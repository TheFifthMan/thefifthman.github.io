<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-25T13:49:35.569Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python模块-协程</title>
    <link href="http://yoursite.com/2018/07/25/python%E6%A8%A1%E5%9D%97-%E5%8D%8F%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/07/25/python模块-协程/</id>
    <published>2018-07-25T13:41:40.000Z</published>
    <updated>2018-07-25T13:49:35.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="协程"><a class="markdownIt-Anchor" href="#协程"></a> 协程</h1><p>首先写一段简单的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">async def test1():</span><br><span class="line">    await test2()</span><br><span class="line">    print(&apos;This is test1&apos;)</span><br><span class="line">    </span><br><span class="line">async def test2():</span><br><span class="line">    print(&quot;This is test2&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ ==&quot;__main__&quot;:</span><br><span class="line">    b = test1()</span><br><span class="line">    b.send(None)</span><br></pre></td></tr></table></figure><p>很简单的代码，加上async以后，这个函数就成了一个异步函数。异步函数需要通过send() 方法才能执行。否则会报错。</p><h1 id="之前的疑惑"><a class="markdownIt-Anchor" href="#之前的疑惑"></a> 之前的疑惑</h1><p>之前最大的疑惑就是，test2都被挂起在那里了，就只有单线程，单线程都去执行test1了，怎么test2还会有值会返回？</p><p>后来陆续看了一些文章，涉及到了系统底层。系统将这样的IO变化称之为事件变化，提供了专门的模块来进行处理，所以，很明显test2触发了，比如发送请求了，但是没返回，所以先把test2挂起来以后，就由系统去检测其IO变化，一旦有值返回了，系统回来告诉应用程序，应用程序通过回调函数对值做处理。</p><h1 id="简单的协程代码"><a class="markdownIt-Anchor" href="#简单的协程代码"></a> 简单的协程代码</h1><p>在python里面，只有调用了 send方法，协程函数才会去调用一次，所以要整个协程放进去事件循环里面，才能完全的执行完协程函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">from datetime import datetime</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">test1 start 2018-07-25 14:35:56.808890</span><br><span class="line">test1 start 2018-07-25 14:35:56.808890</span><br><span class="line">test1 start 2018-07-25 14:35:56.808890</span><br><span class="line">test1 done 2018-07-25 14:36:01.835863</span><br><span class="line">test1 done 2018-07-25 14:36:01.835863</span><br><span class="line">test1 done 2018-07-25 14:36:01.835863</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">async def test1():</span><br><span class="line">    print(&quot;test1 start &#123;&#125;&quot;.format(datetime.now()))</span><br><span class="line">    await asyncio.sleep(5)</span><br><span class="line">    print(&quot;test1 done &#123;&#125;&quot;.format(datetime.now()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    a = test1()</span><br><span class="line">    b = test1()</span><br><span class="line">    c = test1()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    tasks = [</span><br><span class="line">        asyncio.ensure_future(a),</span><br><span class="line">        asyncio.ensure_future(b),</span><br><span class="line">        asyncio.ensure_future(c),</span><br><span class="line">    ]</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks)) # 如果是task，必须要wait一下。</span><br></pre></td></tr></table></figure><p>在这一段代码里面，run_until_complete将协程包装成了一个task对象，也就是Future类的子类，保存了协程运行后的状态，方便后面IO变化以后，用于获取协程的结果。</p><h1 id="增加回调函数"><a class="markdownIt-Anchor" href="#增加回调函数"></a> 增加回调函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">I am test1 and the param is 2</span><br><span class="line">the waitting x is 20</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">async def test1(x):</span><br><span class="line">    print(&quot;I am test1 and the param is &#123;&#125;&quot;.format(x))</span><br><span class="line">    await asyncio.sleep(10)</span><br><span class="line">    return x*10</span><br><span class="line"></span><br><span class="line"># param 是一个future对象。想象一下，这个类来自未来。</span><br><span class="line">def callback(param):</span><br><span class="line">    print(&apos;the waitting x is &#123;&#125;&apos;.format(param.result()))</span><br><span class="line"></span><br><span class="line">a = test1(2)</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">task = asyncio.ensure_future(a)</span><br><span class="line">task.add_done_callback(callback)</span><br><span class="line">loop.run_until_complete(task)</span><br></pre></td></tr></table></figure><p>调用了一个回调函数，用于处理异步函数test1的返回值。如果回调函数需要增加参数，可以使用functools.partial。</p><p>使用回调函数需要十分小心，避免掉进回调的地狱。 这里我们使用同步的方式来处理异步函数返回来的值，而不一定使用回调函数，其方式就是借用future对象，可以取到异步执行后的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">I am test1 and the param is 2</span><br><span class="line">20</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">async def test1(x):</span><br><span class="line">    print(&quot;I am test1 and the param is &#123;&#125;&quot;.format(x))</span><br><span class="line">    await asyncio.sleep(10)  # 这里是异步操作，所以可以挂起</span><br><span class="line">    return x*10</span><br><span class="line"></span><br><span class="line">a = test1(2)</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"># task 是来自未来的对象</span><br><span class="line">task = asyncio.ensure_future(a)</span><br><span class="line">loop.run_until_complete(task)</span><br><span class="line">print(task.result())</span><br></pre></td></tr></table></figure><h1 id="线程阻塞问题"><a class="markdownIt-Anchor" href="#线程阻塞问题"></a> 线程阻塞问题</h1><p>在使用requests的时候，会阻塞掉唯一的线程，就是说你的函数虽然是异步的，但是在这个异步的函数里面，有阻塞线程的调用，于是，你没办法挂起这个函数。这个时候，可以开一个线程让它去阻塞，而当前线程继续执行。当然这样做，就成了多线程了就是。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">from datetime import datetime</span><br><span class="line">import time,requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def run(url):</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    print(&apos;start &#123;&#125; and time is &#123;&#125;&apos;.format(url,datetime.now()))</span><br><span class="line">    try:</span><br><span class="line">        task = loop.run_in_executor(None,requests.get,url)</span><br><span class="line">        #task2 = loop.run_in_executor(None,time.sleep,10)</span><br><span class="line">        complete,pending = await asyncio.wait([task])</span><br><span class="line">        for t in complete:</span><br><span class="line">            print(t.result())</span><br><span class="line"></span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(e)</span><br><span class="line"></span><br><span class="line">    print(&apos;done &#123;&#125; and time is &#123;&#125;&apos;.format(url,datetime.now()))</span><br><span class="line"></span><br><span class="line">url_list = [&apos;http://www.baidu.com&apos;,&apos;http://www.google.com&apos;,&apos;http://www.sina.com.cn&apos;]</span><br><span class="line">tasks = [asyncio.ensure_future(run(url)) for url in url_list]</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"># 这里是并发的场景，每当有协程挂起，就需要wait，如果没加，就会报错。</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start http://www.baidu.com and time is 2018-07-25 15:37:57.221670</span><br><span class="line">start http://www.google.com and time is 2018-07-25 15:37:57.222670</span><br><span class="line">start http://www.sina.com.cn and time is 2018-07-25 15:37:57.223670</span><br><span class="line">done http://www.sina.com.cn and time is 2018-07-25 15:38:07.759670</span><br><span class="line">done http://www.google.com and time is 2018-07-25 15:38:07.936670</span><br><span class="line">done http://www.baidu.com and time is 2018-07-25 15:38:08.014670</span><br></pre></td></tr></table></figure><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>在协程中，因为很多请求是同步的，会阻塞掉当前的线程，你根本无法挂起这个请求，执行并发，除非使用一些异步框架来做，或者如上开一个另外的线程来 做这种阻塞的动作。这样其实跟多线程没啥区别了，有待研究。当然可以使用gevent这样的框架来做，可以用写同步函数的方式来做异步IO的事情，执行并发等等，但是也有其他的一些缺陷，但是对其底层不了解的话，很容易出现不知所谓的错误。<br>优点：<br>协程开销小</p><p>缺点：<br>复杂<br>一旦异步，全部都必须异步。</p><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h1><ol><li><p><a href="http://www.dongwm.com/archives/%E4%BD%BF%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-asyncio%E7%AF%87/" target="_blank" rel="noopener">http://www.dongwm.com/archives/使用Python进行并发编程-asyncio篇/</a></p></li><li><p><a href="http://thief.one/2018/06/21/1/" target="_blank" rel="noopener">http://thief.one/2018/06/21/1/</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;协程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#协程&quot;&gt;&lt;/a&gt; 协程&lt;/h1&gt;
&lt;p&gt;首先写一段简单的代码&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
      <category term="python_modules" scheme="http://yoursite.com/categories/python-modules/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python模块-多进程</title>
    <link href="http://yoursite.com/2018/07/25/python%E6%A8%A1%E5%9D%97-%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/07/25/python模块-多进程/</id>
    <published>2018-07-25T12:47:20.000Z</published>
    <updated>2018-07-25T13:41:22.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><ul><li>[x] 多进程概念</li><li>[x] 多进程的Process</li><li>[x] 多进程的Pool</li><li>[x] 多进程的Pool相关函数</li><li>[x] 基于队列的多进程</li></ul><h1 id="多进程概念"><a class="markdownIt-Anchor" href="#多进程概念"></a> 多进程概念</h1><blockquote><p>顾名思义，多进程就是多个进程，可以并发执行任务，从而提高效率，在python中，因为全局锁的原因，对于CPU密集的任务，多线程起不到任何的作用，反而会因为线程切换，而导致效率下降。而多进程可以解决这个问题。</p></blockquote><p>多进程一般有两种实现方式</p><ol><li>Process</li><li>Pool</li></ol><h1 id="多进程的process"><a class="markdownIt-Anchor" href="#多进程的process"></a> 多进程的Process</h1><p>首先先上代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import os</span><br><span class="line">from datetime import datetime</span><br><span class="line">def run_proc(name):</span><br><span class="line">    print(&apos;Child process &#123;0&#125; is running&apos;.format(name,os.getpid()))</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    print(&apos;parent process &#123;&#125; is running&apos;.format(os.getpid()))</span><br><span class="line">    for i in range(5):</span><br><span class="line">        p = Process(target=run_proc,args=(str(i),))</span><br><span class="line">        print(&apos;process start &#123;&#125;&apos;.format(datetime.now()))</span><br><span class="line">        p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    print(&apos;close&apos;)</span><br></pre></td></tr></table></figure><p>很简单的代码示例，跟多线程有点像。</p><h1 id="多进程的pool"><a class="markdownIt-Anchor" href="#多进程的pool"></a> 多进程的Pool</h1><p>有时候进程开的太多容易使得程序崩溃。这个时候可以通过进程池来解决这个问题，如果启动的进程达到了池子里面的数量，就会先执行当前的进程，执行完一个再放进来一个。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">#-*-coding:utf-8-*-</span><br><span class="line"># Pool 指定数量的进程，默认是CPU数量，如果池子没有满，就创建一个新进程，否则就等待</span><br><span class="line"># apply_async 允许多个进程进入池子进行执行</span><br><span class="line"># apply 只允许一个进程</span><br><span class="line"></span><br><span class="line">from multiprocessing import Process,Pool</span><br><span class="line">import os</span><br><span class="line">from datetime import datetime</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def run_proc(i):</span><br><span class="line">    time.sleep(10)</span><br><span class="line">    print(&apos;[process &#123;&#125;]I am child process &#123;&#125; and the start time is &#123;&#125;&apos;.format(i,os.getpid(),datetime.now()))</span><br><span class="line">    time.sleep(10)</span><br><span class="line">    print(&apos;task done&apos;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    p = Pool(processes=os.cpu_count())</span><br><span class="line">    for i in range(10):</span><br><span class="line">        p.apply_async(run_proc,args=(str(i),))</span><br><span class="line">        #p.apply(run_proc,args=(str(i),))</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    print(&apos;all done&apos;)</span><br></pre></td></tr></table></figure><h1 id="多进程的pool相关函数"><a class="markdownIt-Anchor" href="#多进程的pool相关函数"></a> 多进程的Pool相关函数</h1><h3 id="start"><a class="markdownIt-Anchor" href="#start"></a> start()</h3><blockquote><p>启动进程</p></blockquote><h3 id="join"><a class="markdownIt-Anchor" href="#join"></a> join()</h3><blockquote><p>跟多线程一样，使用了join函数，会使得主进程等待子进程结束才会结束，否则就会提前结束</p></blockquote><h3 id="name"><a class="markdownIt-Anchor" href="#name"></a> name</h3><blockquote><p>这不是函数，是一个属性，指的是进程的名字</p></blockquote><h3 id="is_alive"><a class="markdownIt-Anchor" href="#is_alive"></a> is_alive()</h3><blockquote><p>检查进程是否存活，除非进程terminates了。</p></blockquote><h3 id="close"><a class="markdownIt-Anchor" href="#close"></a> close()</h3><blockquote><p>close函数必须要在join函数前面，调用了close函数以后，就不能再添加进程了。这里的close指的是关闭进程池。在Pool里面一定要关闭进程池，而且<mark>必须要在join面前</mark>，要不执行不了。找不到更多的解释，估计很多人也是一知半解。</p></blockquote><h3 id="terminate"><a class="markdownIt-Anchor" href="#terminate"></a> terminate</h3><blockquote><p>结束当前的进程，不在处理</p></blockquote><h1 id="基于队列的多进程"><a class="markdownIt-Anchor" href="#基于队列的多进程"></a> 基于队列的多进程</h1><p>一个简单的多进程队列例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">#-*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">from multiprocessing import Queue,Pool,Process</span><br><span class="line"></span><br><span class="line"># 使用队列进行多进程</span><br><span class="line"></span><br><span class="line">def producer(q):</span><br><span class="line">    for i in range(20):</span><br><span class="line">        q.put(i)</span><br><span class="line"></span><br><span class="line">def worker(q):</span><br><span class="line">    while not q.empty():</span><br><span class="line">        item = q.get()</span><br><span class="line">        print(item)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # 在这里加入队列</span><br><span class="line">    q=Queue()</span><br><span class="line">    producer(q)</span><br><span class="line">    for i in range(10):</span><br><span class="line">        p = Process(target=worker,args=(q,))</span><br><span class="line">        p.start()</span><br><span class="line">    </span><br><span class="line">    p.join()</span><br><span class="line">    print(&quot;done&quot;)</span><br></pre></td></tr></table></figure><p>但是需要注意的是，这里的Queue只适用于Process在，不适用于Pool</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;[x] 多进程概念&lt;/li&gt;
&lt;li&gt;[x] 多进程的Process&lt;/li&gt;
&lt;li&gt;[x] 多进程的Pool&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="python_modules" scheme="http://yoursite.com/categories/python-modules/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>移动端测试1-MAC下配置Android Studio环境</title>
    <link href="http://yoursite.com/2018/07/22/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%951-MAC%E4%B8%8B%E9%85%8D%E7%BD%AEAndroid-Studio%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2018/07/22/移动端测试1-MAC下配置Android-Studio环境/</id>
    <published>2018-07-22T14:33:51.000Z</published>
    <updated>2018-07-25T12:43:57.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>本来安装工具这种东西是没什么好记录的，点点点就完了，但是因为我国的特殊网络环境，发现在下载android的SDK，一直报&quot; SDK tools directory is missing&quot; 试过多种方法，多种镜像网站，发现均不能下载。最后终于找到解决方法了</p><h1 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h1><h3 id="设置代理"><a class="markdownIt-Anchor" href="#设置代理"></a> 设置代理</h3><p>testhome提供了http代理地址：<br><img src="https://testerhome.com/uploads/photo/2018/c4f0647b-6255-4631-b2f9-24f654d91c4c.png" alt="image"></p><p>其中port number，比如今天是7月22号，port number就是 60722</p><h3 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h3><p>还有一个坑就是，在mac下面删除android，直接从app里面删除是不够的。下面提供彻底删除的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rm -Rf /Applications/Android\ Studio.app</span><br><span class="line">rm -Rf ~/Library/Preferences/AndroidStudio*</span><br><span class="line">rm ~/Library/Preferences/com.google.android.studio.plist</span><br><span class="line">rm -Rf ~/Library/Application\ Support/AndroidStudio*</span><br><span class="line">rm -Rf ~/Library/Logs/AndroidStudio*</span><br><span class="line">rm -Rf ~/Library/Caches/AndroidStudio*</span><br><span class="line">rm -Rf ~/.gradle</span><br><span class="line">rm -Rf ~/.android</span><br><span class="line">rm -Rf ~/Library/Android*</span><br></pre></td></tr></table></figure><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>算是做为了解移动端的一个起步吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h1&gt;
&lt;p&gt;本来安装工具这种东西是没什么好记录的，点点点就完了，但是因为我国的特殊网络环境，发现在下载android的SDK，一直报&amp;quot; SDK t
      
    
    </summary>
    
      <category term="测试" scheme="http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>python学习-装饰器</title>
    <link href="http://yoursite.com/2018/07/22/python%E5%AD%A6%E4%B9%A0-%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://yoursite.com/2018/07/22/python学习-装饰器/</id>
    <published>2018-07-22T14:17:13.000Z</published>
    <updated>2018-07-25T13:43:19.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>学习一下python的装饰器函数。关于装饰器的定义，底层，肯定说得不如网上的文章好。这里就简单记录一下其使用。</p><h1 id="需求"><a class="markdownIt-Anchor" href="#需求"></a> 需求</h1><p>python的装饰器其实是一种面向切面的编程方式，可以将大量可复用的代码抽离出来进行复用，这样的编程方式显得优雅。其主要需求有几种：</p><ol><li>插入日志</li><li>性能测试</li><li>权限检验</li><li>事务处理</li><li>缓存</li><li>…</li></ol><h1 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h1><p>装饰器的语法也很简单，其原理可以先这样理解：<br>假设我们要为一个函数打印log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def foo():</span><br><span class="line">    print(&quot;I am foo&quot;)</span><br><span class="line">    </span><br><span class="line">def print_log_for_foo(func):</span><br><span class="line">    print(&quot;Hello log&quot;)</span><br><span class="line">    func()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">print_log_for_foo(foo)</span><br></pre></td></tr></table></figure><p>这样我们就为foo打印了log，但不是很优雅，因为我们调用的是另一个函数，这样显得杂乱无章。用了装饰器就显得清晰明白了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def decoration(func):</span><br><span class="line">    def wrapper(*args,**kw):</span><br><span class="line">        print(&quot;Hello logs&quot;)</span><br><span class="line">        return func(*args,**kw)</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">@decoration    </span><br><span class="line">def foo():</span><br><span class="line">    print(&apos;Hello I am foo&apos;)</span><br><span class="line">    </span><br><span class="line">foo() # 调用foo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 输出</span><br><span class="line">Hello logs</span><br><span class="line">Hello I am foo</span><br></pre></td></tr></table></figure><p>同样的，这样还存在一些问题，[foo函数]被[wrapper函数]包裹住了，这个时候，函数的元信息就变成了[wrapper函数]的了.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(foo.__name__) # wrapper</span><br></pre></td></tr></table></figure><p>这个时候我们要引入另一个装饰函数，把元信息也给传进去.<br>所以废话这么多，完整的case是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from functools import wraps</span><br><span class="line">def decoration(func):</span><br><span class="line">    @wraps(func)</span><br><span class="line">    def wrapper(*args,**kw):</span><br><span class="line">        print(&quot;Hello logs&quot;)</span><br><span class="line">        return func(*args,**kw)</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">@decoration    </span><br><span class="line">def foo():</span><br><span class="line">    print(&apos;Hello I am foo&apos;)</span><br><span class="line">    </span><br><span class="line">a = foo() # 调用foo</span><br><span class="line">print(foo.__name__) # foo</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 输出</span><br><span class="line">Hello logs</span><br><span class="line">Hello I am foo</span><br><span class="line">foo</span><br></pre></td></tr></table></figure><h1 id="类装饰器"><a class="markdownIt-Anchor" href="#类装饰器"></a> 类装饰器</h1><p>类也有装饰器，其装饰器是通过<figure class="highlight plain"><figcaption><span>函数```来实现的.通过@调用了这个函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>class Decorations(object):<br>def <strong>init</strong>(self,func):<br>self.func = func</p><pre><code>def __call__(self):    print('Hello i am decarations')    self.func()</code></pre><p>@Decorations<br>def foo():<br>print(‘i am foo’)</p><p>foo()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">类装饰器具有以下优点</span><br><span class="line">1. 灵活度大</span><br><span class="line">2. 高内聚</span><br><span class="line">3. 封装性</span><br><span class="line"></span><br><span class="line"># 总结</span><br><span class="line">当然平时一些小东西，也就用函数装饰器就足够使用了。</span><br><span class="line">最后附上写flask时候验证admin权限的装饰器</span><br></pre></td></tr></table></figure><p>def adminRequired(func):<br>@functools.wraps(func)<br>def decoration(*args,**kw):<br>if current_user.is_authenticated and current_user.is_admin == 1:<br>return func(*args,**kw)<br>else:<br>return redirect(url_for(‘auth.login’))<br>return decoration</p><p>@admin.route(’/’)<br>@adminRequired<br>def home():<br>return “Hello This is admin”</p><pre class="highlight"><code class=""># 参考https://foofish.net/python-decorator.html https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014318435599930270c0381a3b44db991cd6d858064ac0000 </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h1&gt;
&lt;p&gt;学习一下python的装饰器函数。关于装饰器的定义，底层，肯定说得不如网上的文章好。这里就简单记录一下其使用。&lt;/p&gt;
&lt;h1 id=&quot;需求&quot;&gt;
      
    
    </summary>
    
      <category term="python_modules" scheme="http://yoursite.com/categories/python-modules/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>自动化测试-ui自动化+docker</title>
    <link href="http://yoursite.com/2018/07/19/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95-ui%E8%87%AA%E5%8A%A8%E5%8C%96-docker/"/>
    <id>http://yoursite.com/2018/07/19/自动化测试-ui自动化-docker/</id>
    <published>2018-07-19T15:54:54.000Z</published>
    <updated>2018-07-19T15:55:54.801Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>在docker里面创建UI自动化测试平台</p><h1 id="搭建环境"><a class="markdownIt-Anchor" href="#搭建环境"></a> 搭建环境</h1><h2 id="安装docker"><a class="markdownIt-Anchor" href="#安装docker"></a> 安装docker</h2><p>详细见docker官方文档</p><h2 id="安装selenoid"><a class="markdownIt-Anchor" href="#安装selenoid"></a> 安装selenoid</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">docker pull aerokube/selenoid:latest-release</span><br><span class="line">mkdir -p /data/config</span><br><span class="line">vim /data/config/browsers.json</span><br><span class="line">---------------------------</span><br><span class="line">&#123;</span><br><span class="line">    &quot;firefox&quot;: &#123;</span><br><span class="line">        &quot;default&quot;: &quot;57.0&quot;,</span><br><span class="line">        &quot;versions&quot;: &#123;</span><br><span class="line">            &quot;57.0&quot;: &#123;</span><br><span class="line">                &quot;image&quot;: &quot;selenoid/vnc:firefox_57.0&quot;,</span><br><span class="line">                &quot;port&quot;: &quot;4444&quot;,</span><br><span class="line">                &quot;path&quot;: &quot;/wd/hub&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------</span><br><span class="line"></span><br><span class="line">docker run -d       \</span><br><span class="line">--name selenoid   \</span><br><span class="line">-p 14444:4444     \</span><br><span class="line">-v /data/config:/etc/selenoid/:ro \</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">aerokube/selenoid:latest-release</span><br></pre></td></tr></table></figure><p>注意：最好使用其他的端口转发4444端口。4444端口不是安全的，应该禁止掉。</p><h2 id="安装selenoid-ui"><a class="markdownIt-Anchor" href="#安装selenoid-ui"></a> 安装selenoid ui</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker pull aerokube/selenoid-ui</span><br><span class="line">如果selenoid是跟selenoid-ui安装在一起的话，那么需要查看selenoid的IP</span><br><span class="line">&gt;&gt;&gt; ifconfig | grep -E &quot;([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;&quot; | grep -v 127.0.0.1 | awk &apos;&#123; print $2 &#125;&apos; | cut -f2 -d: | head -n1</span><br><span class="line">&gt;&gt;&gt; 172.17.0.1</span><br><span class="line">&gt;&gt;&gt; docker run -d --name selenoid-ui -p 8080:8080 aerokube/selenoid-ui --selenoid-uri http://172.17.0.1:14444</span><br></pre></td></tr></table></figure><h1 id="操作"><a class="markdownIt-Anchor" href="#操作"></a> 操作</h1><p>在本地写好脚本，用python撸了一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import selenium </span><br><span class="line">from selenium import webdriver</span><br><span class="line">        </span><br><span class="line">capabilities = &#123;</span><br><span class="line">    &quot;browserName&quot;: &quot;firefox&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;57.0&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">driver = webdriver.Remote(</span><br><span class="line">    command_executor=&quot;http://192.168.31.236:4444/wd/hub&quot;,</span><br><span class="line">    desired_capabilities=capabilities)</span><br><span class="line"></span><br><span class="line">driver.get(&apos;https://www.baidu.com&apos;)</span><br><span class="line">print(driver.title)</span><br></pre></td></tr></table></figure><p>然后你就可以看到成功运行的样子<br><img src="https://raw.githubusercontent.com/TheFifthMan/postimages/master/selenium/success.jpg" alt="image"></p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>然后打开 <a href="http://yourip:8080" target="_blank" rel="noopener">http://yourip:8080</a> 就可以打开相应的webUI界面，在这里我们可以看到selenoid的使用方法，最后编写相应的脚本放上去跑就可以了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h1&gt;
&lt;p&gt;在docker里面创建UI自动化测试平台&lt;/p&gt;
&lt;h1 id=&quot;搭建环境&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href
      
    
    </summary>
    
      <category term="自动化测试" scheme="http://yoursite.com/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="ui自动化" scheme="http://yoursite.com/tags/ui%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>03-项目搭建</title>
    <link href="http://yoursite.com/2018/07/09/03-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2018/07/09/03-项目搭建/</id>
    <published>2018-07-08T16:08:42.000Z</published>
    <updated>2018-07-08T16:08:59.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>这一节有以下要点</p><ul><li>[ ] 项目分析</li><li>[ ] 项目目录</li><li>[ ] 安装基础插件及环境</li><li>[ ] 蓝图</li><li>[ ] 代码</li></ul><h1 id="项目分析"><a class="markdownIt-Anchor" href="#项目分析"></a> 项目分析</h1><p><img src="https://raw.githubusercontent.com/TheFifthMan/postimages/master/flask_microMovie/%e9%a1%b9%e7%9b%ae%e5%88%86%e6%9e%90%e5%89%8d%e5%8f%b0.png" alt="image"><br><img src="https://raw.githubusercontent.com/TheFifthMan/postimages/master/flask_microMovie/%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90%E5%90%8E%E5%8F%B0.png" alt="image"></p><h1 id="项目目录"><a class="markdownIt-Anchor" href="#项目目录"></a> 项目目录</h1><p><img src="https://raw.githubusercontent.com/TheFifthMan/postimages/master/flask_microMovie/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png" alt="image"></p><h1 id="安装基础插件及环境"><a class="markdownIt-Anchor" href="#安装基础插件及环境"></a> 安装基础插件及环境</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd micromovie</span><br><span class="line">python -m venv venv</span><br><span class="line">source .\venv\bin\activate</span><br><span class="line">pip install flask</span><br><span class="line">git init </span><br><span class="line">git checkout -b day01</span><br></pre></td></tr></table></figure><h1 id="程序工程函数"><a class="markdownIt-Anchor" href="#程序工程函数"></a> 程序工程函数</h1><p>如果全局创建程序，也就是<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">#app/__init__.py</span><br><span class="line"></span><br><span class="line">from flask import Flask</span><br><span class="line">from config import Configuration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def create_app(config_name):</span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    app.config.from_object(Configuration[config_name])</span><br><span class="line"></span><br><span class="line">    from .frontend import index as index_blueprint</span><br><span class="line">    app.register_blueprint(index_blueprint)</span><br><span class="line"></span><br><span class="line">    from .backend import backoffice as backoffice_blueprint</span><br><span class="line">    app.register_blueprint(backoffice_blueprint,url_prefix=&apos;/backoffice&apos;) </span><br><span class="line"></span><br><span class="line">    return app</span><br></pre></td></tr></table></figure></p><h1 id="蓝图"><a class="markdownIt-Anchor" href="#蓝图"></a> 蓝图</h1><p><img src="https://raw.githubusercontent.com/TheFifthMan/postimages/master/flask_microMovie/%E8%93%9D%E5%9B%BE%E7%AE%80%E4%BB%8B.png" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># movie/frontend/__init__.py</span><br><span class="line"></span><br><span class="line">from flask import Blueprint</span><br><span class="line">index = Blueprint(&apos;index&apos;,__name__)</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line"># movie/backoffice/__init__.py</span><br><span class="line">from flask import Blueprint</span><br><span class="line">backoffice = Blueprint(&apos;backoffice&apos;,__name__)</span><br><span class="line">from . import views</span><br></pre></td></tr></table></figure><ul><li>注意点：<mark>注意包的引入格式。</mark></li></ul><h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码：</h1><p><a href="https://github.com/TheFifthMan/micromovie/tree/day01" target="_blank" rel="noopener">https://github.com/TheFifthMan/micromovie/tree/day01</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h1&gt;
&lt;p&gt;这一节有以下要点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[ ] 项目分析&lt;/li&gt;
&lt;li&gt;[ ] 项目目录&lt;/li&gt;
&lt;li&gt;[ ] 安装基础插件及环境&lt;
      
    
    </summary>
    
      <category term="micro_movie" scheme="http://yoursite.com/categories/micro-movie/"/>
    
    
      <category term="flask" scheme="http://yoursite.com/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>python模块-requests</title>
    <link href="http://yoursite.com/2018/07/08/python%E6%A8%A1%E5%9D%97-requests/"/>
    <id>http://yoursite.com/2018/07/08/python模块-requests/</id>
    <published>2018-07-08T15:32:50.000Z</published>
    <updated>2018-07-08T15:33:21.899Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>requests是python中热门的模块，它封装了python底层的库，并且更加容易使用。在python爬虫中非常常见的使用这个框架作为其请求的发送，这里记录其部分常见用法。</p><h1 id="requests"><a class="markdownIt-Anchor" href="#requests"></a> requests</h1><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install reqeusts</span><br></pre></td></tr></table></figure><h2 id="简单使用"><a class="markdownIt-Anchor" href="#简单使用"></a> 简单使用</h2><h3 id="post请求"><a class="markdownIt-Anchor" href="#post请求"></a> POST请求</h3><h5 id="x-www-form-urlencode"><a class="markdownIt-Anchor" href="#x-www-form-urlencode"></a> x-www-form-urlencode</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data=&#123;</span><br><span class="line">&quot;xx&quot;:&quot;yy&quot;,</span><br><span class="line">&quot;aa&quot;:&quot;bb&quot;</span><br><span class="line">&#125;</span><br><span class="line">r = requests.post(&quot;http://www.posturl.com&quot;,data=data)</span><br></pre></td></tr></table></figure><h5 id="json"><a class="markdownIt-Anchor" href="#json"></a> json</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">json=&quot;&#123;&apos;type&apos;:&apos;post&apos;,&apos;age&apos;:123&#125;&quot;</span><br><span class="line">r = requests.post(url,data=json)</span><br></pre></td></tr></table></figure><h2 id="get"><a class="markdownIt-Anchor" href="#get"></a> GET</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">headers=&#123;</span><br><span class="line">&quot;user-agent&quot;:&apos;xxxx&apos;,</span><br><span class="line">&#125;</span><br><span class="line">r=requests.get(url,headers=headers)</span><br></pre></td></tr></table></figure><h1 id="高级使用"><a class="markdownIt-Anchor" href="#高级使用"></a> 高级使用</h1><h2 id="有时候某些场景会出现ssl错误我们需要禁用"><a class="markdownIt-Anchor" href="#有时候某些场景会出现ssl错误我们需要禁用"></a> 有时候某些场景会出现SSL错误，我们需要禁用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from urllib3.exceptions import InsecureRequestWarning</span><br><span class="line">requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)</span><br><span class="line"></span><br><span class="line">requests.api.request(&apos;post&apos;, url, data=&#123;&apos;bar&apos;:&apos;baz&apos;&#125;, json=None, verify=False)</span><br></pre></td></tr></table></figure><h2 id="我们需要session来保持网站的连接"><a class="markdownIt-Anchor" href="#我们需要session来保持网站的连接"></a> 我们需要session来保持网站的连接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session = requests.session()</span><br><span class="line">response = session.get(url)</span><br></pre></td></tr></table></figure><h2 id="上传文件模拟"><a class="markdownIt-Anchor" href="#上传文件模拟"></a> 上传文件模拟</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; url = &apos;http://httpbin.org/post&apos;</span><br><span class="line">&gt;&gt;&gt; files = &#123;&apos;file&apos;: (&apos;report.xls&apos;, open(&apos;report.xls&apos;, &apos;rb&apos;), &apos;application/vnd.ms-excel&apos;, &#123;&apos;Expires&apos;: &apos;0&apos;&#125;)&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; r = requests.post(url, files=files)</span><br><span class="line">&gt;&gt;&gt; r.text</span><br></pre></td></tr></table></figure><h2 id="responsetext-和-responsecontent"><a class="markdownIt-Anchor" href="#responsetext-和-responsecontent"></a> response.text 和 response.content</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">text是正常的字符流</span><br><span class="line">content是二进制的字节流，常用于图片的传输</span><br></pre></td></tr></table></figure><h1 id="例子"><a class="markdownIt-Anchor" href="#例子"></a> 例子</h1><p>结合unittest做API测试框架</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install html-testRunner</span><br><span class="line">pip install requests</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> HtmlTestRunner</span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestPyRequest</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.url = <span class="string">'https://api.douban.com'</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_douban_api</span><span class="params">(self)</span>:</span></span><br><span class="line">    r = requests.get(self.url+<span class="string">'/v2/movie/top250'</span>,verify=<span class="keyword">False</span>)</span><br><span class="line">    self.assertTrue(r.status_code,<span class="number">200</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  unittest.main(testRunner=HtmlTestRunner.HTMLTestRunner(output=<span class="string">'.'</span>))</span><br></pre></td></tr></table></figure><p>以上我们就完成了一个以requests发送请求，以html-testRunner生成report，unittest作为验证断言的api框架，（以上代码只为简略的演示。）</p><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h1><p><a href="http://docs.python-requests.org/zh_CN/latest/" target="_blank" rel="noopener">http://docs.python-requests.org/zh_CN/latest/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h1&gt;
&lt;p&gt;requests是python中热门的模块，它封装了python底层的库，并且更加容易使用。在python爬虫中非常常见的使用这个框架作为其请求
      
    
    </summary>
    
      <category term="python_modules" scheme="http://yoursite.com/categories/python-modules/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>00-课程导学</title>
    <link href="http://yoursite.com/2018/07/06/00-%E8%AF%BE%E7%A8%8B%E5%AF%BC%E5%AD%A6/"/>
    <id>http://yoursite.com/2018/07/06/00-课程导学/</id>
    <published>2018-07-05T16:04:08.000Z</published>
    <updated>2018-07-05T16:05:00.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>这是一套来自慕课网的视频教程。记录一下学习过程。</p><h1 id="框架知识"><a class="markdownIt-Anchor" href="#框架知识"></a> 框架知识</h1><p>通过学习本课程，可学习到的知识</p><ol><li>学会使用整型，浮点型，路径型，字符型正则表达式路由转换器</li><li>学会使用post和get请求，上传文件，cookie，获取和响应，404请求</li><li>学会使用模板自动转义，定义过滤器，定义全局上下文处理器，jinja2语法，包含，继承，定义宏</li><li>学会使用flask-wtf定义表单模型，字段类型，字段验证，视图处理表单，模板使用表单</li><li>学会使用flask-sqlalchemy定义数据库模型，提那家数据，修改数据，查询数据，删除数据，数据库事件，数据迁移</li><li>学会使用蓝图优化项目结构，实现微电影网站前台和后台的逻辑</li><li>学会flask的部署方法，安装编译nginx服务，安装编译python3服务，安装mysql服务，通过nginx反向代理对视频流媒体限制下载速率，限制单个IP能发起的播放连接数</li></ol><h1 id="微内核"><a class="markdownIt-Anchor" href="#微内核"></a> 微内核</h1><ol><li>werkzug工具箱</li><li>pymysql</li><li>flask-sqlalchemy</li><li>wtforms</li><li>jinja2</li><li>flask-script</li><li>functools定义高阶函数</li></ol><h1 id="视频技术"><a class="markdownIt-Anchor" href="#视频技术"></a> 视频技术</h1><ol><li>jwplayer播放器插件</li><li>视频限速限IP访问</li><li>flv,mp4视频格式支持</li><li>nginx点播实现</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h1&gt;
&lt;p&gt;这是一套来自慕课网的视频教程。记录一下学习过程。&lt;/p&gt;
&lt;h1 id=&quot;框架知识&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; 
      
    
    </summary>
    
      <category term="micro_movie" scheme="http://yoursite.com/categories/micro-movie/"/>
    
    
      <category term="flask" scheme="http://yoursite.com/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>02-环境搭建</title>
    <link href="http://yoursite.com/2018/07/06/02-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2018/07/06/02-环境搭建/</id>
    <published>2018-07-05T16:03:39.000Z</published>
    <updated>2018-07-05T16:05:41.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><ol><li>windows环境搭建</li><li>mac环境搭建</li><li>mysql常规配置</li></ol><h1 id="windows搭建"><a class="markdownIt-Anchor" href="#windows搭建"></a> windows搭建</h1><h3 id="0-下载简介"><a class="markdownIt-Anchor" href="#0-下载简介"></a> 0. 下载简介</h3><p><img src="https://raw.githubusercontent.com/TheFifthMan/postimages/master/flask_microMovie/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%9C%B0%E5%9D%80.png" alt="image"></p><h3 id="1-下载安装python3"><a class="markdownIt-Anchor" href="#1-下载安装python3"></a> 1. 下载安装python3</h3><h3 id="2-下载安装mysql"><a class="markdownIt-Anchor" href="#2-下载安装mysql"></a> 2. 下载安装mysql</h3><p><img src="https://raw.githubusercontent.com/TheFifthMan/postimages/master/flask_microMovie/mysql%E5%AE%89%E8%A3%851.png" alt="image"><br><img src="https://raw.githubusercontent.com/TheFifthMan/postimages/master/flask_microMovie/mysql%E5%AE%89%E8%A3%852.png" alt="image"><br><img src="https://raw.githubusercontent.com/TheFifthMan/postimages/master/flask_microMovie/mysql%E5%AE%89%E8%A3%853.png" alt="image"><br><img src="https://raw.githubusercontent.com/TheFifthMan/postimages/master/flask_microMovie/mysql%E5%AE%89%E8%A3%854.png" alt="image"><br><img src="https://raw.githubusercontent.com/TheFifthMan/postimages/master/flask_microMovie/mysql%E5%AE%89%E8%A3%855.png" alt="image"></p><h3 id="3-下载安装pycharm"><a class="markdownIt-Anchor" href="#3-下载安装pycharm"></a> 3. 下载安装pycharm</h3><h3 id="4-指定python下载源"><a class="markdownIt-Anchor" href="#4-指定python下载源"></a> 4. 指定python下载源</h3><p><img src="https://raw.githubusercontent.com/TheFifthMan/postimages/master/flask_microMovie/pypi%E6%BA%901.png" alt="image"></p><p>验证源：<br><img src="https://raw.githubusercontent.com/TheFifthMan/postimages/master/flask_microMovie/pypi%E6%BA%902.png" alt="image"></p><h3 id="5-安装虚拟环境"><a class="markdownIt-Anchor" href="#5-安装虚拟环境"></a> 5. 安装虚拟环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir microMovie</span><br><span class="line">cd microMovie</span><br><span class="line">python -m venv venv </span><br><span class="line">.\venv\Scripts\activate</span><br></pre></td></tr></table></figure><h1 id="mac环境搭建"><a class="markdownIt-Anchor" href="#mac环境搭建"></a> mac环境搭建</h1><ol><li>安装pyenv，用于python环境切换</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">brew install pyenv </span><br><span class="line">cd ~/.pyenv</span><br><span class="line">mkdir cache</span><br><span class="line">pyenv install 3.6.4</span><br><span class="line">pyenv global 3.6.4 </span><br><span class="line">pyenv refresh</span><br></pre></td></tr></table></figure><ol start="2"><li>指定python下载源</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/.pip</span><br><span class="line">cd ~/.pip</span><br><span class="line">vim pip.conf</span><br><span class="line"></span><br><span class="line">-----file content</span><br><span class="line">[global]</span><br><span class="line">trusted-host =  mirrors.aliyun.com</span><br><span class="line">index-url = http://mirrors.aliyun.com/pypi/simple</span><br><span class="line">-----</span><br></pre></td></tr></table></figure><ol start="3"><li>安装docker<br><a href="https://download.docker.com/mac/stable/Docker.dmg" target="_blank" rel="noopener">https://download.docker.com/mac/stable/Docker.dmg</a></li><li>使用docker安装mysql</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql -p 3306:3306 -v /data/mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</span><br><span class="line">docker exec -it /bin/bash</span><br></pre></td></tr></table></figure><h1 id="mysql数据库配置"><a class="markdownIt-Anchor" href="#mysql数据库配置"></a> mysql数据库配置</h1><h3 id="1-mysql修改密码"><a class="markdownIt-Anchor" href="#1-mysql修改密码"></a> 1. mysql修改密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1、修改 /etc/my.cnf，在 [mysqld] 小节下添加一行：skip-grant-tables=1</span><br><span class="line"></span><br><span class="line">这一行配置让 mysqld 启动时不对密码进行验证</span><br><span class="line"></span><br><span class="line">2、重启 mysqld 服务：systemctl restart mysqld</span><br><span class="line"></span><br><span class="line">3、使用 root 用户登录到 mysql：mysql -u root </span><br><span class="line"></span><br><span class="line">4、切换到mysql数据库，更新 user 表：</span><br><span class="line"></span><br><span class="line">update user set authentication_string = password(&apos;wzw011992&apos;), password_expired = &apos;N&apos;, password_last_changed = now() where user = &apos;wluser&apos;;</span><br><span class="line"></span><br><span class="line">在之前的版本中，密码字段的字段名是 password，5.7版本改为了 authentication_string</span><br><span class="line"></span><br><span class="line">5、退出 mysql，编辑 /etc/my.cnf 文件，删除 skip-grant-tables=1 的内容</span><br><span class="line"></span><br><span class="line">6、重启 mysqld 服务，再用新密码登录即可</span><br></pre></td></tr></table></figure><h3 id="2-配置远程用户登录"><a class="markdownIt-Anchor" href="#2-配置远程用户登录"></a> 2. 配置远程用户登录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *(db name).* to &apos;username&apos;@&apos;%&apos; identified by &apos;qwe123&apos; with grant option</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure><h3 id="3-创建本地用户"><a class="markdownIt-Anchor" href="#3-创建本地用户"></a> 3. 创建本地用户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">use awesome;</span><br><span class="line">grant select,insert,update,delete on awesome.* to &apos;john(user)&apos;@&apos;localhost&apos; identified by &apos;qwe123(password)&apos;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><h3 id="4-创建数据库"><a class="markdownIt-Anchor" href="#4-创建数据库"></a> 4. 创建数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database `threatenReport` default character set utf8 collate utf8_general_ci;</span><br></pre></td></tr></table></figure><h3 id="5错误"><a class="markdownIt-Anchor" href="#5错误"></a> 5.错误：</h3><p>61 ： 数据库没有开启远程访问的权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/mysql/my.cnf</span><br><span class="line">bind-address :0.0.0.0</span><br></pre></td></tr></table></figure><p>没有映射端口的话也会出错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -lnp | grep 3306</span><br></pre></td></tr></table></figure><p>数据库连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 127.0.0.1 -u root -p</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;windows环境搭建&lt;/li&gt;
&lt;li&gt;mac环境搭建&lt;/li&gt;
&lt;li&gt;mysql常规配置&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=
      
    
    </summary>
    
      <category term="micro_movie" scheme="http://yoursite.com/categories/micro-movie/"/>
    
    
      <category term="flask" scheme="http://yoursite.com/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>01-项目分析</title>
    <link href="http://yoursite.com/2018/07/06/01-%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/07/06/01-项目分析/</id>
    <published>2018-07-05T16:03:30.000Z</published>
    <updated>2018-07-05T16:05:25.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>首先阐述一下我们要开发的微电影网站。功能还是比较强大的。一图胜前言</p><p><img src="https://raw.githubusercontent.com/TheFifthMan/postimages/master/flask_microMovie/projectneeds.png" alt="image"></p><h1 id="开发和生产环境"><a class="markdownIt-Anchor" href="#开发和生产环境"></a> 开发和生产环境</h1><ol><li>centos</li><li>python3</li><li>mysql</li><li>html5</li><li>flask</li><li>nginx</li><li>pycharm</li></ol><h1 id="框架对比"><a class="markdownIt-Anchor" href="#框架对比"></a> 框架对比</h1><p><img src="https://raw.githubusercontent.com/TheFifthMan/postimages/master/flask_microMovie/%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h1&gt;
&lt;p&gt;首先阐述一下我们要开发的微电影网站。功能还是比较强大的。一图胜前言&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubuse
      
    
    </summary>
    
      <category term="micro_movie" scheme="http://yoursite.com/categories/micro-movie/"/>
    
    
      <category term="flask" scheme="http://yoursite.com/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>python模块-click</title>
    <link href="http://yoursite.com/2018/07/03/python%E6%A8%A1%E5%9D%97-click/"/>
    <id>http://yoursite.com/2018/07/03/python模块-click/</id>
    <published>2018-07-02T16:14:16.000Z</published>
    <updated>2018-07-02T16:14:31.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>我们有时候要实现命令行带参数去执行函数的时候，可以使用click模块去实现，简单方便。</p><h1 id="click常用语法"><a class="markdownIt-Anchor" href="#click常用语法"></a> click常用语法</h1><h2 id="基础用法"><a class="markdownIt-Anchor" href="#基础用法"></a> 基础用法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> click</span><br><span class="line"></span><br><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option('--name','-name',default='johnw')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(name)</span><br></pre></td></tr></table></figure><h2 id="设置一个参数多个值"><a class="markdownIt-Anchor" href="#设置一个参数多个值"></a> 设置一个参数多个值</h2><p>其中多个值会被包装成一个tuple</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> click </span><br><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option('--name',nargs=2,type='str')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(name)</span><br></pre></td></tr></table></figure><h2 id="一个参数设置多个值并且类型不同"><a class="markdownIt-Anchor" href="#一个参数设置多个值并且类型不同"></a> 一个参数设置多个值，并且类型不同</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> click</span><br><span class="line"></span><br><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option('--ops',type=(unicode,int))</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(ops)</span>:</span></span><br><span class="line">    print(ops)</span><br></pre></td></tr></table></figure><h2 id="问答型参数"><a class="markdownIt-Anchor" href="#问答型参数"></a> 问答型参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import click</span><br><span class="line"></span><br><span class="line">@click.command()</span><br><span class="line">@click.option(&apos;--name&apos;,prompt=&quot;Your name is : &quot;)</span><br><span class="line">def main(name):</span><br><span class="line">    print(&quot;Hello &quot;,name)</span><br></pre></td></tr></table></figure><h2 id="密码型参数"><a class="markdownIt-Anchor" href="#密码型参数"></a> 密码型参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import click</span><br><span class="line"></span><br><span class="line">@click.command()</span><br><span class="line">@click.option(&apos;--password&apos;,prompt=True,hide_input=True,confirmation_prompt=True)</span><br><span class="line"></span><br><span class="line">def encrypt(password):</span><br><span class="line">    print(&apos;encrypted password&apos;)</span><br></pre></td></tr></table></figure><h2 id="几个参数"><a class="markdownIt-Anchor" href="#几个参数"></a> 几个参数</h2><ol><li>default：默认值</li><li>type： int,str,float</li><li>help: 提示信息</li></ol><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h1><p><a href="http://click.pocoo.org/6/options/#basic-value-options" target="_blank" rel="noopener">http://click.pocoo.org/6/options/#basic-value-options</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h1&gt;
&lt;p&gt;我们有时候要实现命令行带参数去执行函数的时候，可以使用click模块去实现，简单方便。&lt;/p&gt;
&lt;h1 id=&quot;click常用语法&quot;&gt;&lt;a cl
      
    
    </summary>
    
      <category term="python_modules" scheme="http://yoursite.com/categories/python-modules/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python模块-queue</title>
    <link href="http://yoursite.com/2018/07/01/python%E6%A8%A1%E5%9D%97-queue/"/>
    <id>http://yoursite.com/2018/07/01/python模块-queue/</id>
    <published>2018-07-01T15:29:19.000Z</published>
    <updated>2018-07-01T15:29:39.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>上次简单总结了python的多线程模块，这次主要学习一下python的queue模块，仔细通读下来，有两点</p><ol><li>在queue模块中，如果你要执行put的操作的时候，如果是多线程，就会比较难办，因为这个时候数据是无序的，机器也没办法知道哪个已经放进去了，哪个还没放进去，会变得混乱</li><li>如果是把它拿出来执行，那就很方便，因为这个是在一个队列里面。</li></ol><p>下面我们总结一下概念</p><h1 id="queue"><a class="markdownIt-Anchor" href="#queue"></a> queue</h1><p>queue实现了三种队列</p><ol><li>FIFO： 先进先出</li><li>LIFO：后进先出</li><li>priority queue：优先值低的先出去，优先值相同的，先进先出</li></ol><p>下面通过代码来学习一下队列多线程</p><h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime,sleep</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先是先起一个队列</span></span><br><span class="line">q = queue.Queue()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        item = q.get()</span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            print(<span class="string">"线程 &#123;&#125; 发现了一个None， 可以休息了. time:&#123;&#125;"</span>.format(i,ctime()))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        sleep(<span class="number">0.5</span>) <span class="comment"># do some work</span></span><br><span class="line">        print(<span class="string">"线程&#123;&#125;将任务&lt;&#123;&#125;&gt;给完成了。time : &#123;&#125;"</span>.format(i,item,ctime()))</span><br><span class="line">        q.task_done()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里开始往队列里面放东西</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        sleep(<span class="number">0.5</span>)</span><br><span class="line">        q.put(i)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始放，在这里就把需要的资源都放进去了。</span></span><br><span class="line">producer()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 起一个线程池</span></span><br><span class="line">work_threads = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其三个线程，加入线程池</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    work_threads.append(threading.Thread(target=work,args=(i,)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 线程启动开始消耗</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> work_threads:</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 阻塞队列，直到所有任务都完成了，在开始加入None</span></span><br><span class="line">q.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入None，以便完成任务</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    q.put(<span class="keyword">None</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 等待消耗的线程完成</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> work_threads:</span><br><span class="line">    t.join()</span><br></pre></td></tr></table></figure><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>理解了多线程+queue，下一篇进行实战！</p><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h1><p><a href="https://www.t00ls.net/articles-44516.html" target="_blank" rel="noopener">https://www.t00ls.net/articles-44516.html</a></p><p><a href="http://www.liujiangblog.com/course/python/59" target="_blank" rel="noopener">http://www.liujiangblog.com/course/python/59</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h1&gt;
&lt;p&gt;上次简单总结了python的多线程模块，这次主要学习一下python的queue模块，仔细通读下来，有两点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在queu
      
    
    </summary>
    
      <category term="python_modules" scheme="http://yoursite.com/categories/python-modules/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>常见的逻辑漏洞</title>
    <link href="http://yoursite.com/2018/06/30/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2018/06/30/常见的逻辑漏洞/</id>
    <published>2018-06-30T15:52:44.000Z</published>
    <updated>2018-06-30T15:54:16.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逻辑安全存在的前提"><a class="markdownIt-Anchor" href="#逻辑安全存在的前提"></a> 逻辑安全存在的前提</h1><blockquote><p>有效的区分每个用户，并且针对每个用户提供独立的服务内容，允许用户与服务器进行大量的交互<br>。web应用的攻击就是<mark>攻击者从零交互零权限到最后取得最高权限</mark>。以下分别总结几点逻辑安全的漏洞</p></blockquote><h1 id="用户管理功能漏洞"><a class="markdownIt-Anchor" href="#用户管理功能漏洞"></a> 用户管理功能漏洞</h1><h2 id="cookie-and-session"><a class="markdownIt-Anchor" href="#cookie-and-session"></a> Cookie and Session</h2><p>最大的漏洞就是避免cookie伪造，例如在cookies中存在一个字段为 admin: false，这个时候，如果黑客将其改为 true，那么就可以实现cookies的一个伪造，从而进行攻击。</p><h1 id="用户授权管理和安全分析"><a class="markdownIt-Anchor" href="#用户授权管理和安全分析"></a> 用户授权管理和安全分析</h1><p>授权管理分为以下几个部分</p><ol><li>注册</li><li>密码找回</li><li>登录</li><li>密码修改、绑定信息修改</li><li>管理权限</li></ol><p>下面总结一下，大概有哪些危险</p><h2 id="注册"><a class="markdownIt-Anchor" href="#注册"></a> 注册</h2><h4 id="面临的危险和解决方案"><a class="markdownIt-Anchor" href="#面临的危险和解决方案"></a> 面临的危险和解决方案</h4><ol><li>恶意重复注册</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#解决方案</span><br><span class="line">限制IP注册频率</span><br><span class="line">表单加上验证码</span><br><span class="line">姓名和身份证验证</span><br><span class="line">二次验证，例如绑定手机号码或者邮箱</span><br></pre></td></tr></table></figure><ol start="2"><li>注册用户与已经存在的用户重名</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#解决方案</span><br><span class="line">首先数据库字段，要加上验证，不允许重复</span><br><span class="line">对用户输入要做校验。</span><br></pre></td></tr></table></figure><ol start="3"><li>没有对用户输入进行校验，造成xss，sql注入</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#解决方案</span><br><span class="line">对用户输入要做校验.</span><br><span class="line">过滤特殊字符</span><br><span class="line">不使用sql拼接</span><br></pre></td></tr></table></figure><ol start="4"><li>mysql中，可能存在空格覆盖。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#解决方案</span><br><span class="line">对用户输入要做校验,去除空格。</span><br></pre></td></tr></table></figure><h2 id="密码找回"><a class="markdownIt-Anchor" href="#密码找回"></a> 密码找回</h2><p>面临的危险和解决方案</p><ol><li>服务器没有校验修改密码的token，或者token是可猜测破解的，这回造成任意密码修改【!】。这个是存在最多的漏洞，很常见。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加强token的安全性</span><br></pre></td></tr></table></figure><ol start="2"><li>session覆盖攻击,少见，即一个用户的session，会覆盖掉另一个用户的session，导致打开的时候，修改的其实是另一个用户的密码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">很少见，估计实现都有困难。</span><br></pre></td></tr></table></figure><h2 id="登录"><a class="markdownIt-Anchor" href="#登录"></a> 登录</h2><p>面临的危险和解决方案</p><ol><li>暴力破解用户密码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用验证码形式，用户三次输入错误，需要输入验证码，多次输入错误需要绑定的手机或者邮箱进行解锁</span><br></pre></td></tr></table></figure><ol start="2"><li>明文传输导致中间人攻击</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTPS</span><br><span class="line">HSTS</span><br></pre></td></tr></table></figure><ol start="3"><li>万能密码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">做好防止sql注入的漏洞</span><br></pre></td></tr></table></figure><ol start="4"><li>用户密码存储</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户密码应该使用hash+随机盐的形式进行存储。</span><br></pre></td></tr></table></figure><ol start="5"><li>登录提示</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不应该使用过于明显的登录提示</span><br></pre></td></tr></table></figure><h2 id="密码修改个人信息修改"><a class="markdownIt-Anchor" href="#密码修改个人信息修改"></a> 密码修改/个人信息修改</h2><ol><li>CSRF攻击</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加CSRF token和 refer 进行防御</span><br></pre></td></tr></table></figure><ol start="2"><li>确认用户本人操作</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要进行二次验证，确认是本人操作</span><br></pre></td></tr></table></figure><h2 id="管理权限漏洞"><a class="markdownIt-Anchor" href="#管理权限漏洞"></a> 管理权限漏洞</h2><ol><li>开发过程中没有对当前用户的一致性做校验工作。例如在flask中，个人中心需要登录才能看，但是如果你忘记了对当前用户的身份做一个校验，那么就会变成，只要随便登录一个用户，那么他就可以随便的修改或者查看他人的个人中心。</li></ol><p>代码实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&apos;/profile/&lt;username&gt;&apos;)</span><br><span class="line">@login_required</span><br><span class="line">def profile(username):</span><br><span class="line">    user = User.query.filter_by(username=username).first()</span><br><span class="line">    # 应该这么校验</span><br><span class="line">    if current_user == user:</span><br><span class="line">        ...</span><br><span class="line">    else:</span><br><span class="line">        flash(&quot;You have no permission to access this page.&quot;)</span><br><span class="line">        return redirect(url_for(&apos;index&apos;))</span><br></pre></td></tr></table></figure><ol start="2"><li>权限管理没做好，导致低权限用户可以访问高权限用户的页面。同上，做好权限校验</li></ol><h1 id="用户身份识别和安全防护"><a class="markdownIt-Anchor" href="#用户身份识别和安全防护"></a> 用户身份识别和安全防护</h1><p>这章主要讲的是验证码和二次验证码的安全，基本上可以概括为：</p><ol><li>无论哪种验证码，都应该要有一个过期时间。</li><li>为了保证安全，都不该可以被猜测</li></ol><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>下一步打算认认真真研究一下kali这个系统了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;逻辑安全存在的前提&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#逻辑安全存在的前提&quot;&gt;&lt;/a&gt; 逻辑安全存在的前提&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;有效的区分每个用户，并且针对每个用户提供独立的服务内容，允许用户与服务器进行
      
    
    </summary>
    
      <category term="web_security" scheme="http://yoursite.com/categories/web-security/"/>
    
    
      <category term="security" scheme="http://yoursite.com/tags/security/"/>
    
      <category term="xss" scheme="http://yoursite.com/tags/xss/"/>
    
  </entry>
  
  <entry>
    <title>python模块-threading</title>
    <link href="http://yoursite.com/2018/06/29/python%E6%A8%A1%E5%9D%97-threading/"/>
    <id>http://yoursite.com/2018/06/29/python模块-threading/</id>
    <published>2018-06-29T11:38:34.000Z</published>
    <updated>2018-06-29T11:39:44.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>众所周知，运行一个程序最重要的是它的执行效率，比如爬虫，要如何节省爬虫的时间，提高爬虫效率是一件很重要的事情。<br>虽然python的多线程是鸡肋，在任意时间内，只有一个python的解释器在解释python的bytecode。但也不是多线程就是没有用的，我们的代码分为两种，一种是计算密集型，一种是IO密集型，其中计算密集型主要是需要CPU进行大量的计算的，这个时候，python的多线程没什么用，反而可能会比单线程的效率差。而相对于IO密集型的代码，主要瓶颈在于网络的传输，硬盘IO之类的上面，这个时候，使用python多线程就可以提高其效率。<br>上面的理解可能稍显有些片面，但不管如何，偏底层的东西先做一个了解，先学会一下如何用python写多线程</p><h1 id="threadingthread"><a class="markdownIt-Anchor" href="#threadingthread"></a> threading.Thread</h1><p>以一段代码为例，做一下学习</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime,sleep</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        print(<span class="string">"The thread name is &#123;&#125; and start in &#123;&#125;"</span>.format(threading.current_thread().name,ctime()))</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">"The thread name is &#123;&#125; and end in &#123;&#125;"</span>.format(threading.current_thread().name,ctime()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        print(<span class="string">"The thread name is &#123;&#125; and start in &#123;&#125;"</span>.format(threading.current_thread().name,ctime()))</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">"The thread name is &#123;&#125; and end in &#123;&#125;"</span>.format(threading.current_thread().name,ctime()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">"__main__"</span> == __name__:</span><br><span class="line">    t1 = threading.Thread(target=thread1)</span><br><span class="line">    t2 = threading.Thread(target=thread2)</span><br><span class="line"></span><br><span class="line">    threads = []</span><br><span class="line">    threads.append(t1)</span><br><span class="line">    threads.append(t2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        print(t.daemon)</span><br><span class="line">        t.start()</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"The thread name is &#123;&#125; and end in &#123;&#125;"</span>.format(threading.current_thread().name,ctime()))</span><br><span class="line"><span class="comment"># result： 最后一个线程退出，用时两秒。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">The thread name is Thread-1 and start in Fri Jun 29 16:34:43 2018</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">The thread name is Thread-2 and start in Fri Jun 29 16:34:43 2018</span></span><br><span class="line"><span class="string">The thread name is MainThread and end in Fri Jun 29 16:34:43 2018</span></span><br><span class="line"><span class="string">The thread name is Thread-2 and end in Fri Jun 29 16:34:44 2018</span></span><br><span class="line"><span class="string">The thread name is Thread-1 and end in Fri Jun 29 16:34:44 2018</span></span><br><span class="line"><span class="string">The thread name is Thread-2 and start in Fri Jun 29 16:34:44 2018</span></span><br><span class="line"><span class="string">The thread name is Thread-1 and start in Fri Jun 29 16:34:44 2018</span></span><br><span class="line"><span class="string">The thread name is Thread-2 and end in Fri Jun 29 16:34:45 2018</span></span><br><span class="line"><span class="string">The thread name is Thread-1 and end in Fri Jun 29 16:34:45 2018</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="daemon属性"><a class="markdownIt-Anchor" href="#daemon属性"></a> daemon属性</h2><p>如果你设置一个线程的daemon属性为True的话，说明这个线程是不重要的，整个python的程序无需等待这个线程即可结束。<br>（注意，很多地方说是主线程结束，但是我实验了一下，主线程已经执行完了，但是其子线程还是会继续执行下去的。）<br>从代码可见，其daemon属性，从一开始就是False的。<br>但是如果你将daemon设置为True，那么程序将不会等待，主线程结束，程序就会退出，我们可以试着将代码改为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">t1 = threading.Thread(target=thread1,daemon=<span class="keyword">True</span>)</span><br><span class="line">t2 = threading.Thread(target=thread2,daemon=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line">threads.append(t1)</span><br><span class="line">threads.append(t2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    print(t.daemon)</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"The thread name is &#123;&#125; and end in &#123;&#125;"</span>.format(threading.current_thread().name,ctime()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># result</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string">The thread name is Thread-1 and start in Fri Jun 29 16:39:36 2018</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string">The thread name is Thread-2 and start in Fri Jun 29 16:39:36 2018</span></span><br><span class="line"><span class="string">The thread name is MainThread and end in Fri Jun 29 16:39:36 2018</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="join方法"><a class="markdownIt-Anchor" href="#join方法"></a> join方法</h2><p>官方解释，join方法是用于阻塞线程的，一般要等待当前线程完成，才会进行下一个线程。根据实验，如果你对于每个线程都加一个join方法的话，那么就等于将程序变成了单线程，所以一般只给最后执行的子线程加一个join，这样，主线程就不会提前退出。</p><ol><li>每个子线程都加join</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    print(t.daemon)</span><br><span class="line">    t.start()</span><br><span class="line">    t.join()</span><br></pre></td></tr></table></figure><ol start="2"><li>先启动,再遍历子线程加join</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for t in threads:</span><br><span class="line">    print(t.daemon)</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">for t in threads:</span><br><span class="line">    t.join()</span><br></pre></td></tr></table></figure><h2 id="start方法"><a class="markdownIt-Anchor" href="#start方法"></a> start方法</h2><p>这个方法很直白，就是启动一个线程。</p><h1 id="线程类"><a class="markdownIt-Anchor" href="#线程类"></a> 线程类</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime,sleep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入多线程类</span></span><br><span class="line"><span class="comment"># 只能重写两个方法，一个__init__ 一个是run</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">            print(<span class="string">"The thread name is &#123;&#125; and start in &#123;&#125;"</span>.format(threading.current_thread().name,ctime()))</span><br><span class="line">            sleep(<span class="number">1</span>)</span><br><span class="line">            print(<span class="string">"The thread name is &#123;&#125; and end in &#123;&#125;"</span>.format(threading.current_thread().name,ctime()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        mt = MyThread()</span><br><span class="line">        threads.append(mt)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">The thread name is Thread-1 and start in Fri Jun 29 17:04:41 2018</span></span><br><span class="line"><span class="string">The thread name is Thread-2 and start in Fri Jun 29 17:04:41 2018</span></span><br><span class="line"><span class="string">The thread name is Thread-1 and end in Fri Jun 29 17:04:42 2018</span></span><br><span class="line"><span class="string">The thread name is Thread-1 and start in Fri Jun 29 17:04:42 2018</span></span><br><span class="line"><span class="string">The thread name is Thread-2 and end in Fri Jun 29 17:04:42 2018</span></span><br><span class="line"><span class="string">The thread name is Thread-2 and start in Fri Jun 29 17:04:42 2018</span></span><br><span class="line"><span class="string">The thread name is Thread-1 and end in Fri Jun 29 17:04:43 2018</span></span><br><span class="line"><span class="string">The thread name is Thread-2 and end in Fri Jun 29 17:04:43 2018</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>以上学习了python多线程的简单用法，实际中用法肯定比较复杂，比如说锁，比如说队列的多线程，还有待探索。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h1&gt;
&lt;p&gt;众所周知，运行一个程序最重要的是它的执行效率，比如爬虫，要如何节省爬虫的时间，提高爬虫效率是一件很重要的事情。&lt;br&gt;
虽然python的多线程
      
    
    </summary>
    
      <category term="python_modules" scheme="http://yoursite.com/categories/python-modules/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python模块-logging</title>
    <link href="http://yoursite.com/2018/06/29/python%E6%A8%A1%E5%9D%97-logging/"/>
    <id>http://yoursite.com/2018/06/29/python模块-logging/</id>
    <published>2018-06-29T11:36:55.000Z</published>
    <updated>2018-06-29T11:38:54.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工作流"><a class="markdownIt-Anchor" href="#工作流"></a> 工作流</h1><p>理解log模块，首先应该理解其工作流，下面通过例子来说明其工作流<br><a href="http://xn--main-ko8f602i0g9e.py" target="_blank" rel="noopener">首先是main.py</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import sub</span><br><span class="line">import sub2</span><br><span class="line">import logging</span><br><span class="line">import logging.config</span><br><span class="line">from config import LOGGING</span><br><span class="line">logging.config.dictConfig(LOGGING)</span><br><span class="line">logger = logging.getLogger(&quot;main&quot;)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    sub.sub1()</span><br><span class="line">    logger.error(&quot;main debug&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if &quot;__main__&quot; == __name__:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>在这里我们引入了sub 和sub2，先不理会其配置文件，假设已经写好配置文件了。<br><a href="http://xn--sub-yx1ej16g9sg.py" target="_blank" rel="noopener">其次是sub.py</a> 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">sub_logger = logging.getLogger(&quot;main.sub&quot;)</span><br><span class="line">def sub1():</span><br><span class="line">    print(&quot;Hello This is sub1&quot;)</span><br><span class="line">    sub_logger.debug(&quot;This is sub1&quot;)</span><br></pre></td></tr></table></figure><p>我们可以看到，如果是多模块引入log机制，可以直接写成 如上面的形式。这种继承机制，让我们可以很方便的复用log.</p><h1 id="理解配置文件"><a class="markdownIt-Anchor" href="#理解配置文件"></a> 理解配置文件</h1><p>配置文件一般有两种：<br>字典形式<br>配置文件形式<br>至于哪种形式更好，就众说纷坛，有说字典形式比较好，因为都是python文件，我们写代码自定义程度更高，一种说配置文件形式其可读性更好。这里没有一个决断，我们首先使用字典形式，用代码来定义配置文件。<br>在配置文件里面，log有四个类，分别是</p><ol><li>formatters</li><li>handlers</li><li>filters</li><li>loggers</li></ol><h2 id="formatters"><a class="markdownIt-Anchor" href="#formatters"></a> formatters</h2><p>首先我们来看一下formatters</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;formatters&quot;:&#123;</span><br><span class="line">  # 标准模式</span><br><span class="line">  &quot;standard&quot;:&#123;</span><br><span class="line">     &apos;format&apos;:&apos;[%(asctime)s][%(threadName)s:%(thread)d][%(name)s:%(levelname)s(%(lineno)d)]\n[%(module)s:%(funcName)s]:%(message)s&apos;</span><br><span class="line">  &#125;</span><br><span class="line">  # 简单模式</span><br><span class="line">  &quot;brief&quot;:&#123;</span><br><span class="line">    &quot;format&quot;:&apos;[%(message)s]&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 standard 和 brief 都是我们可以自定义的名字<br>接下来我们看一下formatters的格式化字符串有哪些，并且分别是什么含义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">%(name)s Logger的名字</span><br><span class="line">%(levelno)s 数字形式的日志级别</span><br><span class="line">%(levelname)s 文本形式的日志级别</span><br><span class="line">%(pathname)s 调用日志输出函数的模块的完整路径名，可能没有</span><br><span class="line">%(filename)s 调用日志输出函数的模块的文件名</span><br><span class="line">%(module)s 调用日志输出函数的模块名</span><br><span class="line">%(funcName)s 调用日志输出函数的函数名</span><br><span class="line">%(lineno)d 调用日志输出函数的语句所在的代码行</span><br><span class="line">%(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示</span><br><span class="line">%(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数</span><br><span class="line">%(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒</span><br><span class="line">%(thread)d 线程ID。可能没有</span><br><span class="line">%(threadName)s 线程名。可能没有</span><br><span class="line">%(process)d 进程ID。可能没有</span><br><span class="line">%(message)s 用户输出的消息</span><br></pre></td></tr></table></figure><h2 id="handlers"><a class="markdownIt-Anchor" href="#handlers"></a> handlers</h2><p>handlers模块，顾名思义，就是处理log的模块，在这里我们要定义，log的输出是文件形式还是命令行输出形式，文件形式的话，其文件的存储路径，文件大小改如何分割等问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&quot;handlers&quot;:&#123;</span><br><span class="line">  &quot;console&quot;:&#123;</span><br><span class="line">     &apos;level&apos;:&apos;DEBUG&apos;,    #输出信息的最低级别</span><br><span class="line">     &apos;class&apos;:&apos;logging.StreamHandler&apos;,</span><br><span class="line">     &apos;formatter&apos;:&apos;standard&apos;, #使用standard格式</span><br><span class="line">      &apos;filters&apos;: [&apos;require_debug_true&apos;,], #仅当 DEBUG = True 该处理器才生效,一般没用。</span><br><span class="line">  &#125;,</span><br><span class="line">  &apos;log&apos;:&#123;</span><br><span class="line">      &apos;level&apos;:&apos;DEBUG&apos;,</span><br><span class="line">      &apos;class&apos;:&apos;logging.handlers.RotatingFileHandler&apos;,</span><br><span class="line">      &apos;formatter&apos;:&apos;standard&apos;,</span><br><span class="line">      &apos;filename&apos;:os.path.join(BASE_DIR, &apos;debug.log&apos;), #输出位置</span><br><span class="line">      &apos;maxBytes&apos;:1024*1024*5, #文件大小 5M</span><br><span class="line">      &apos;backupCount&apos;: 5, #备份份数</span><br><span class="line">       &apos;encoding&apos;: &apos;utf8&apos;, #文件编码</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，这里的console和log也是我们自定义的名字，我们还可以定义其他的，然后选择日志的输出位置，或者设置变量为日志的输出位置</p><h2 id="loggers"><a class="markdownIt-Anchor" href="#loggers"></a> loggers</h2><p>loggers是日志的全局管理器，我们会在这里定义一个管理器，在后面调用的时候，我们要获得这个管理器的名字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 日志管理器集合</span><br><span class="line">    &apos;loggers&apos;:&#123;</span><br><span class="line">        #管理器</span><br><span class="line">        &quot;main&quot;:&#123;</span><br><span class="line">            &apos;handlers&apos;:[&apos;console&apos;, &apos;main_log&apos;],</span><br><span class="line">            &apos;level&apos;:&apos;DEBUG&apos;,</span><br><span class="line">            &apos;propagate&apos;:True, #是否传递给父记录器</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中 main 是我们自己定义的名字，需要注意的是，如果使用的logger没有在这里定义名字，那么这些配置将无用。</p><h1 id="调用logger"><a class="markdownIt-Anchor" href="#调用logger"></a> 调用logger</h1><p>这里其实也是前面有提到的东西，我们要引入logging和logging.config。（注意，不能只单纯引入logging，会报错）<br>在main.py中我们 这么引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">import logging.config</span><br><span class="line">from config import LOGGING</span><br><span class="line">logging.config.dictConfig(LOGGING)</span><br><span class="line">logger = logging.getLogger(&quot;main&quot;</span><br></pre></td></tr></table></figure><p>其中这个main 就是我们定义在配置文件中管理器的main<br>根据其工作流原理，其自模块也需要进行log记录，这个时候我们就不需要写配置文件了，直接使用这个配置文件即可<br>在sub.py中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">sub_logger = logging.getLogger(&quot;main.sub&quot;)</span><br><span class="line">def sub1():</span><br><span class="line">    print(&quot;Hello This is sub1&quot;)</span><br><span class="line">    sub_logger.debug(&quot;This is sub1&quot;)</span><br></pre></td></tr></table></figure><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>就这样，我们模拟了如何在python中使用日志记录，这对于开发来说是一件提高效率和产品质量很重要的事情</p><h1 id="代码地址"><a class="markdownIt-Anchor" href="#代码地址"></a> 代码地址</h1><p><a href="https://github.com/TheFifthMan/python_modules" target="_blank" rel="noopener">https://github.com/TheFifthMan/python_modules</a></p><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h1><p><a href="http://yshblog.com/blog/125" target="_blank" rel="noopener">http://yshblog.com/blog/125</a></p><p><a href="https://segmentfault.com/a/1190000015143449" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015143449</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;工作流&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#工作流&quot;&gt;&lt;/a&gt; 工作流&lt;/h1&gt;
&lt;p&gt;理解log模块，首先应该理解其工作流，下面通过例子来说明其工作流&lt;br&gt;
&lt;a href=&quot;http://xn--main-ko8f602
      
    
    </summary>
    
      <category term="python_modules" scheme="http://yoursite.com/categories/python-modules/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>kali下使用Tor网络</title>
    <link href="http://yoursite.com/2018/06/27/kali%E4%B8%8B%E4%BD%BF%E7%94%A8Tor%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2018/06/27/kali下使用Tor网络/</id>
    <published>2018-06-27T15:22:42.000Z</published>
    <updated>2018-06-27T15:26:17.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><blockquote><p>记录一下如何在命令行下面使用tor网络</p></blockquote><h1 id="kali下安装tor"><a class="markdownIt-Anchor" href="#kali下安装tor"></a> Kali下安装tor</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install tor</span><br></pre></td></tr></table></figure><h1 id="架梯子"><a class="markdownIt-Anchor" href="#架梯子"></a> 架梯子</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup sslocal -c ss.json</span><br></pre></td></tr></table></figure><h1 id="编辑tor配置添加"><a class="markdownIt-Anchor" href="#编辑tor配置添加"></a> 编辑tor配置,添加</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/tor/torrc /etc/tor/torrc.backup</span><br><span class="line">vim /etc/tor/torrc</span><br><span class="line"></span><br><span class="line">在里面添加</span><br><span class="line">...</span><br><span class="line">RunAsDaemon 1</span><br><span class="line">Socks5Proxy 127.0.0.1:1080</span><br><span class="line"># 重点，每隔n时间进行ip更换，时间单位为秒</span><br><span class="line">MaxCircuitDirtiness 900</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="启动"><a class="markdownIt-Anchor" href="#启动"></a> 启动</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service tor@default start</span><br></pre></td></tr></table></figure><h1 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、创建一个用户，运行tor；</span><br><span class="line"></span><br><span class="line">2、编辑“start-tor-browser”文件，找到下面语句，删除或注释掉即可运行：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#if [ “`id -u`” -eq 0 ]; then</span><br><span class="line"></span><br><span class="line"># complain “The Tor Browser Bundle should not be run as root. Exiting.”</span><br><span class="line"></span><br><span class="line"># exit 1</span><br><span class="line"></span><br><span class="line">#fi</span><br></pre></td></tr></table></figure><h1 id="关闭"><a class="markdownIt-Anchor" href="#关闭"></a> 关闭</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service tor@default stop</span><br></pre></td></tr></table></figure><h1 id="配置全局代理"><a class="markdownIt-Anchor" href="#配置全局代理"></a> 配置全局代理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:9050</span><br></pre></td></tr></table></figure><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><blockquote><p>完成这一切的前提，是你有一个梯子…</p></blockquote><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h1><p><a href="https://evi1cg.me/archives/Tor_Fronting.html" target="_blank" rel="noopener">https://evi1cg.me/archives/Tor_Fronting.html</a></p><p><a href="http://www.cnblogs.com/iamstudy/articles/tor_usage_in_pentest.html" target="_blank" rel="noopener">http://www.cnblogs.com/iamstudy/articles/tor_usage_in_pentest.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;记录一下如何在命令行下面使用tor网络&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;kali下安装tor&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Linux_security" scheme="http://yoursite.com/categories/Linux-security/"/>
    
    
      <category term="kali" scheme="http://yoursite.com/tags/kali/"/>
    
  </entry>
  
  <entry>
    <title>文件上传漏洞-理论</title>
    <link href="http://yoursite.com/2018/06/26/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E-%E7%90%86%E8%AE%BA/"/>
    <id>http://yoursite.com/2018/06/26/文件上传漏洞-理论/</id>
    <published>2018-06-25T16:09:00.000Z</published>
    <updated>2018-06-25T16:09:33.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h1><blockquote><p>攻击者利用web应用对上传文件过滤不严的漏洞，将应用程序不该允许的文件类型上传到web服务器上，并成功解析。</p></blockquote><h1 id="文件上传攻击的前提"><a class="markdownIt-Anchor" href="#文件上传攻击的前提"></a> 文件上传攻击的前提</h1><ol><li>网站具有上传功能</li><li>上传的文件能够被web服务器解析并执行</li><li>知道上传后的文件路径和文件名称</li><li>目标文件可以呗用户访问</li></ol><h1 id="文件上传漏洞的攻与防"><a class="markdownIt-Anchor" href="#文件上传漏洞的攻与防"></a> 文件上传漏洞的攻与防</h1><h1 id="攻击"><a class="markdownIt-Anchor" href="#攻击"></a> 攻击</h1><ol><li>判断是否为js防护或者MIME防护</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用burp suite抓取流量，进行伪造后重放攻击</span><br></pre></td></tr></table></figure><ol start="2"><li>针对黑名单过滤</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 多次测试过滤文件名。例如php，php4，php5</span><br><span class="line">2. 判断大小写绕过。Php，PHP</span><br><span class="line">3. 特殊文件名构造：php.shell. , php.shell_</span><br><span class="line">4. %00 截断。 phpshell.php%00.jpg</span><br><span class="line">5. 考虑web中间件版本漏洞。如httpd，tomcat，nginx,struts2等</span><br><span class="line">6. 如果web服务器是检测文件内容的，那么就可以使用修改文件头进行上传webshell</span><br></pre></td></tr></table></figure><h1 id="防御"><a class="markdownIt-Anchor" href="#防御"></a> 防御</h1><ol><li>前端进行js防御 [<mark>可绕过</mark>]</li><li>后端进行MIME防御 [<mark>可绕过</mark>]</li><li>后端进行白名单防御</li></ol><blockquote><p>只允许相应格式的文件进行上传，其余格式的文件丢弃</p></blockquote><ol start="4"><li>后端黑名单过滤 [<mark>可绕过</mark>]</li></ol><blockquote><p>不允许相应格式的文件进行上传</p></blockquote><ol start="5"><li>文件重命名防御</li></ol><blockquote><p>将用户上传的文件进行重命名，防止截断和绕过</p></blockquote><ol start="6"><li>文件名不该含有特殊符号，防止xss之类的攻击</li><li>文件内容检测。[<mark>可绕过</mark>]</li></ol><blockquote><p>有些图像文件，如果以网页脚本形式进行展示的话，那么就可能执行木马。针对文件内容进行检测，必要时候可以使用图像二次渲染之类的技术进行防护。</p></blockquote><ol start="8"><li>文件名长度需要做限制</li><li>需要有三个文件夹，一个存放临时文件，一个存放正式文件，一个存放病毒文件，并且其上传的文件都不应该具有x权限</li><li>用户上传文件后应该经过杀毒软件的扫描，如果是病毒文件，应该放置到隔离的文件中，做为审计资料，如果不是，应该由临时文件夹移动到正式文件夹</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概念&quot;&gt;&lt;/a&gt; 概念&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;攻击者利用web应用对上传文件过滤不严的漏洞，将应用程序不该允许的文件类型上传到web服务器上，并成功解析。&lt;/p&gt;

      
    
    </summary>
    
      <category term="web_security" scheme="http://yoursite.com/categories/web-security/"/>
    
    
      <category term="文件上传漏洞" scheme="http://yoursite.com/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>Kali下配置ss服务</title>
    <link href="http://yoursite.com/2018/06/25/Kali%E4%B8%8B%E9%85%8D%E7%BD%AEss%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2018/06/25/Kali下配置ss服务/</id>
    <published>2018-06-25T14:17:29.000Z</published>
    <updated>2018-06-30T11:48:40.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="步骤"><a class="markdownIt-Anchor" href="#步骤"></a> 步骤</h1><ol><li>首先你必须要有一个ss服务器</li><li>安装shadowsocks</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure><ol start="3"><li>修改python包错误</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/lib/python2.7/dist-packages/shadowsocks/crypto/openssl.py</span><br><span class="line"></span><br><span class="line">将第52行libcrypto.EVP_CIPHER_CTX_cleanup.argtypes = (c_void_p,)</span><br><span class="line">改为libcrypto.EVP_CIPHER_CTX_reset.argtypes = (c_void_p,)</span><br><span class="line"></span><br><span class="line">再次搜索cleanup（全文件共2处，此处位于111行），将libcrypto.EVP_CIPHER_CTX_cleanup(self._ctx)</span><br><span class="line">改为libcrypto.EVP_CIPHER_CTX_reset(self._ctx)</span><br><span class="line"></span><br><span class="line">save and restart shadowsocks service</span><br></pre></td></tr></table></figure><ol start="4"><li>增加ss服务器配置</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    &quot;server&quot;:&quot;服务器地址&quot;,</span><br><span class="line">    &quot;server_port&quot;:服务器端口号, &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;local_port&quot;:1080, </span><br><span class="line">    password&quot;:&quot;密码&quot;, </span><br><span class="line">    &quot;timeout&quot;:300, </span><br><span class="line">    &quot;method&quot;:&quot;加密方式&quot;, </span><br><span class="line">    &quot;fast_open&quot;: true,</span><br><span class="line">    &quot;workers&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>启动服务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sslocal -c /etc/shadowsocks.json</span><br></pre></td></tr></table></figure><ol start="6"><li>配置 /etc/proxychains.conf</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">socks5 127.0.0.1 1080</span><br></pre></td></tr></table></figure><ol start="7"><li>使用proxychains启动应用程序</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxychains firefox www.google.com</span><br><span class="line">proxychains msfconsole</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;步骤&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#步骤&quot;&gt;&lt;/a&gt; 步骤&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;首先你必须要有一个ss服务器&lt;/li&gt;
&lt;li&gt;安装shadowsocks&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;hi
      
    
    </summary>
    
      <category term="Linux_security" scheme="http://yoursite.com/categories/Linux-security/"/>
    
    
      <category term="kali" scheme="http://yoursite.com/tags/kali/"/>
    
  </entry>
  
  <entry>
    <title>4-Linux的远程认证</title>
    <link href="http://yoursite.com/2018/06/24/4-Linux%E7%9A%84%E8%BF%9C%E7%A8%8B%E8%AE%A4%E8%AF%81/"/>
    <id>http://yoursite.com/2018/06/24/4-Linux的远程认证/</id>
    <published>2018-06-24T07:35:37.000Z</published>
    <updated>2018-06-24T07:39:16.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="增强ssh安全性"><a class="markdownIt-Anchor" href="#增强ssh安全性"></a> 增强ssh安全性</h1><h3 id="改变ssh的端口"><a class="markdownIt-Anchor" href="#改变ssh的端口"></a> 改变ssh的端口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cp /ect/ssh/sshd_onfig /etc/ssh/sshd_config.backup</span><br><span class="line"></span><br><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line">...</span><br><span class="line">Port 3333</span><br><span class="line"></span><br><span class="line">service sshd restart</span><br></pre></td></tr></table></figure><h3 id="禁止root直接登录"><a class="markdownIt-Anchor" href="#禁止root直接登录"></a> 禁止root直接登录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line">...</span><br><span class="line">PermissionRootLogin no</span><br><span class="line">...</span><br><span class="line">service sshd restart</span><br></pre></td></tr></table></figure><h3 id="只允许一部分用户登录"><a class="markdownIt-Anchor" href="#只允许一部分用户登录"></a> 只允许一部分用户登录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line">...</span><br><span class="line">AllowUsers user1 user2</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">service sshd restart</span><br></pre></td></tr></table></figure><h3 id="使用密钥登录服务器"><a class="markdownIt-Anchor" href="#使用密钥登录服务器"></a> 使用密钥登录服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 首先在本地生成一个私钥和公钥。客户端</span><br><span class="line">ssh-keygen-t rsa</span><br><span class="line"></span><br><span class="line">2. 将客户端的公钥上传到服务器端</span><br><span class="line">ssh-copy-id -p 33 linux@172.16.190.901</span><br><span class="line"></span><br><span class="line">3. 登录</span><br><span class="line">ssh -p 33 linux@172.111.111.111</span><br></pre></td></tr></table></figure><h3 id="禁止密码登录"><a class="markdownIt-Anchor" href="#禁止密码登录"></a> 禁止密码登录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line">...</span><br><span class="line">PasswordAuthentication      no</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">service sshd restart</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;增强ssh安全性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#增强ssh安全性&quot;&gt;&lt;/a&gt; 增强ssh安全性&lt;/h1&gt;
&lt;h3 id=&quot;改变ssh的端口&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#改变s
      
    
    </summary>
    
      <category term="Linux_security" scheme="http://yoursite.com/categories/Linux-security/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="security" scheme="http://yoursite.com/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>3-Linux的本地认证</title>
    <link href="http://yoursite.com/2018/06/24/3-Linux%E7%9A%84%E6%9C%AC%E5%9C%B0%E8%AE%A4%E8%AF%81/"/>
    <id>http://yoursite.com/2018/06/24/3-Linux的本地认证/</id>
    <published>2018-06-24T07:35:11.000Z</published>
    <updated>2018-06-24T07:36:23.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><ul><li>[x] 用户认证和日志记录</li><li>[x] 限制用户登录的能力</li><li>[x] 使用acct监视用户行为</li><li>[x] 定义用户授权控制</li><li>[ ] 使用USB设备和PAM进行登录</li></ul><h1 id="日志记录"><a class="markdownIt-Anchor" href="#日志记录"></a> 日志记录</h1><h3 id="varlog"><a class="markdownIt-Anchor" href="#varlog"></a> /var/log</h3><blockquote><p>存放着各种log</p></blockquote><h3 id="查看特定账号的错误登录尝试"><a class="markdownIt-Anchor" href="#查看特定账号的错误登录尝试"></a> 查看特定账号的错误登录尝试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lastb root</span><br></pre></td></tr></table></figure><h3 id="查看内存中缓存的内核信息"><a class="markdownIt-Anchor" href="#查看内存中缓存的内核信息"></a> 查看内存中缓存的内核信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg</span><br></pre></td></tr></table></figure><h3 id="查看最近某用户登录信息"><a class="markdownIt-Anchor" href="#查看最近某用户登录信息"></a> 查看最近某用户登录信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">last</span><br></pre></td></tr></table></figure><h3 id="查看最后一次登录"><a class="markdownIt-Anchor" href="#查看最后一次登录"></a> 查看最后一次登录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lastlog</span><br></pre></td></tr></table></figure><h1 id="限制用户登录"><a class="markdownIt-Anchor" href="#限制用户登录"></a> 限制用户登录</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">usermod -s /usr/bim/nologin user1</span><br><span class="line">passwd -l user1</span><br><span class="line">usermod -l user1</span><br><span class="line"># 解锁</span><br><span class="line">passwd -u user1</span><br><span class="line">usermod -u user1</span><br></pre></td></tr></table></figure><h1 id="使用acct监视用户"><a class="markdownIt-Anchor" href="#使用acct监视用户"></a> 使用acct监视用户</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-get install acct</span><br><span class="line"></span><br><span class="line">查询特定用户执行过的命令</span><br><span class="line">lastcomm root</span><br></pre></td></tr></table></figure><h1 id="定义用户用户授权限制"><a class="markdownIt-Anchor" href="#定义用户用户授权限制"></a> 定义用户用户授权限制</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim sudoers</span><br><span class="line"># 每次切换root权限都需要输入密码</span><br><span class="line">Defaults user1 timestamp_timeout=0</span><br></pre></td></tr></table></figure><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>这章，比较没写什么有价值的东西。单纯了解了一些linux的操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;[x] 用户认证和日志记录&lt;/li&gt;
&lt;li&gt;[x] 限制用户登录的能力&lt;/li&gt;
&lt;li&gt;[x] 使用acct监视用户行为&lt;/li
      
    
    </summary>
    
      <category term="Linux_security" scheme="http://yoursite.com/categories/Linux-security/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="security" scheme="http://yoursite.com/tags/security/"/>
    
  </entry>
  
</feed>
